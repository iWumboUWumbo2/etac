// A stub for an Eta CUP specification.
package aar226_akc55_ayc62_ahl88;

import java_cup.runtime.*;
import aar226_akc55_ayc62_ahl88.newast.*;
import aar226_akc55_ayc62_ahl88.newast.definitions.*;
import aar226_akc55_ayc62_ahl88.newast.declarations.*;
import aar226_akc55_ayc62_ahl88.newast.expr.*;
import aar226_akc55_ayc62_ahl88.newast.stmt.*;
import aar226_akc55_ayc62_ahl88.newast.stmt.declstmt.*;
import aar226_akc55_ayc62_ahl88.newast.expr.arrayaccessexpr.*;
import aar226_akc55_ayc62_ahl88.newast.expr.arrayliteral.*;
import aar226_akc55_ayc62_ahl88.newast.expr.binop.*;
import aar226_akc55_ayc62_ahl88.newast.expr.binop.intbop.*;
import aar226_akc55_ayc62_ahl88.newast.expr.binop.boolbop.*;
import aar226_akc55_ayc62_ahl88.newast.expr.unop.*;
import aar226_akc55_ayc62_ahl88.newast.expr.unop.intuop.*;
import aar226_akc55_ayc62_ahl88.newast.expr.unop.booluop.*;
import aar226_akc55_ayc62_ahl88.Errors.SyntaxError;


import aar226_akc55_ayc62_ahl88.newast.expr.*;
import java.util.ArrayList;

// You might want to add types to these declarations.
parser RhParser {:
    public void syntax_error(Symbol cur_token){
        throw new SyntaxError(cur_token.left,cur_token.right ,"Parsing error " + cur_token.value());
    }
:};

terminal String     IDENTIFIER;
terminal String     STRING_LITERAL;
terminal String     CHARACTER_LITERAL;
terminal Long       INTEGER_LITERAL;
terminal Boolean    BOOL_LITERAL;
terminal            INT, BOOL;

terminal IF, ELSE, WHILE, RETURN, USE, LENGTH, PLUS, MINUS, TIMES, HI_MULT,
  DIVIDE, MODULO, NOT, LT, LEQ, GT, GEQ, AND, OR, EQUAL, NOT_EQUAL, GETS,
  OPEN_BRACKET, CLOSE_BRACKET, OPEN_PAREN, CLOSE_PAREN, OPEN_BRACE, CLOSE_BRACE,
  COLON, COMMA, SEMICOLON, UNDERSCORE, UMINUS,MAX_NUM, BREAK, NULL, RECORD, PERIOD;

nonterminal Program                 program;
nonterminal ArrayList<Use>          importUseStar;
nonterminal Use                     use_component;
nonterminal ArrayList<Definition>   definitionStar;
nonterminal Definition              definition;
nonterminal Method                  method;
nonterminal ArrayList<AnnotatedTypeDecl>         emptyBracketDecl_star;
nonterminal ArrayList<AnnotatedTypeDecl>         emptyBracketDecl_plus;
nonterminal AnnotatedTypeDecl       emptyBracketDecl;
nonterminal ArrayList<Type>         emptyBracketType_plus;
nonterminal Type                    emptyBracketType;
nonterminal Dimension               emptyDimension_star;
nonterminal Definition              globalDecl;
nonterminal Definition              newGlob;
nonterminal Expr                    value;
nonterminal Expr                    expr;
nonterminal Block                   block;
nonterminal ArrayList<Expr>         exprList;
nonterminal Stmt                    stmt;
nonterminal ArrayList<Stmt>         statement_star;
nonterminal Stmt                    declaration_assign_stmt;
nonterminal Stmt                    multi_declaration_assign_stmt;
nonterminal ArrayList<Expr>         right_side;
nonterminal Return                  return;
nonterminal ArrayList<Decl>         type_list;
nonterminal ArrayList<Expr>         fullBracketPlus;
nonterminal ArrAccessDecl           fullBracketType;
nonterminal ArrayList<Expr>         valueList;
nonterminal ArrAccessDecl           fullBracketAss;
nonterminal ArrayList<AnnotatedTypeDecl> glob_type_list;
//Rho
nonterminal Dimension              rhoEmptyDimension_star;
nonterminal Type                   rhoEmptyBracketType;
nonterminal ArrayList<Type>        rhoEmptyBracketType_plus;
nonterminal AnnotatedTypeDecl      rhoEmptyBracketDecl;
nonterminal ArrayList<AnnotatedTypeDecl>        rhoEmptyBracketDecl_plus;
nonterminal ArrayList<Id>           identifier_plus;
nonterminal ArrayList<AnnotatedTypeDecl>         rhoMultiDecl;
nonterminal ArrayList<AnnotatedTypeDecl>         fieldDecl;
nonterminal RecordDef                  record;
nonterminal ArrayList<AnnotatedTypeDecl> fieldDeclPlus;
nonterminal ArrayList<AnnotatedTypeDecl> multi_declaration_stmt;
nonterminal ArrayList<Decl> recordaccessdeclarray;
nonterminal RecordAccessDecl recordaccessdecl;

precedence nonassoc IF;
precedence nonassoc ELSE;

// function call
precedence left OR;
precedence left AND;
precedence left EQUAL,NOT_EQUAL;
precedence left LT,LEQ,GEQ,GT;
precedence left PLUS,MINUS;
precedence left TIMES,HI_MULT,DIVIDE,MODULO;
precedence left PERIOD;
precedence nonassoc NOT, UMINUS;// ??? negation?
precedence left OPEN_BRACKET,CLOSE_BRACKET,OPEN_PAREN,CLOSE_PAREN;
precedence left PERIOD;

start with program;

program ::=
    importUseStar:ius definitionStar:dl {: RESULT = new Program(ius, dl,1,1);:}
;

importUseStar ::=
    importUseStar:ius use_component:u {: ius.add(u); RESULT = ius; :}
    | {: RESULT = new ArrayList<Use>(); :}
;

use_component::=
      USE IDENTIFIER:i           {: RESULT = new Use(i, ileft, iright); :}
    | USE IDENTIFIER:i SEMICOLON {: RESULT = new Use(i, ileft, iright); :}
;

definitionStar ::=
    definitionStar:ds definition:d {:ds.add(d); RESULT = ds; :}
    | {: RESULT = new ArrayList<Definition>(); :}
;

definition ::=
    method:m {: RESULT = m; :}
    | globalDecl:gd {: RESULT = gd; :}
    | record:r {: RESULT = r; :}
;

method ::= // Id b
    IDENTIFIER:i OPEN_PAREN emptyBracketDecl_star:ds CLOSE_PAREN COLON emptyBracketType_plus:ts block:b {:
        RESULT = new Method(i,ds,ts,b,ileft,iright); :}
    | IDENTIFIER:i OPEN_PAREN emptyBracketDecl_star:ds CLOSE_PAREN block:b {: // Block b
        RESULT = new Method(i,ds,new ArrayList<Type>(),b,ileft,iright); // NONE :}
;

emptyBracketDecl_star ::=
    emptyBracketDecl_plus:declstar {: RESULT = declstar; :}
    | {: RESULT = new ArrayList<AnnotatedTypeDecl>(); :}
;

emptyBracketDecl_plus ::=
    emptyBracketDecl_plus:ts COMMA emptyBracketDecl:d {: ts.add(d); RESULT = ts; :}
    |emptyBracketDecl:d {:
        ArrayList<AnnotatedTypeDecl> temp = new ArrayList<AnnotatedTypeDecl>();
        temp.add(d);
        RESULT = temp; :}
    ;

emptyBracketDecl ::=
    IDENTIFIER:i COLON emptyBracketType:t {:
        RESULT = new AnnotatedTypeDecl(new Id(i,ileft,iright),t,ileft,iright); :}
;

fullBracketType::=
    IDENTIFIER: i fullBracketPlus:e {:
        Id a = new Id(i,ileft,iright);
        RESULT = new ArrAccessDecl(a,e, ileft,iright);
    :}
    | IDENTIFIER:id OPEN_PAREN CLOSE_PAREN fullBracketPlus:e {:
        RESULT = new ArrAccessDecl(new Id(id,idleft,idright),new ArrayList<Expr>(),e, idleft, idright); :}
    | IDENTIFIER:id OPEN_PAREN exprList:e CLOSE_PAREN fullBracketPlus:indi {:
        RESULT = new ArrAccessDecl(new Id(id,idleft,idright), e,indi, idleft, idright); :}
;

fullBracketPlus ::=
    fullBracketPlus:ts OPEN_BRACKET expr:e CLOSE_BRACKET {:
        ts.add(e);
        RESULT = ts; :}
   | OPEN_BRACKET expr:e CLOSE_BRACKET {:
        ArrayList<Expr> exprList = new ArrayList<Expr>();
        exprList.add(e);
        RESULT = exprList; :}
;

globalDecl ::=
    newGlob:ng {: RESULT = ng; :}
;

newGlob ::=
    emptyBracketDecl:ed {:
    RESULT = new Globdecl(ed, null, edleft, edright); :} // make sure to check NULL
    | emptyBracketDecl:ed GETS:g value:v {:
        if (!ed.type.dimensions.allEmpty) {
            throw new SyntaxError(gleft,gright ,"array with init len no Val");
        }
        if (ed.type.dimensions.getDim() != 0){
            throw new SyntaxError(gleft,gright ,"global arr not init allowed");
        }
        RESULT  = new Globdecl(ed, v, edleft, edright);
    :}
    | newGlob:gd SEMICOLON {:
        RESULT = gd;:}
    | glob_type_list:tl GETS valueList:v {:
        RESULT = new MultiGlobalDecl(tl,v,tlleft,tlright);:}
    | identifier_plus:ip COLON emptyBracketType:t {:       // x, y : int
        ArrayList<AnnotatedTypeDecl> declList = new ArrayList<AnnotatedTypeDecl>();
        for(int j = 0; j < ip.size(); j++) {
            declList.add(new AnnotatedTypeDecl(ip.get(j), t, ipleft, ipright));
        }
        RESULT = new MultiGlobalDecl(declList, new ArrayList<Expr>(), ipleft, ipright); :}
;

glob_type_list ::=
    emptyBracketDecl:ed1 COMMA emptyBracketDecl:ed2 {:
         ArrayList<AnnotatedTypeDecl> temp = new ArrayList<>();
         temp.add(ed1);
         temp.add(ed2);
         RESULT = temp; :}
    |glob_type_list:tl COMMA emptyBracketDecl:ed {:
         tl.add(ed);
         RESULT = tl; :}
;

value ::=
    INTEGER_LITERAL:i  {: RESULT = new IntLiteral(i,ileft,iright); :}
    | MINUS MAX_NUM:m {:RESULT = new IntLiteral(Long.MIN_VALUE,mleft,mright);:}
    | CHARACTER_LITERAL:c {: RESULT = new IntLiteral(c,cleft,cright); :}// Create as INT cause Chars are ints
    | MINUS INTEGER_LITERAL:i  {: RESULT = new IntLiteral(-i,ileft,iright); :} %prec UMINUS
    | BOOL_LITERAL:b    {: RESULT = new BoolLiteral(b,bleft,bright); :}
;

valueList ::=
    value:x {:
        ArrayList<Expr> temp = new ArrayList<Expr>();
        temp.add(x);
        RESULT = temp;
        :}
    | valueList:ave COMMA value:x {: ave.add(x); RESULT = ave; :}
;

emptyBracketType_plus ::=
    emptyBracketType_plus:ts COMMA emptyBracketType:t {: ts.add(t); RESULT = ts; :}
    | emptyBracketType:t {:
        ArrayList<Type> typeList = new ArrayList<Type>();
        typeList.add(t);
        RESULT = typeList; :}
;

emptyBracketType ::=
    INT  emptyDimension_star:d {:RESULT = new Type(true,d,dleft,dright); :}
    | BOOL emptyDimension_star:d {:RESULT = new Type(false,d,dleft,dright); :}
    | IDENTIFIER:i emptyDimension_star:d {:RESULT = new Type(i, d, ileft,iright); :}
;

emptyDimension_star ::=
    emptyDimension_star:ds OPEN_BRACKET CLOSE_BRACKET {:
    ds.increment();
    ds.foundEmpty = true;
    ds.indices.add(null);
    RESULT = ds;:}
    |emptyDimension_star:ds OPEN_BRACKET INTEGER_LITERAL:i CLOSE_BRACKET {:
        if (ds.foundEmpty) throw new SyntaxError(ileft,iright,"Filled index after empty");
        ds.allEmpty = false;
        IntLiteral iL = new IntLiteral(i,ileft,iright);
        ds.indices.add(iL);
        ds.increment(); // [][2]
        RESULT = ds;:}
    |emptyDimension_star:ds OPEN_BRACKET IDENTIFIER:i CLOSE_BRACKET {:
        if (ds.foundEmpty) throw new SyntaxError(ileft,iright ,"Filled index after empty");
        ds.allEmpty = false;
        ds.indices.add(new Id(i,ileft,iright));
        ds.increment(); // [][2]
        RESULT = ds;:}
    |emptyDimension_star:ds OPEN_BRACKET expr:e CLOSE_BRACKET {:
        if (ds.foundEmpty) throw new SyntaxError(eleft,eright,"Filled index after empty");
        ds.allEmpty = false;
        ds.indices.add(e);
        ds.increment(); // [][2]
        RESULT = ds;:}
    | {:RESULT = new Dimension(-1,-1); :} // Maybe check future
;

expr ::=
    // ignore Paren
    OPEN_PAREN expr:e1 CLOSE_PAREN {:RESULT = e1;:}

    //BINOP
    |  expr:e1 TIMES     expr:e2  {: RESULT = new TimesBinop(e1, e2, e1left, e1right); :}
    |  expr:e1 HI_MULT   expr:e2  {: RESULT = new HighMultBinop(e1, e2, e1left, e1right); :}
    |  expr:e1 DIVIDE    expr:e2  {: RESULT = new DivideBinop(e1, e2, e1left, e1right); :}
    |  expr:e1 MODULO    expr:e2  {: RESULT = new ModuloBinop(e1, e2, e1left, e1right); :}
    |  expr:e1 PLUS      expr:e2  {: RESULT = new PlusBinop(e1, e2, e1left, e1right); :}
    |  expr:e1 MINUS     expr:e2  {: RESULT = new MinusBinop(e1, e2, e1left, e1right); :}
    |  expr:e1 LT        expr:e2  {: RESULT = new LtBinop(e1, e2, e1left, e1right); :}
    |  expr:e1 LEQ       expr:e2  {: RESULT = new LeqBinop(e1, e2, e1left, e1right); :}
    |  expr:e1 GT        expr:e2  {: RESULT = new GtBinop(e1, e2, e1left, e1right); :}
    |  expr:e1 GEQ       expr:e2  {: RESULT = new GeqBinop(e1, e2, e1left, e1right); :}
    |  expr:e1 EQUAL     expr:e2  {: RESULT = new EqualsBinop(e1, e2, e1left, e1right); :}
    |  expr:e1 NOT_EQUAL expr:e2  {: RESULT = new NotEqualsBinop(e1, e2, e1left, e1right); :}
    |  expr:e1 AND       expr:e2  {: RESULT = new AndBinop(e1, e2, e1left, e1right); :}
    |  expr:e1 OR        expr:e2  {: RESULT = new OrBinop(e1, e2, e1left, e1right); :}

    // UNOP
    |  NOT   expr:e1              {: RESULT = new NotUnop(e1, e1left, e1right); :}
    |  MINUS expr:e1              {: RESULT = new IntegerNegExpr (e1, e1left, e1right);:} %prec UMINUS // IF ITS INT CONVER TO NEG

    // LITS
    | INTEGER_LITERAL:i           {: RESULT = new IntLiteral(i,ileft,iright); :}
    | MINUS MAX_NUM:m             {: RESULT = new IntLiteral(Long.MIN_VALUE,mleft,mright);:}
    | CHARACTER_LITERAL:c         {: RESULT = new IntLiteral(c, cleft, cright); :}// Create as INT cause Chars are ints
    | BOOL_LITERAL:b              {: RESULT = new BoolLiteral(b, bleft, bright); :}
    | STRING_LITERAL:s            {: RESULT = new ArrayValueLiteral(s, sleft, sright); :}

    // IDS
    | IDENTIFIER:id {: RESULT = new Id(id, idleft, idright); :}

    // NULL
    | NULL:n {: RESULT = new Null(nleft, nright); :}

    // ARRAY LITERALS
    | OPEN_BRACE:ob CLOSE_BRACE {:RESULT = new ArrayValueLiteral(new ArrayList<Expr>(), obleft, obright);:}
    | OPEN_BRACE:ob exprList:x CLOSE_BRACE {:RESULT = new ArrayValueLiteral(x, obleft, obright);:}
    | OPEN_BRACE:ob exprList:x COMMA CLOSE_BRACE {:RESULT = new ArrayValueLiteral(x, obleft, obright); :}

    // Functions
    |  LENGTH OPEN_PAREN expr:e CLOSE_PAREN {: RESULT = new Length(e, eleft, eright); :}
    | IDENTIFIER:id OPEN_PAREN CLOSE_PAREN {: RESULT = new FunctionCallExpr(new Id(id,idleft,idright),new ArrayList<Expr>(), idleft, idright); :}
    | IDENTIFIER:id OPEN_PAREN exprList:e CLOSE_PAREN {: RESULT = new FunctionCallExpr(new Id(id,idleft,idright), e, idleft, idright); :}
    | expr:e fullBracketPlus:i {: RESULT = new ArrayAccessExpr(e, i, eleft, eright); :}

    // Records
    | expr:e PERIOD IDENTIFIER:id {: RESULT = new RecordAcessBinop(e, new Id(id, idleft, idright), eleft, eright); :}
;

exprList ::=
    expr:x {:
            ArrayList<Expr> temp = new ArrayList<Expr>();
            temp.add(x);
            RESULT = temp;
        :}
    |  exprList:ave COMMA expr:x {: ave.add(x); RESULT = ave; :}
;

stmt ::=
    declaration_assign_stmt:das {:RESULT = das; :}
    | multi_declaration_assign_stmt:mdas {:RESULT = mdas;:}
    | WHILE expr:e stmt:s {:RESULT = new While(e,s,eleft,eright);:}
    | IF expr:e stmt:s {:RESULT = new IfOnly(e,s,eleft,eright);:}
    | IF expr:e stmt:s1 ELSE stmt:s2 {:RESULT = new IfElse(e,s1,s2,eleft,eright);:}
    | IDENTIFIER:id OPEN_PAREN CLOSE_PAREN {: RESULT = new ProcedureCall(new Id(id,idleft,idright),new ArrayList<Expr>(),idleft,idright); :}
    | IDENTIFIER:id OPEN_PAREN exprList:e CLOSE_PAREN {: RESULT = new ProcedureCall(new Id(id,idleft,idright), e, idleft,idright); :}
    | block:b {: RESULT = b; :}
    | BREAK:b {: RESULT = new Break(bleft, bright); :}
;

multi_declaration_assign_stmt ::= type_list:tl right_side:rs {: RESULT = new MultiDeclAssignStmt(tl,rs,tlleft,tlright); :}
;

right_side ::=
    GETS exprList:el {:RESULT = el;:}
    | {:RESULT = new ArrayList<Expr>();:}
;

multi_declaration_stmt ::=
    // x, y, z : int
    identifier_plus:ip COLON emptyBracketType:t {:
        ArrayList<AnnotatedTypeDecl> declList = new ArrayList<AnnotatedTypeDecl>();
        for(int j = 0; j < ip.size(); j++) {
            declList.add(new AnnotatedTypeDecl(ip.get(j), t, ipleft, ipright));
        }
    RESULT = declList; :}
;

fullBracketAss ::=
    IDENTIFIER:id fullBracketPlus:fbp {: RESULT = new ArrAccessDecl(new Id(id,idleft,idright), fbp,idleft,idright ); :}
    | IDENTIFIER:id OPEN_PAREN CLOSE_PAREN fullBracketPlus:e{: RESULT = new ArrAccessDecl(new Id(id,idleft,idright),new ArrayList<Expr>(),e, idleft, idright); :}
    | IDENTIFIER:id OPEN_PAREN exprList:e CLOSE_PAREN fullBracketPlus:indi{: RESULT = new ArrAccessDecl(new Id(id,idleft,idright), e,indi, idleft, idright); :}
;

recordaccessdeclarray ::=
    recordaccessdeclarray:rad PERIOD IDENTIFIER:i {:
        rad.add(new NoTypeDecl(new Id(i,ileft,iright),ileft,iright,true));
        RESULT = rad; :}
    | IDENTIFIER:id OPEN_PAREN exprList:e CLOSE_PAREN PERIOD IDENTIFIER:i {:
        ArrayList<Decl> rad = new ArrayList<Decl>();
        rad.add(new NoTypeDecl(new Id(id,idleft,idright),e,idleft,idright,false));
        rad.add(new NoTypeDecl(new Id(i,ileft,iright),ileft,iright,true));
        RESULT = rad; :}
    | IDENTIFIER:id OPEN_PAREN exprList:e CLOSE_PAREN PERIOD fullBracketAss:fb {:
        //Point(1,2).x[2]
        //TODO: dont think it should be fullbracketass?
        ArrayList<Decl> rad = new ArrayList<Decl>();
        rad.add(new NoTypeDecl(new Id(id,idleft,idright),e,idleft,idright,false));
        rad.add(fb);
        RESULT = rad; :}
    | recordaccessdeclarray:rad PERIOD fullBracketAss:fb {:
        rad.add(fb);
        RESULT = rad; :}
    | IDENTIFIER:i PERIOD fullBracketAss:fb {:
        ArrayList<Decl> rad = new ArrayList<Decl>();
        rad.add(new NoTypeDecl(new Id(i,ileft,iright),ileft,iright,false));
        rad.add(fb);
        RESULT = rad; :}
    | fullBracketAss:fb PERIOD IDENTIFIER:i {:
        ArrayList<Decl> rad = new ArrayList<Decl>();
        rad.add(fb);
        rad.add(new NoTypeDecl(new Id(i,ileft,iright),ileft,iright,true));
        RESULT = rad; :}
    | IDENTIFIER:i1 PERIOD IDENTIFIER:i {:
        ArrayList<Decl> rad = new ArrayList<Decl>();
        rad.add(new NoTypeDecl(new Id(i1,i1left,i1right),i1left,i1right,false));
        rad.add(new NoTypeDecl(new Id(i,ileft,iright),ileft,iright,true));
        RESULT = rad; :}
    | fullBracketAss:fb PERIOD fullBracketAss:fb1 {:
        ArrayList<Decl> rad = new ArrayList<Decl>();
        rad.add(fb);
        rad.add(fb1);
        RESULT = rad; :}
;

recordaccessdecl ::= recordaccessdeclarray:rad
    {: RESULT = new RecordAccessDecl(rad, radleft, radright);
    :}
;



// x:int, y, b:bool, z
type_list ::=
    UNDERSCORE:u COMMA IDENTIFIER:i2 {:
        ArrayList<Decl> temp = new ArrayList<Decl>();
        temp.add(new UnderScore(uleft,uright));
        temp.add(new NoTypeDecl(new Id(i2,i2left,i2right),i2left,i2right,false));
        RESULT = temp; :}
    |IDENTIFIER:i1 COLON emptyBracketType:t1 COMMA UNDERSCORE:u {:
        ArrayList<Decl> temp = new ArrayList<Decl>();
        temp.add(new AnnotatedTypeDecl(new Id(i1,i1left,i1right),t1,i1left,i1right));
        temp.add(new UnderScore(uleft,uright));
        RESULT = temp; :}
    |UNDERSCORE:u COMMA IDENTIFIER:i2 COLON emptyBracketType:t2 {:
        ArrayList<Decl> temp = new ArrayList<Decl>();
        temp.add(new UnderScore(uleft,uright));
        temp.add(new AnnotatedTypeDecl(new Id(i2,i2left,i2right),t2,i2left,i2right));
        RESULT = temp; :}
    |IDENTIFIER:i1 COMMA UNDERSCORE:u {:
        ArrayList<Decl> temp = new ArrayList<Decl>();
        temp.add(new NoTypeDecl(new Id(i1,i1left,i1right),i1left, i1right,false));
        temp.add(new UnderScore(uleft,uright));
        RESULT = temp; :}
    |UNDERSCORE:u1 COMMA UNDERSCORE:u2 {:
        ArrayList<Decl> temp = new ArrayList<Decl>();
        temp.add(new UnderScore(u1left,u1right));
        temp.add(new UnderScore(u2left,u2right));
        RESULT = temp; :}
    |IDENTIFIER:i1 COMMA IDENTIFIER:i2 {:
        ArrayList<Decl> temp = new ArrayList<Decl>();
        temp.add(new NoTypeDecl(new Id(i1,i1left,i1right),i1left, i1right,false));
        temp.add(new NoTypeDecl(new Id(i2,i2left,i2right), i2left, i2right,false));
        RESULT = temp; :}
    |IDENTIFIER:i1 COLON emptyBracketType:t1 COMMA IDENTIFIER:i2 {:
        ArrayList<Decl> temp = new ArrayList<Decl>();
        temp.add(new AnnotatedTypeDecl(new Id(i1,i1left,i1right),t1,i1left,i1right));
        temp.add(new NoTypeDecl(new Id(i2,i2left,i2right), i2left, i2right,false));
        RESULT = temp; :}
    |IDENTIFIER:i1 COMMA IDENTIFIER:i2 COLON emptyBracketType:t2 {:
        ArrayList<Decl> temp = new ArrayList<Decl>();
        temp.add(new NoTypeDecl(new Id(i1,i1left,i1right), i1left, i1right,false));
        temp.add(new AnnotatedTypeDecl(new Id(i2,i2left,i2right),t2, i2left, i2right));
        RESULT = temp; :}
    |IDENTIFIER:i1 COLON emptyBracketType:t1 COMMA IDENTIFIER:i2 COLON emptyBracketType:t2 {:
        ArrayList<Decl> temp = new ArrayList<Decl>();
        temp.add(new AnnotatedTypeDecl(new Id(i1,i1left,i1right),t1, i1left, i1right));
        temp.add(new AnnotatedTypeDecl(new Id(i2,i2left,i2right),t2, i2left, i2right));
        RESULT = temp; :}
    |type_list:tl COMMA IDENTIFIER:i COLON emptyBracketType:t {:
        tl.add(new AnnotatedTypeDecl(new Id(i,ileft,iright), t, ileft, iright));
        RESULT = tl; :}
    | type_list:tl COMMA IDENTIFIER:i {:
        tl.add(new NoTypeDecl(new Id(i,ileft,iright), ileft, iright,false));
        RESULT = tl; :}
    | type_list:tl COMMA UNDERSCORE:u {:
        tl.add(new UnderScore(uleft,uright));
        RESULT = tl; :}
    |fullBracketAss:fb  COMMA UNDERSCORE:u {:
        ArrayList<Decl> temp = new ArrayList<Decl>();
        temp.add(fb);
        temp.add(new UnderScore(uleft,uright));
        RESULT = temp; :}
    | UNDERSCORE:u COMMA fullBracketAss:fb{:
        ArrayList<Decl> temp = new ArrayList<Decl>();
        temp.add(new UnderScore(uleft,uright));
        temp.add(fb);
        RESULT = temp; :}
    |fullBracketAss:fb COMMA IDENTIFIER:i1 COLON emptyBracketType:t1 {:
        ArrayList<Decl> temp = new ArrayList<Decl>();
        temp.add(fb);
        temp.add(new AnnotatedTypeDecl(new Id(i1,i1left,i1right),t1,i1left, i1right));
        RESULT = temp; :}
    | IDENTIFIER:i1 COLON emptyBracketType:t1 COMMA fullBracketAss:fb{:
        ArrayList<Decl> temp = new ArrayList<Decl>();
        temp.add(new AnnotatedTypeDecl(new Id(i1,i1left,i1right),t1, i1left, i1right));
        temp.add(fb);
        RESULT = temp; :}
    |fullBracketAss:fb COMMA IDENTIFIER:i1 {:
        ArrayList<Decl> temp = new ArrayList<Decl>();
        temp.add(fb);
        temp.add(new NoTypeDecl(new Id(i1,i1left,i1right), i1left, i1right,false));
        RESULT = temp; :}
    | IDENTIFIER:i1 COMMA fullBracketAss:fb {:
        ArrayList<Decl> temp = new ArrayList<Decl>();
        temp.add(new NoTypeDecl(new Id(i1,i1left,i1right), i1left, i1right,false));
        temp.add(fb);
        RESULT = temp; :}
    | fullBracketAss:fb1 COMMA fullBracketAss:fb2{:
        ArrayList<Decl> temp = new ArrayList<Decl>();
        temp.add(fb1);
        temp.add(fb2);
        RESULT = temp; :}
    | type_list:tl COMMA fullBracketAss:fb {:
        tl.add(fb);
        RESULT = tl; :}
    // RECORD ACCESS DECLS
    | recordaccessdecl:rd1 COMMA recordaccessdecl:rd2 {:
        ArrayList<Decl> temp = new ArrayList<Decl>();
        temp.add(rd1);
        temp.add(rd2);
        RESULT = temp; :}
    | recordaccessdecl:rd COMMA IDENTIFIER:i {:
        ArrayList<Decl> temp = new ArrayList<Decl>();
        temp.add(rd);
        temp.add(new NoTypeDecl(new Id(i,ileft,iright),ileft,iright,false));
        RESULT = temp; :}
    | IDENTIFIER:i COMMA recordaccessdecl:rd {:
        ArrayList<Decl> temp = new ArrayList<Decl>();
        temp.add(new NoTypeDecl(new Id(i,ileft,iright),ileft,iright,false));
        temp.add(rd);
        RESULT = temp; :}
    | recordaccessdecl:rd COMMA UNDERSCORE:u {:
        ArrayList<Decl> temp = new ArrayList<Decl>();
        temp.add(rd);
        temp.add(new UnderScore(uleft,uright));
        RESULT = temp; :}
    | UNDERSCORE:u COMMA recordaccessdecl:rd {:
        ArrayList<Decl> temp = new ArrayList<Decl>();
        temp.add(new UnderScore(uleft,uright));
        temp.add(rd);
        RESULT = temp; :}
    | recordaccessdecl:rd COMMA IDENTIFIER:i1 COLON emptyBracketType:t1{:
        ArrayList<Decl> temp = new ArrayList<Decl>();
        temp.add(rd);
        temp.add(new AnnotatedTypeDecl(new Id(i1,i1left,i1right),t1, i1left, i1right));
        RESULT = temp; :}
    | IDENTIFIER:i1 COLON emptyBracketType:t1 COMMA recordaccessdecl:rd {:
        ArrayList<Decl> temp = new ArrayList<Decl>();
        temp.add(new AnnotatedTypeDecl(new Id(i1,i1left,i1right),t1, i1left, i1right));
        temp.add(rd);
        RESULT = temp; :}
   | recordaccessdecl:rd COMMA fullBracketAss:fb {:
        ArrayList<Decl> temp = new ArrayList<Decl>();
        temp.add(rd);
        temp.add(fb);
        RESULT = temp; :}
   | fullBracketAss:fb COMMA recordaccessdecl:rd {:
        ArrayList<Decl> temp = new ArrayList<Decl>();
        temp.add(fb);
        temp.add(rd);
        RESULT = temp; :}
   | type_list:tl COMMA recordaccessdecl:rd {:
       tl.add(rd);
       RESULT = tl; :}
;

declaration_assign_stmt ::=
    emptyBracketDecl:d GETS:g expr:e {: // ANNOTATED
    if (!d.type.dimensions.allEmpty) {
        throw new SyntaxError(gleft, gright,"array with init len no Val");
    }
    RESULT = new DeclAssignStmt(d,e,gleft,gright);
    :}
    | emptyBracketDecl:d {:RESULT = new DeclNoAssignStmt(d,dleft,dright);:}
    | IDENTIFIER:id GETS:g expr:e {:
        NoTypeDecl tempDec = new NoTypeDecl(new Id(id,idleft,idright),idleft,idright,false);
        RESULT = new DeclAssignStmt(tempDec,e,gleft,gright);:}
    | UNDERSCORE:u GETS:g expr:e {:
        UnderScore tempUnder = new UnderScore(uleft,uright);
        RESULT = new DeclAssignStmt(tempUnder,e,gleft,gright);:}
    | fullBracketType:d GETS expr:e {:
    RESULT = new DeclAssignStmt(d,e,dleft,dright);
    :}
    | recordaccessdecl:rd GETS expr:e {:
    RESULT = new DeclAssignStmt(rd, e, rdleft, rdright);
    :}
;

block ::=
    OPEN_BRACE:ob statement_star:ss CLOSE_BRACE {:RESULT = new Block(ss,obleft,obright);:}
    |OPEN_BRACE:ob statement_star:ss SEMICOLON CLOSE_BRACE {:RESULT = new Block(ss,obleft,obright);:}
    |OPEN_BRACE:ob statement_star:ss SEMICOLON return:r CLOSE_BRACE{:ss.add(r); RESULT = new Block(ss,obleft,obright);:}
    |OPEN_BRACE:ob statement_star:ss return:r SEMICOLON CLOSE_BRACE{:ss.add(r); RESULT = new Block(ss,obleft,obright);:}
    |OPEN_BRACE:ob statement_star:ss return:r CLOSE_BRACE{:ss.add(r); RESULT = new Block(ss,obleft,obright);:}
    |OPEN_BRACE:ob statement_star:ss SEMICOLON return:r SEMICOLON CLOSE_BRACE{:ss.add(r); RESULT = new Block(ss,obleft,obright);:}
;

statement_star ::=
    statement_star:ss stmt:s {: ss.add(s); RESULT = ss;:}
    |statement_star:ss SEMICOLON stmt:s {: ss.add(s); RESULT = ss;:}
    | {:RESULT = new ArrayList<Stmt>();:}
;

return ::=
    RETURN:r exprList:el {:RESULT = new Return(el,rleft,rright);:}
    | RETURN:r {:RESULT = new Return(new ArrayList<Expr>(),rleft,rright);:}
;

//Rho stuff-----------------------------------------
rhoEmptyDimension_star ::=
    rhoEmptyDimension_star:ds OPEN_BRACKET CLOSE_BRACKET {:
        ds.increment();
        ds.foundEmpty = true;
        ds.indices.add(null);
        RESULT = ds;:}
    | {:RESULT = new Dimension(-1,-1); :}
; // Maybe check future

rhoEmptyBracketType ::=
    INT  rhoEmptyDimension_star:d {:RESULT = new Type(true,d,dleft,dright); :}
    | BOOL rhoEmptyDimension_star:d {:RESULT = new Type(false,d,dleft,dright); :}
    | IDENTIFIER:i rhoEmptyDimension_star:d {: RESULT = new Type(i, d, ileft, iright); :}
;

rhoEmptyBracketDecl ::=
    IDENTIFIER:i COLON rhoEmptyBracketType:t {: RESULT = new AnnotatedTypeDecl(new Id(i,ileft,iright),t,ileft,iright); :}
;

rhoEmptyBracketDecl_plus ::=
    rhoEmptyBracketDecl_plus:ts COMMA rhoEmptyBracketDecl:d {: ts.add(d); RESULT = ts; :}
    |rhoEmptyBracketDecl:d {:ArrayList<AnnotatedTypeDecl> temp = new ArrayList<AnnotatedTypeDecl>();
      temp.add(d);
      RESULT = temp;
      :}
;

identifier_plus ::=
    identifier_plus:ip COMMA IDENTIFIER:i {: ip.add(new Id(i, ileft, iright)); RESULT = ip; :}
    | IDENTIFIER:i1 COMMA IDENTIFIER:i2 {:
        ArrayList<Id> idList = new ArrayList<Id>();
        idList.add(new Id(i1, i1left, i1right));
        idList.add(new Id(i2, i2left, i2right));
        RESULT = idList; :}
;

// x, y : int
rhoMultiDecl ::=
    identifier_plus:ip COLON rhoEmptyBracketType:e {:
        ArrayList<AnnotatedTypeDecl> declList = new ArrayList<AnnotatedTypeDecl>();
        for(int j = 0; j < ip.size(); j++) {
            declList.add(new AnnotatedTypeDecl(ip.get(j), e, ipleft, ipright));
        }
        RESULT = declList; :}
;

// x, y : int
// x : int, y : int
fieldDecl ::=
    rhoMultiDecl:m {: RESULT = m; :}
    | rhoMultiDecl:m SEMICOLON {: RESULT = m; :}
    | rhoEmptyBracketDecl_plus:e {: RESULT = e; :}
    | rhoEmptyBracketDecl_plus:e SEMICOLON {: RESULT = e; :}
;

fieldDeclPlus ::=
    fieldDeclPlus:ss fieldDecl:s {: ss.addAll(s); RESULT = ss; :}
    |fieldDecl:s {: RESULT = s; :}
;

record ::=
    RECORD IDENTIFIER:i OPEN_BRACE fieldDeclPlus:s CLOSE_BRACE {:RESULT = new RecordDef(new Id(i, ileft, iright), s, ileft, iright); :}
;