// A stub for an Eta CUP specification.
package aar226_akc55_ayc62_ahl88;

import java_cup.runtime.*;
import aar226_akc55_ayc62_ahl88.ast.*;
import java.util.ArrayList;
// You might want to add types to these declarations.
//parser ExampleParser {: :}
terminal String IDENTIFIER;
terminal String STRING_LITERAL;
terminal String CHARACTER_LITERAL;
terminal Long INTEGER_LITERAL;
terminal Boolean TRUE;
terminal Boolean FALSE;
terminal INT, BOOL;

terminal IF, ELSE, WHILE, BREAK, RETURN, USE, LENGTH, PLUS, MINUS, TIMES, HI_MULT,
  DIVIDE, MODULO, NOT, LT, LEQ, GT, GEQ, AND, OR, EQUAL, NOT_EQUAL, GETS,
  OPEN_BRACKET, CLOSE_BRACKET, OPEN_PAREN, CLOSE_PAREN, OPEN_BRACE, CLOSE_BRACE,
  COLON, COMMA, SEMICOLON, UNDERSCORE, UMINUS;

nonterminal Program program;
nonterminal ArrayList<Use> importUseList;
nonterminal Use use_component;
nonterminal ArrayList<Definition> methodDefList;

// function call
precedence left OR;
precedence left AND;
precedence left EQUAL,NOT_EQUAL;
precedence left LT,LEQ,GEQ,GT;
precedence left PLUS,MINUS;
precedence left TIMES,HI_MULT,DIVIDE,MODULO;
precedence nonassoc NOT, UMINUS;// ??? negation?
precedence left OPEN_BRACKET,CLOSE_BRACKET,OPEN_PAREN,CLOSE_PAREN;

start with program;

program ::=
    | importUseList:iul methodDefList:mdl {:RESULT = new Program(iul,mdl);:}
//    | methodDefList:mdl                   {:RESULT = new Program (new ArrayList<Use>(),mdl);:}
    ;

importUseList::=
    use_component:u {:
        ArrayList<Use> newList = new ArrayList<Use>();
        newList.add(u);
        RESULT = newList;
        :}
    | importUseList:iul use_component:u {:
        iul.add(u);
        RESULT = iul; :}
        ;

use_component::=
      USE IDENTIFIER:i {:           RESULT = new Use(i); :}
    | USE IDENTIFIER:i SEMICOLON {: RESULT = new Use(i); :}
    ;

methodDefList::=
        {:RESULT = new ArrayList<Definition>(); :}
    ;

//start with expr;
//
//expr ::=
////        |  IDENTIFIER:i OPEN_PAREN exprlist:el CLOSE_PAREN // Function Call with Param
////        |  IDENTIFIER:i OPEN_PAREN CLOSE_PAREN            // Function Call no param
////        |  expr:e1 OPEN_BRACKET:l expr:e2 CLOSE_BRACKET // INDEXING
////        |  LENGTH OPEN_PAREN expr:e CLOSE_PAREN // EXPR LENGTH
////        |  OPEN_BRACE exprlist:e CLOSE_BRACE  // ARRY LIT
////        |  OPEN_BRACE exprlist:e COMMA CLOSE_BRACE // ARRY LIT
////        |  OPEN_BRACE CLOSE_BRACE     {: RESULT = new ArrayLiteral(new ArrayList<Expr>()); :} // create this class
//           MINUS:o           expr:e   {: RESULT = new Unary(o,e); :} // Change to UMINUS later
//        |  NOT               expr:e1  {: RESULT = new Not(e1); :}
//        |  expr:e1 TIMES     expr:e2  {: RESULT = new Times(e1, e2); :}
//        |  expr:e1 HI_MULT   expr:e2  {: RESULT = new Hi_Mult(e1, e2); :}
//        |  expr:e1 DIVIDE    expr:e2  {: RESULT = new Divide(e1, e2); :}
//        |  expr:e1 MODULO    expr:e2  {: RESULT = new Modulo(e1, e2); :}
//        |  expr:e1 PLUS      expr:e2  {: RESULT = new Plus(e1, e2); :}
//        |  expr:e1 MINUS     expr:e2  {: RESULT = new Minus(e1, e2); :}
//        |  expr:e1 LT        expr:e2  {: RESULT = new Lt(e1, e2); :}
//        |  expr:e1 LEQ       expr:e2  {: RESULT = new Leq(e1, e2); :}
//        |  expr:e1 GT        expr:e2  {: RESULT = new Gt(e1, e2); :}
//        |  expr:e1 GEQ       expr:e2  {: RESULT = new Geq(e1, e2); :}
//        |  expr:e1 EQUAL     expr:e2  {: RESULT = new Equal(e1, e2); :}
//        |  expr:e1 NOT_EQUAL expr:e2  {: RESULT = new Not_Equal(e1, e2); :}
//        |  expr:e1 AND       expr:e2  {: RESULT = new And(e1, e2); :}
//        |  expr:e1 OR        expr:e2  {: RESULT = new Or(e1, e2); :}
//        |  INTEGER_LITERAL:n          {: RESULT = new Num(n); :}
//        |  TRUE:t                     {: RESULT = new Bool(t); :}
//        |  FALSE:f                    {: RESULT = new Bool(f); :}
////        |  CHARACTER_LITERAL:c // Create as INT cause Chars are ints
////        |  STRING_LITERAL:s // Create as INT cause Strings are array of Ints
//        // Chaaracter and String needed
//        |  OPEN_PAREN expr:e CLOSE_PAREN       {: RESULT = e; :}
//        |  error                      {: RESULT = null; :}
//        ;
