// A stub for an Eta CUP specification.
package aar226_akc55_ayc62_ahl88;

import java_cup.runtime.*;
import aar226_akc55_ayc62_ahl88.ast.*;
import java.util.ArrayList;
// You might want to add types to these declarations.
//parser ExampleParser {: :}
terminal String IDENTIFIER;
terminal String STRING_LITERAL;
terminal String CHARACTER_LITERAL;
terminal Long INTEGER_LITERAL;
terminal Boolean TRUE;
terminal Boolean FALSE;
terminal Boolean BOOL_LITERAL;
terminal INT, BOOL;

terminal IF, ELSE, WHILE, BREAK, RETURN, USE, LENGTH, PLUS, MINUS, TIMES, HI_MULT,
  DIVIDE, MODULO, NOT, LT, LEQ, GT, GEQ, AND, OR, EQUAL, NOT_EQUAL, GETS,
  OPEN_BRACKET, CLOSE_BRACKET, OPEN_PAREN, CLOSE_PAREN, OPEN_BRACE, CLOSE_BRACE,
  COLON, COMMA, SEMICOLON, UNDERSCORE, UMINUS;

nonterminal Program program;
nonterminal ArrayList<Use> importUseStar;
nonterminal Use use_component;
nonterminal ArrayList<Definition> definitionStar;
nonterminal Definition definition;
nonterminal Method method;
nonterminal ArrayList<Decl> emptyBracketDecl_star;
nonterminal Decl emptyBracketDecl;
nonterminal ArrayList<Type> emptyBracketType_plus;
nonterminal Type emptyBracketType;
nonterminal Dimension emptyDimension_star;
nonterminal Globdecl globalDecl;
nonterminal Value value;
nonterminal ArrayList<Value> arrayValueLiteral;
nonterminal Expr expr;
nonterminal Block block;
nonterminal ArrayList<Expr> arrayExpr;
nonterminal LengthArg lengthArg;
nonterminal ArrayList<Expr> exprList;
nonterminal Stmt stmt;
nonterminal Stmt matched_stmt;
nonterminal Stmt unmatched_stmt;
nonterminal ArrayList<Stmt> statement_star;
nonterminal DeclStmt declartion_assign_stmt;
precedence nonassoc IF;
precedence nonassoc ELSE;
// function call
precedence left OR;
precedence left AND;
precedence left EQUAL,NOT_EQUAL;
precedence left LT,LEQ,GEQ,GT;
precedence left PLUS,MINUS;
precedence left TIMES,HI_MULT,DIVIDE,MODULO;
precedence nonassoc NOT, UMINUS;// ??? negation?
precedence left OPEN_BRACKET,CLOSE_BRACKET,OPEN_PAREN,CLOSE_PAREN;

start with program;

program ::= importUseStar:ius definitionStar:dl {:
    System.out.println("IN PRGO");
    RESULT = new Program(ius,dl);:}
    ;

importUseStar ::=
    importUseStar:ius use_component:u {: ius.add(u); RESULT = ius;:}
    | {: RESULT = new ArrayList<Use>();:}
    ;

use_component::=
      USE IDENTIFIER:i {:           RESULT = new Use(i); :}
    | USE IDENTIFIER:i SEMICOLON {: RESULT = new Use(i); :}
    ;

definitionStar ::=
    definitionStar:ds definition:d {:ds.add(d); RESULT = ds; :}
    | {:RESULT = new ArrayList<Definition>(); :}
    ;

definition ::=
    method:m {: System.out.println("IN DEF"); RESULT = m;:}
    | globalDecl:gd {:RESULT = gd; :}
    ;

method ::= // Id b
    IDENTIFIER:i OPEN_PAREN emptyBracketDecl_star:ds CLOSE_PAREN COLON emptyBracketType_plus:ts block:b{:
    RESULT = new Method(i,ds,ts,b);
    :}
    | IDENTIFIER:i OPEN_PAREN emptyBracketDecl_star:ds CLOSE_PAREN block:b {: // Block b
        System.out.println("IN MEETH");
        RESULT = new Method(i,ds,new ArrayList<Type>(),b); // NONE
    :}
//    |IDENTIFIER:i OPEN_PAREN emptyBracketDecl_star:ds CLOSE_PAREN COLON emptyBracketType_plus:ts {:
//     RESULT = new Method(i,ds,ts);
//     :}
//     |IDENTIFIER:i OPEN_PAREN emptyBracketDecl_star:ds CLOSE_PAREN {:
//      RESULT = new Method(i,ds,new ArrayList<Type>());
//      :}
    ;

emptyBracketDecl_star ::=
    emptyBracketDecl_star:declstar COMMA emptyBracketDecl:d {:declstar.add(d); RESULT = declstar; :}
    |emptyBracketDecl:d {:ArrayList<Decl> temp = new ArrayList<Decl>();
      temp.add(d);
      RESULT = temp;
      :}
    | {: RESULT = new ArrayList<Decl>();:}
    ;

emptyBracketDecl ::=
    IDENTIFIER:i COLON emptyBracketType:t {: RESULT = new Decl(i,t); :}
    ;

globalDecl ::=
    emptyBracketDecl:ed {:RESULT = new Globdecl(ed, null);:}
    | emptyBracketDecl:ed GETS value:v {:
        if (!ed.type.dimensions.allEmpty) {
            throw new Error("array with init len no Val");
        }
        if (ed.type.dimensions.getDim() != 0){
            throw new Error("global arr not init allowed");
        }
        RESULT  = new Globdecl(ed, v);
    :}
    | globalDecl:gd SEMICOLON {:RESULT = gd;:}
    ;

value ::=
    INTEGER_LITERAL:i  {: RESULT = new IntLiteral(i,true); :}
    | CHARACTER_LITERAL:c {: RESULT = new IntLiteral(c); :}// Create as INT cause Chars are ints
    | MINUS INTEGER_LITERAL:i  {: RESULT = new IntLiteral(i,false); :} %prec UMINUS
    | BOOL_LITERAL:b    {: RESULT = new BoolLiteral(b); :}
//    | OPEN_BRACE arrayValueLiteral:avl  CLOSE_BRACE {:RESULT = new ArrayValueLiteral(avl); :}
//    | OPEN_BRACE arrayValueLiteral:avl COMMA CLOSE_BRACE {:RESULT = new ArrayValueLiteral(avl); :}
//    | OPEN_BRACE CLOSE_BRACE {:RESULT = new ArrayValueLiteral(new ArrayList<Value>()); :}
    | STRING_LITERAL:s {: new ArrayValueLiteral(s); :}
    ;

//arrayValueLiteral ::=
//    value:v {:
//    ArrayList<Value> temp = new ArrayList<Value>();
//    temp.add(v);
//    RESULT = temp;
//    :}
//    | arrayValueLiteral:avl COMMA value:v {:avl.add(v); RESULT = avl; :}
//;

emptyBracketType_plus ::=
    emptyBracketType_plus:ts COMMA emptyBracketType:t {: ts.add(t); RESULT = ts; :}
    | emptyBracketType:t {: ArrayList<Type> typeList = new ArrayList<Type>();
                      typeList.add(t);
                      RESULT = typeList;
                      :}
    ;

emptyBracketType ::=
   INT  emptyDimension_star:d {:RESULT = new Type(true,d); :}
 | BOOL emptyDimension_star:d {:RESULT = new Type(false,d); :}
 ;

emptyDimension_star ::=
    emptyDimension_star:ds OPEN_BRACKET CLOSE_BRACKET {:
    ds.increment();
    ds.foundEmpty = true;
    ds.indices.add(null);
    RESULT = ds;:}
    |emptyDimension_star:ds OPEN_BRACKET INTEGER_LITERAL:i CLOSE_BRACKET {:
        if (ds.foundEmpty) throw new Error("Filled index after empty");
        ds.allEmpty = false;
        IntLiteral iL = new IntLiteral(i,true);
        ds.indices.add(iL.getLong());
        ds.increment(); // [][2]
        RESULT = ds;:}
    | {:RESULT = new Dimension(0); :}
    ;

expr ::=
       expr:e1 TIMES     expr:e2  {: RESULT = new TimesExpr(e1, e2); :}
    |  expr:e1 HI_MULT   expr:e2  {: RESULT = new Hi_MultExpr(e1, e2); :}
    |  expr:e1 DIVIDE    expr:e2  {: RESULT = new DivideExpr(e1, e2); :}
    |  expr:e1 MODULO    expr:e2  {: RESULT = new ModuloExpr(e1, e2); :}
    |  expr:e1 PLUS      expr:e2  {: RESULT = new PlusExpr(e1, e2); :}
    |  expr:e1 MINUS     expr:e2  {: RESULT = new MinusExpr(e1, e2); :}
    |  expr:e1 LT        expr:e2  {: RESULT = new LtExpr(e1, e2); :}
    |  expr:e1 LEQ       expr:e2  {: RESULT = new LeqExpr(e1, e2); :}
    |  expr:e1 GT        expr:e2  {: RESULT = new GtExpr(e1, e2); :}
    |  expr:e1 GEQ       expr:e2  {: RESULT = new GeqExpr(e1, e2); :}
    |  expr:e1 EQUAL     expr:e2  {: RESULT = new EqualExpr(e1, e2); :}
    |  expr:e1 NOT_EQUAL expr:e2  {: RESULT = new Not_EqualExpr(e1, e2); :}
    |  expr:e1 AND       expr:e2  {: RESULT = new AndExpr(e1, e2); :}
    |  expr:e1 OR        expr:e2  {: RESULT = new OrExpr(e1, e2); :}
    |  NOT               expr:e1  {: RESULT = new NotExpr(e1); :}
    |  value:v                    {: RESULT = (Expr) v;:}
    | OPEN_BRACE arrayExpr:ave  CLOSE_BRACE {:RESULT = new ArrayExpr(ave); :}
    | OPEN_BRACE arrayExpr:ave COMMA CLOSE_BRACE {:RESULT = new ArrayExpr(ave); :}
    | OPEN_BRACE CLOSE_BRACE {:RESULT = new ArrayExpr(new ArrayList<Expr>()); :}
    | IDENTIFIER:id {: RESULT = new Id(id); :}
//    | LENGTH OPEN_PAREN IDENTIFIER:id CLOSE_PAREN {: RESULT = new Length(id); :}
//    |  LENGTH OPEN_PAREN arrayExpr:a CLOSE_PAREN {: RESULT = new Length(a); :}
//    |  LENGTH OPEN_PAREN arrayValueLiteral:a CLOSE_PAREN {: RESULT = new Length(a); :}
//    | IDENTIFIER:id OPEN_PAREN CLOSE_PAREN {: RESULT = new Procedure(id); :}
//    | IDENTIFIER:id OPEN_PAREN exprList:e CLOSE_PAREN {: RESULT = new FunctionCallExpr(id, e); :}
    ;


exprList ::=
    expr:x {:
            ArrayList<Expr> temp = new ArrayList<Expr>();
            temp.add(x);
            RESULT = temp;
        :}
    |  arrayExpr:ave COMMA expr:x {: ave.add(x); RESULT = ave; :}
;

arrayExpr ::=
    expr:x {:
            ArrayList<Expr> temp = new ArrayList<Expr>();
            temp.add(x);
            RESULT = temp;
        :}
    |  arrayExpr:ave COMMA expr:x {: ave.add(x); RESULT = ave; :}
;

stmt ::=
  matched_stmt:m {: RESULT = m; :}
//| unmatched_stmt:u {: RESULT = u; :}
;

matched_stmt ::= declartion_assign_stmt:das {:RESULT = das; :}
//    WHILE expr:e matched_stmt:ms {:RESULT = new While(e,ms);:}
//    | block:b {: RESULT = b; :}
//    | declartion_assign_stmt:das {:RESULT = das; :}
    ;

declartion_assign_stmt ::=
    emptyBracketDecl:d GETS expr:e {:RESULT = new DeclStmt(d,e);:}
    | emptyBracketDecl:d {:RESULT = new DeclStmt(d,null);:}
    | declartion_assign_stmt:das SEMICOLON {:RESULT = das;:}
//    | UNDERSCORE:u GETS expr:e {::}
//    |
;
block ::= OPEN_BRACE statement_star:ss CLOSE_BRACE {:System.out.println("IN BLOCK");RESULT = new Block(ss);:}

;

statement_star ::=
    statement_star:ss stmt:s {:System.out.println("IN SS"); ss.add(s); RESULT = ss;:}
    | {:RESULT = new ArrayList<Stmt>();:}
;




//start with expr;
//
//expr ::=
////        |  IDENTIFIER:i OPEN_PAREN exprlist:el CLOSE_PAREN // Function Call with Param
////        |  IDENTIFIER:i OPEN_PAREN CLOSE_PAREN            // Function Call no param
////        |  expr:e1 OPEN_BRACKET:l expr:e2 CLOSE_BRACKET // INDEXING
////        |  LENGTH OPEN_PAREN expr:e CLOSE_PAREN // EXPR LENGTH
////        |  OPEN_BRACE exprlist:e CLOSE_BRACE  // ARRY LIT
////        |  OPEN_BRACE exprlist:e COMMA CLOSE_BRACE // ARRY LIT
////        |  OPEN_BRACE CLOSE_BRACE     {: RESULT = new ArrayLiteral(new ArrayList<Expr>()); :} // create this class
//           MINUS:o           expr:e   {: RESULT = new Unary(o,e); :} // Change to UMINUS later%prec UMINUS
//        |  NOT               expr:e1  {: RESULT = new Not(e1); :}
//        |  expr:e1 TIMES     expr:e2  {: RESULT = new Times(e1, e2); :}
//        |  expr:e1 HI_MULT   expr:e2  {: RESULT = new Hi_Mult(e1, e2); :}
//        |  expr:e1 DIVIDE    expr:e2  {: RESULT = new Divide(e1, e2); :}
//        |  expr:e1 MODULO    expr:e2  {: RESULT = new Modulo(e1, e2); :}
//        |  expr:e1 PLUS      expr:e2  {: RESULT = new Plus(e1, e2); :}
//        |  expr:e1 MINUS     expr:e2  {: RESULT = new Minus(e1, e2); :}
//        |  expr:e1 LT        expr:e2  {: RESULT = new Lt(e1, e2); :}
//        |  expr:e1 LEQ       expr:e2  {: RESULT = new Leq(e1, e2); :}
//        |  expr:e1 GT        expr:e2  {: RESULT = new Gt(e1, e2); :}
//        |  expr:e1 GEQ       expr:e2  {: RESULT = new Geq(e1, e2); :}
//        |  expr:e1 EQUAL     expr:e2  {: RESULT = new Equal(e1, e2); :}
//        |  expr:e1 NOT_EQUAL expr:e2  {: RESULT = new Not_Equal(e1, e2); :}
//        |  expr:e1 AND       expr:e2  {: RESULT = new And(e1, e2); :}
//        |  expr:e1 OR        expr:e2  {: RESULT = new Or(e1, e2); :}
//        |  INTEGER_LITERAL:n          {: RESULT = new Num(n); :}
//        |  TRUE:t                     {: RESULT = new Bool(t); :}
//        |  FALSE:f                    {: RESULT = new Bool(f); :}
////        |  CHARACTER_LITERAL:c // Create as INT cause Chars are ints
////        |  STRING_LITERAL:s // Create as INT cause Strings are array of Ints
//        // Chaaracter and String needed
//        |  OPEN_PAREN expr:e CLOSE_PAREN       {: RESULT = e; :}
//        |  error                      {: RESULT = null; :}
//        ;
