Index: tests/pa5Eth/ex01.eta
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/tests/pa5Eth/ex01.eta b/tests/pa5Eth/ex01.eta
new file mode 100644
--- /dev/null	(date 1681159066882)
+++ b/tests/pa5Eth/ex01.eta	(date 1681159066882)
@@ -0,0 +1,7 @@
+use io
+
+main(args: int[][]) {
+  print("Hello, Worl\x{64}!\n")
+  c3po: int = 'x' + 47;
+  r2d2: int = c3po // No Han Solo
+}
Index: tests/pa5Eth/io.eti
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/tests/pa5Eth/io.eti b/tests/pa5Eth/io.eti
new file mode 100644
--- /dev/null	(date 1674940885000)
+++ b/tests/pa5Eth/io.eti	(date 1674940885000)
@@ -0,0 +1,8 @@
+// I/O support
+
+print(str: int[])     // Print a string to standard output.
+println(str: int[])   // Print a string to standard output, followed by a newline.
+readln() : int[]      // Read from standard input until a newline.
+getchar() : int       // Read a single character from standard input.
+                      // Returns -1 if the end of input has been reached.
+eof() : bool          // Test for end of file on standard input.
Index: src/main/java/aar226_akc55_ayc62_ahl88/src/edu/cornell/cs/cs4120/xic/ir/visit/AbstractASMVisitor.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package aar226_akc55_ayc62_ahl88.src.edu.cornell.cs.cs4120.xic.ir.visit;\n\nimport aar226_akc55_ayc62_ahl88.asm.*;\nimport aar226_akc55_ayc62_ahl88.asm.Expressions.*;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.ASMArg2;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.ASMComment;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.ASMInstruction;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.ASMLabel;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.arithmetic.ASMAdd;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.arithmetic.ASMIDiv;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.arithmetic.ASMIMul;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.arithmetic.ASMSub;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.bitwise.*;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.jumps.*;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.mov.ASMMov;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.mov.ASMMovabs;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.stackops.ASMPop;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.stackops.ASMPush;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.subroutine.ASMCall;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.subroutine.ASMEnter;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.subroutine.ASMLeave;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.subroutine.ASMRet;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.tstcmp.*;\nimport aar226_akc55_ayc62_ahl88.src.edu.cornell.cs.cs4120.xic.ir.*;\nimport aar226_akc55_ayc62_ahl88.src.polyglot.util.InternalCompilerError;\nimport aar226_akc55_ayc62_ahl88.src.polyglot.util.Pair;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\n\n/**\n * NOTES:\n * - branches: use cmp then corresponding jump\n * - multireturn: store first argument in rax, push rest on stack\n * - function args: rdi, rsi, rdx, rcx, r8, r9, push rest on stack\n * - callee saved: rbx, rbp, and r12â€“r15\n * - caller saved: everything else\n * THINGS WE NEEEEEEEEEEEDDDDDDDDD\n * - ir compunit ->\n *      add glob mem locations\n *      call visit to all functions\n * - ir func decl ->\n *      create new label at the top for function name\n *      follow abi for args and register alloc\n *      call visit on each statement\n *      flatten arraylist we get back\n *      follow abi for correct func exit\n * - jump -> jr <label name>\n * - cjump ->\n *      two args: cmp <t1> <t2>; j<flag> <label name>\n *      if instance of IRConst and is boolliteral: true -> jr / false -> nothing\n * - move ->\n *      mooooooooooooove\n *      contains expr: used for dynamic tiling\n *      tiling\n * - mem\n * - binop\n * - call stmt ->\n *      init function call follow abi for function call (store func args correctly)\n *      jump to function\n *      clean accroding to ABI spec (be careful about multireturns and stack dead space)\n *      pop from function\n * - IR Label -> ASM label\n * Generic ASM Class will be called ASMNode\n */\n\npublic class AbstractASMVisitor {\n    private int tempCnt = 0;\n\n//    private HashMap<String,HashSet<String>> functionToTemps = new HashMap<>();\n\n    private final HashMap<String, Pair<Integer,Integer>> functionsNameToSig = new HashMap<>();\n\n    private String nxtTemp() {\n        return String.format(\"_ASMReg_t%d\", (tempCnt++));\n    }\n    private ASMDirectives getType(String name) {\n        String type = name.split(\"_\")[0];\n        if (type.equals(\"i\") || type.equals(\"b\")) {\n            return ASMDirectives.QUAD;\n        }\n        return ASMDirectives.ZERO;\n    }\n    // converts an IR TEMP to an ASM TEMP\n    private ASMTempExpr tempToASM(IRTemp t) {\n        return new ASMTempExpr(t.name());\n    }\n\n    public ArrayList<ASMInstruction> visit(IRData node){\n        throw new InternalCompilerError(\"not visiting IRDATA\");\n    }\n\n    public ASMInstruction binopCondToOpCode(IRBinOp bin,IRCJump node){\n        ASMNameExpr label = new ASMNameExpr(node.trueLabel());\n        return switch (bin.opType()){\n            case EQ -> new ASMJumpEqual(label);\n            case NEQ -> new ASMJumpNotEqual(label);\n            case LT -> new ASMJumpLT(label);\n            case ULT -> new ASMJumpULT(label);\n            case GT -> new ASMJumpGT(label);\n            case LEQ -> new ASMJumpLE(label);\n            case GEQ -> new ASMJumpGE(label);\n            default -> throw new InternalCompilerError(\"binop Cond is not boolean it is: \" + bin);\n        };\n    }\n    public ArrayList<ASMInstruction> visit(IRCJump node) {\n        ArrayList<ASMInstruction> instructions = new ArrayList<>();\n\n        IRExpr condition = node.cond();\n\n        if (condition instanceof IRBinOp c) { // maybe test is faster\n            // create function for IRBINOP\n            // DO A CMP instead\n            ASMAbstractReg tleft = munchIRExpr(c.left());\n            ASMAbstractReg tright = munchIRExpr(c.right());\n            instructions.addAll(c.left().getBestInstructions()); // instrs to create left temp\n            instructions.addAll(c.right().getBestInstructions()); // instrs to create right temp\n            instructions.add(new ASMCmp(tleft,tright)); // cmp\n            instructions.add(binopCondToOpCode(c,node));\n        } else if (condition instanceof IRConst c) {\n            if (c.value() != 0L){ // jump\n                instructions.add(new ASMJumpAlways(new ASMNameExpr(node.trueLabel())));\n            }\n        } else if (condition instanceof IRTemp c) {\n//            functionToTemps.get(curFunction).add(c.name());\n            ASMTempExpr tempName = tempToASM(c);\n            instructions.add(new ASMTest(tempName,tempName));\n            instructions.add(new ASMJumpNotEqual(new ASMNameExpr(node.trueLabel())));\n            //test t, t\n            //jnz l\n        } else if (condition instanceof IRMem c) {\n            ASMAbstractReg tempMem = munchIRExpr(c);\n            instructions.addAll(c.getBestInstructions());\n            instructions.add(new ASMTest(tempMem,tempMem));\n            instructions.add(new ASMJumpNotEqual(new ASMNameExpr(node.trueLabel())));\n            // do temp test and ASM Jump no Equal\n        }else{\n            throw new InternalCompilerError(\"CJUMP guard has another type\");\n        }\n        return instructions;\n    }\n    public ASMCompUnit visit(IRCompUnit node) {\n        HashSet<ASMData> globals = new HashSet<>();\n        HashMap<String, ArrayList<ASMInstruction>> functionToInstructionList = new HashMap<>();\n        HashMap<String, HashSet<String>> functionToTempsMapping = new HashMap<>();\n        for (IRData data : node.dataMap().values()) {\n            ASMLabel data_label = new ASMLabel(data.name());\n            ASMData data_instr = new ASMData(data_label, data.data());\n            globals.add(data_instr);\n            // add to ASMCOMP UNIT GLOBAL\n        }\n\n        for (IRFuncDecl func : node.functions().values()) {\n            String curFunction = func.name();\n//            functionToTemps.put(func.name(),new HashSet<>());\n            ArrayList<ASMInstruction> functionInstructions = visit(func);\n//            functionToTempsMapping.put(curFunction,functionToTemps.get(curFunction));\n            functionToInstructionList.put(curFunction,functionInstructions);\n//            replaceTemps(functionInstructions,curFunction);\n//            instructions.addAll(functionInstructions);\n        }\n\n        return new ASMCompUnit(globals,functionToInstructionList,functionToTempsMapping,functionsNameToSig);\n    }\n    public ArrayList<ASMInstruction> visit (IRConst x) {\n        ArrayList<ASMInstruction> instructions = new ArrayList<>();\n        boolean isInt = x.value() <= Integer.MAX_VALUE && x.value() >= Integer.MIN_VALUE;\n        ASMArg2 instruction = (isInt) ? new ASMMov(new ASMTempExpr(nxtTemp()),new ASMConstExpr(x.value()))\n                : new ASMMovabs(new ASMTempExpr(nxtTemp()),new ASMConstExpr(x.value()));\n        instructions.add(instruction);\n        return instructions;\n    }\n    public ArrayList<ASMInstruction> visit(IRFuncDecl node) {\n        ArrayList<ASMInstruction> result = new ArrayList<>();\n\n        // create new Starting label for this Function\n        result.add(new ASMLabel(node.name()));\n\n//        enter at Botoom\n//        push rbp\n//        mov rbp rsp\n//        sub rsp, 8*l\n//        result.add(new ASMPush(new ASMRegisterExpr(\"rbp\")));\n//        result.add(new ASMMov(new ASMRegisterExpr(\"rbp\"),new ASMRegisterExpr(\"rsp\")));\n\n        // need to calculate number of temporaries used\n\n        ArrayList<String> temps = new ArrayList<>();\n        // foo(1,2,3,4,5,6,7....) -> rdi, rsi, rdx, rcx, r8, r9, stack\n        int numParams = node.functionSig.inputTypes.size();\n        int numReturns = node.functionSig.outputTypes.size();\n        IRSeq body = (IRSeq) node.body();\n        for (int i = 0; i< numParams;i++){\n            IRMove nameAndArg = (IRMove) body.stmts().get(i);\n            IRTemp name = (IRTemp) nameAndArg.target();\n            temps.add(name.name());\n        }\n        ArrayList<ASMInstruction> bodyInstructions = new ArrayList<>();\n\n        if (numReturns > 2){\n//            functionToTemps.get(curFunction).add(\"_returnBase\");\n            bodyInstructions.add(new ASMMov(\n                    new ASMTempExpr(\"_returnBase\"),\n                    new ASMRegisterExpr(\"rdi\")\n            ));\n        }\n\n        int start = numReturns > 2 ? 2: 1;\n        int end   = numReturns > 2 ? numParams +1: numParams;\n        for (int i = start; i<=end;i++){\n\n            // Move arg into argI. argI <- RDI\n            ASMExpr ARGI = switch (i) {\n                case 1 -> new ASMRegisterExpr(\"rdi\");\n                case 2 -> new ASMRegisterExpr(\"rsi\");\n                case 3 -> new ASMRegisterExpr(\"rdx\");\n                case 4 -> new ASMRegisterExpr(\"rcx\");\n                case 5 -> new ASMRegisterExpr(\"r8\");\n                case 6 -> new ASMRegisterExpr(\"r9\");\n                default ->\n                        new ASMMemExpr(\n                                new ASMBinOpAddExpr(\n                                        new ASMRegisterExpr(\"rbp\"),\n                                        new ASMConstExpr(8L * (i - 7 + 2))));\n            };\n//            String tempName = \"_ARG\" + i;\n            String tempName = numReturns > 2 ? temps.get(i-2):temps.get(i-1);\n//            functionToTemps.get(curFunction).add(tempName);\n            // can't do [stack location] <- [stack location2]\n            // need intermediate rax <- [stack location2]\n            // then [stack location] <- temp rax\n//            if (i>=7){\n//                bodyInstructions.add(new ASMMov(new ASMRegisterExpr(\"rax\"),ARGI));\n//                bodyInstructions.add(new ASMMov(new ASMTempExpr(tempName),new ASMRegisterExpr(\"rax\")));\n//            }\n//            // just do MOV [stack location] <- register\n//            else{\n//                bodyInstructions.add(new ASMMov(new ASMTempExpr(tempName),ARGI));\n//            }\n            bodyInstructions.add(new ASMMov(new ASMTempExpr(tempName),ARGI));\n        }\n        if (node.body() instanceof  IRSeq seq){\n            for (int i = numParams;i< seq.stmts().size();i++){\n                IRStmt stmt = seq.stmts().get(i);\n                bodyInstructions.addAll(stmt.accept(this));\n            }\n        }else{\n            throw new InternalCompilerError(\"body isn't a seq\");\n        }\n        // add enter at begin.\n        // enter 8*L, 0\n//        ASMEnter begin = new ASMEnter(new ASMConstExpr(8L*functionToTemps.get(curFunction).size()),new ASMConstExpr(0));\n        ASMEnter begin = new ASMEnter(new ASMConstExpr(0),new ASMConstExpr(0));\n        result.add(begin);\n        result.addAll(bodyInstructions);\n        return result;\n    }\n    public ArrayList<ASMInstruction> visit(IRJump jump) {\n        ArrayList<ASMInstruction> instructions = new ArrayList<>();\n        if (jump.target() instanceof IRName) {\n            instructions.add(new ASMJumpAlways(new ASMNameExpr(jump.label())));\n        }\n        return instructions;\n    }\n    public ArrayList<ASMInstruction> visit(IRLabel node) {\n        ArrayList<ASMInstruction> instructions = new ArrayList<>();\n        instructions.add(new ASMLabel(node.name()));\n        return instructions;\n    }\n    // Always use these three rax, rcx, and rdx\n    public ArrayList<ASMInstruction> visit(IRMove node){\n        IRExpr dest = node.target();\n        IRExpr source = node.source();\n        ArrayList<ASMInstruction> instructions = new ArrayList<>();\n\n        // TEMP TEMP\n        if (dest instanceof IRTemp t1 && source instanceof IRTemp t2) { // random case for testing atm\n            tileTempTemp(t1, t2, instructions);\n        // TEMP CONST\n        } else if (dest instanceof IRTemp t && source instanceof IRConst x) {\n            tileTempConst(t, x, instructions);\n        // TEMP MEM\n        } else if (dest instanceof IRTemp t && source instanceof IRMem m) {\n            tileTempMem(t, m, instructions);\n        // TEMP BINOP\n        } else if (dest instanceof IRTemp t && source instanceof IRBinOp b) {\n            tileTempBinop(t, b, instructions);\n        // MEM TEMP\n        } else if (dest instanceof IRMem m && source instanceof IRTemp t) {\n            tileMemTemp(m, t, instructions);\n        // MEM MEM\n        } else if (dest instanceof IRMem m1 && source instanceof IRMem m2) {\n            tileMemMem(m1, m2, instructions);\n        // MEM CONST\n        } else if (dest instanceof IRMem m && source instanceof IRConst x) {\n            tileMemConst(m, x, instructions);\n        // MEM BINOP\n        } else if (dest instanceof IRMem m && source instanceof IRBinOp b) {\n            tileMemBinop(m, b, instructions);\n        } else {\n            throw new InternalCompilerError(\"TODO Other moves\");\n        }\n        return instructions;\n    }\n\n    // Base Case\n    public long tileTempTemp(IRTemp t1, IRTemp t2, ArrayList<ASMInstruction> instrs) {\n        instrs.add(new ASMMov(new ASMTempExpr(t1.name()), new ASMTempExpr(t2.name())));\n        return 1;\n    }\n\n    // Base Case\n    public long tileTempConst(IRTemp t, IRConst c, ArrayList<ASMInstruction> instrs) {\n        instrs.add(new ASMMov(new ASMTempExpr(t.name()), new ASMConstExpr(c.value())));\n        return 1;\n    }\n\n    // Can Expand\n    public long tileTempMem(IRTemp t, IRMem m, ArrayList<ASMInstruction> instrs) {\n        long curBestCost = Long.MAX_VALUE;\n        ArrayList<ASMInstruction> curBestInstructions = new ArrayList<>();\n        if (false){ // other patterns;\n\n        }else { // catch all case\n            ASMAbstractReg temp = munchIRExpr(m);\n            if (m.getBestCost() + 1 < curBestCost){\n                ArrayList<ASMInstruction> caseInstructions = new ArrayList<>(m.getBestInstructions()); // instructions for Mem\n                caseInstructions.add(new ASMMov(new ASMTempExpr(t.name()), temp)); // move the temp mem into ASMMOV\n                curBestInstructions = caseInstructions;\n                curBestCost = m.getBestCost() + 1;\n            }\n        }\n        instrs.addAll(curBestInstructions);\n        return curBestCost;\n    }\n\n    // Can Expand\n    public long tileTempBinop(IRTemp t, IRBinOp b, ArrayList<ASMInstruction> instrs) {\n        long curBestCost = Long.MAX_VALUE;\n        ArrayList<ASMInstruction> curBestInstructions = new ArrayList<>();\n        if (false){ // other patterns;\n\n        }else { // catch all case\n            ASMAbstractReg temp = munchIRExpr(b);\n            if (b.getBestCost() + 1 < curBestCost){\n                ArrayList<ASMInstruction> caseInstructions = new ArrayList<>(b.getBestInstructions()); // instructions for Mem\n                caseInstructions.add(new ASMMov(new ASMTempExpr(t.name()), temp)); // move the temp mem into ASMMOV\n                curBestInstructions = caseInstructions;\n                curBestCost = b.getBestCost() + 1;\n            }\n        }\n        instrs.addAll(curBestInstructions);\n        return curBestCost;\n    }\n\n    // Can Expand\n    public long tileMemTemp(IRMem m, IRTemp t, ArrayList<ASMInstruction> instrs) {\n        long curBestCost = Long.MAX_VALUE;\n        ArrayList<ASMInstruction> curBestInstructions = new ArrayList<>();\n        if (false){ // other patterns;\n\n        }else { // catch all case\n            ASMAbstractReg temp = munchIRExpr(m);\n            if (m.getBestCost() + 1 < curBestCost){\n                ArrayList<ASMInstruction> caseInstructions = new ArrayList<>(m.getBestInstructions()); // instructions for Mem\n                caseInstructions.add(new ASMMov(new ASMTempExpr(t.name()), temp)); // move the temp mem into ASMMOV\n                curBestInstructions = caseInstructions;\n                curBestCost = m.getBestCost() + 1;\n            }\n        }\n        instrs.addAll(curBestInstructions);\n        return curBestCost;\n    }\n    // Can Expand\n    public long tileMemMem(IRMem m1, IRMem m2, ArrayList<ASMInstruction> instrs) {\n        long curBestCost = Long.MAX_VALUE;\n        ArrayList<ASMInstruction> curBestInstructions = new ArrayList<>();\n        if (false){ // other patterns;\n\n        }else { // catch all case do right mem then left mem\n            ASMAbstractReg leftTemp = munchIRExpr(m1);\n            ASMAbstractReg rightTemp = munchIRExpr(m2);\n            if (m2.getBestCost() + m1.getBestCost() +  1 < curBestCost){\n                ArrayList<ASMInstruction> caseInstructions = new ArrayList<>(); // instructions for Mem\n                caseInstructions.addAll(m2.getBestInstructions());\n                caseInstructions.addAll(m1.getBestInstructions());\n                caseInstructions.add(new ASMMov(leftTemp, rightTemp)); // move the temp mem into ASMMOV\n                curBestInstructions = caseInstructions;\n                curBestCost = m2.getBestCost() + m1.getBestCost() +  1;\n            }\n        }\n        instrs.addAll(curBestInstructions);\n        return curBestCost;\n    }\n    // Can Expand\n    public long tileMemConst(IRMem m, IRConst c, ArrayList<ASMInstruction> instrs) {\n        long curBestCost = Long.MAX_VALUE;\n        ArrayList<ASMInstruction> curBestInstructions = new ArrayList<>();\n        if (false){ // other patterns;\n\n        }else { // catch all case\n            ASMAbstractReg temp = munchIRExpr(m);\n            if (m.getBestCost() + 1 < curBestCost){\n                ArrayList<ASMInstruction> caseInstructions = new ArrayList<>(m.getBestInstructions()); // instructions for Mem\n                caseInstructions.add(new ASMMov(temp, new ASMConstExpr(c.value()))); // move the temp mem into ASMMOV\n                curBestInstructions = caseInstructions;\n                curBestCost = m.getBestCost() + 1;\n            }\n        }\n        instrs.addAll(curBestInstructions);\n        return curBestCost;\n    }\n    // Can Expand\n    public long tileMemBinop(IRMem m, IRBinOp b, ArrayList<ASMInstruction> instrs) {\n        long curBestCost = Long.MAX_VALUE;\n        ArrayList<ASMInstruction> curBestInstructions = new ArrayList<>();\n        if (false){ // other patterns;\n\n        }else { // catch all case\n            ASMAbstractReg temp1 = munchIRExpr(m);\n            ASMAbstractReg temp2 = munchIRExpr(b);\n            if (m.getBestCost() + b.getBestCost() + 1 < curBestCost){\n                ArrayList<ASMInstruction> caseInstructions = new ArrayList<>(); // instructions for Mem\n                caseInstructions.addAll(b.getBestInstructions());\n                caseInstructions.addAll(m.getBestInstructions());\n                caseInstructions.add(new ASMMov(temp1, temp2)); // move the temp mem into ASMMOV\n                curBestInstructions = caseInstructions;\n                curBestCost = m.getBestCost() + 1;\n            }\n        }\n        instrs.addAll(curBestInstructions);\n        return curBestCost;\n    }\n\n    private ASMAbstractReg munchIRExpr(IRExpr e) {\n        IRNode_c top = (IRNode_c) e;\n        if (top.visited){\n            System.out.println(\"visited\");\n            return top.tempName;\n        }\n        if (e instanceof IRBinOp binop) {\n            return munchBinop(binop);\n        }else if (e instanceof IRTemp t){\n            return munchTemp(t);\n        }else if (e instanceof IRConst cons){\n            return munchIRConst(cons);\n        }else if (e instanceof IRName name){ // cheese way of doing it\n            return munchIRName(name);\n        }else if (e instanceof IRMem mem){\n            return munchIRMem(mem);\n        }else{\n            throw new InternalCompilerError(\"TODO EXPR not tested\");\n        }\n    }\n    private ASMTempExpr munchIRName(IRName name) {\n        name.visited = true;\n        name.bestCost = 0;\n        name.bestInstructions = new ArrayList<>();\n        return new ASMTempExpr(name.name());\n    }\n    private ASMTempExpr munchIRMem(IRMem mem) {\n        long curBestCost = Long.MAX_VALUE;\n        ArrayList<ASMInstruction> curBestInstructions = new ArrayList<>();\n        ASMTempExpr destTemp = new ASMTempExpr(nxtTemp());\n        if (false){ // other patterns;\n\n        }else { // catch all case\n            ASMAbstractReg munched = munchIRExpr(mem.expr());\n            if ( mem.expr().getBestCost() +1 < curBestCost){\n                ArrayList<ASMInstruction> caseInstructions = new ArrayList<>(mem.expr().getBestInstructions()); // instructions for Mem\n                caseInstructions.add(new ASMMov(destTemp,new ASMMemExpr(munched)));\n                curBestInstructions = caseInstructions;\n                curBestCost = mem.expr().getBestCost() +1;\n            }\n        }\n        mem.visited = true;\n        mem.bestCost = curBestCost;\n        mem.bestInstructions = curBestInstructions;\n        return destTemp;\n//        return null;\n    }\n    private ASMTempExpr munchTemp(IRTemp temp) {\n        temp.visited = true;\n        temp.bestCost = 0;\n        temp.bestInstructions = new ArrayList<>();\n        return new ASMTempExpr(temp.name());\n    }\n    private ASMTempExpr munchIRConst(IRConst c){\n        c.visited = true;\n        c.bestCost = 1;\n        String extraTemp = nxtTemp();\n        ArrayList<ASMInstruction> extraInstructions = new ArrayList<>();\n        extraInstructions.add(new ASMMov(new ASMTempExpr(extraTemp),new ASMConstExpr(c.value())));\n        c.bestInstructions = extraInstructions;\n        return new ASMTempExpr(extraTemp);\n    }\n    private ASMAbstractReg munchBinop(IRBinOp binop) {\n        // TODO: LATER ADD TEMP/CONST, TEMP/TEMP, CONST/TEMP, ELSE MUCH\n        ASMAbstractReg l1 = munchIRExpr(binop.left());\n        ASMAbstractReg l2 = munchIRExpr(binop.right());\n        ASMTempExpr destTemp = new ASMTempExpr(nxtTemp());\n        ArrayList<ASMInstruction> instrs = new ArrayList<>();\n        instrs.addAll(binop.left().getBestInstructions());\n        instrs.addAll(binop.right().getBestInstructions());\n        switch (binop.opType()) {\n            case ADD:\n                binop.bestCost = binop.left().getBestCost() +\n                        binop.right().getBestCost() + 2;\n                instrs.add(new ASMMov(destTemp, l1));\n                instrs.add(new ASMAdd(l1, l2));\n                break;\n            case MUL:\n                binop.bestCost = binop.left().getBestCost() +\n                        binop.right().getBestCost() + 2;\n                instrs.add(new ASMMov(destTemp, l1));\n                instrs.add(new ASMIMul(destTemp, l2));\n                break;\n            case DIV: // rax/div, store result in rax and remainder in rdx\n                binop.bestCost = binop.left().getBestCost() +\n                        binop.right().getBestCost() + 2;\n                instrs.add(new ASMMov(new ASMRegisterExpr(\"rax\"), l1));\n                instrs.add(new ASMIDiv(l2));\n                instrs.add(new ASMMov(destTemp, new ASMRegisterExpr(\"rax\")));\n                break;\n            case SUB:\n                binop.bestCost = binop.left().getBestCost() +\n                        binop.right().getBestCost() + 2;\n                instrs.add(new ASMMov(destTemp, l1));\n                instrs.add(new ASMArg2(ASMOpCodes.SUB, destTemp, l2));\n                break;\n            case HMUL: // TODO: fix this\n                binop.bestCost = binop.left().getBestCost() +\n                        binop.right().getBestCost() + 5;\n                ASMTempExpr srcTemp = new ASMTempExpr(nxtTemp());\n\n                instrs.add(new ASMMov(destTemp, l1));\n                instrs.add(new ASMShr(srcTemp, l2));\n                instrs.add(new ASMShr(destTemp, new ASMConstExpr(32)));\n                instrs.add(new ASMShr(srcTemp, new ASMConstExpr(32)));\n                instrs.add(new ASMIMul(destTemp, srcTemp));\n                break;\n            case MOD: // rax/div, store result in rax and remainder in rdx\n                binop.bestCost = binop.left().getBestCost() +\n                        binop.right().getBestCost() + 3;\n                instrs.add(new ASMMov(new ASMRegisterExpr(\"rax\"), l1));\n                instrs.add(new ASMIDiv(l2));\n                instrs.add(new ASMMov(destTemp, new ASMRegisterExpr(\"rdx\")));\n                break;\n            case AND:\n                binop.bestCost = binop.left().getBestCost() +\n                        binop.right().getBestCost() + 2;\n                instrs.add(new ASMMov(destTemp, l1));\n                instrs.add(new ASMAnd(destTemp, l2));\n                break;\n            case OR:\n                binop.bestCost = binop.left().getBestCost() +\n                        binop.right().getBestCost() + 2;\n                instrs.add(new ASMMov(destTemp, l1));\n                instrs.add(new ASMOr(destTemp, l2));\n                break;\n            case XOR:\n                binop.bestCost = binop.left().getBestCost() +\n                        binop.right().getBestCost() + 2;\n                instrs.add(new ASMMov(destTemp, l1));\n                instrs.add(new ASMXor(destTemp, l2));\n                break;\n            case LSHIFT: // logical left shift\n                binop.bestCost = binop.left().getBestCost() +\n                        binop.right().getBestCost() + 2;\n                instrs.add(new ASMMov(destTemp, l1));\n                instrs.add(new ASMShl(destTemp, l2));\n                break;\n            case RSHIFT: // logical right shift\n                binop.bestCost = binop.left().getBestCost() +\n                        binop.right().getBestCost() + 2;\n                instrs.add(new ASMMov(destTemp, l1));\n                instrs.add(new ASMShr(destTemp, l2));\n                break;\n            case ARSHIFT:\n                binop.bestCost = binop.left().getBestCost() +\n                        binop.right().getBestCost() + 2;\n                instrs.add(new ASMMov(destTemp, l1));\n                instrs.add(new ASMSar(destTemp, l2));\n                break;\n            case EQ:\n                binop.bestCost = binop.left().getBestCost() +\n                        binop.right().getBestCost() + 4;\n                instrs.add(new ASMMov(destTemp, l1));\n                instrs.add(new ASMCmp(destTemp, l2));\n                instrs.add(new ASMSete(new ASMRegisterExpr(\"al\")));\n//                instrs.add(new ASMAnd(al, new ASMConstExpr(1))); in clang but not in gcc\n                instrs.add(new ASMMov(destTemp, new ASMRegisterExpr(\"al\")));\n                break;\n            case NEQ:\n                binop.bestCost = binop.left().getBestCost() +\n                        binop.right().getBestCost() + 4;\n                instrs.add(new ASMMov(destTemp, l1));\n                instrs.add(new ASMCmp(destTemp, l2));\n                instrs.add(new ASMSetne(new ASMRegisterExpr(\"al\")));\n//                instrs.add(new ASMAnd(al, new ASMConstExpr(1))); in clang but not in gcc\n                instrs.add(new ASMMov(destTemp, new ASMRegisterExpr(\"al\")));\n                break;\n            case LT:\n                binop.bestCost = binop.left().getBestCost() +\n                        binop.right().getBestCost() + 4;\n                instrs.add(new ASMMov(destTemp, l1));\n                instrs.add(new ASMCmp(destTemp, l2));\n                instrs.add(new ASMSetl(new ASMRegisterExpr(\"al\")));\n//                instrs.add(new ASMAnd(al, new ASMConstExpr(1))); in clang but not in gcc\n                instrs.add(new ASMMov(destTemp, new ASMRegisterExpr(\"al\")));\n                break;\n            case ULT:\n                binop.bestCost = binop.left().getBestCost() +\n                        binop.right().getBestCost() + 4;\n                instrs.add(new ASMMov(destTemp, l1));\n                instrs.add(new ASMCmp(destTemp, l2));\n                instrs.add(new ASMSetb(new ASMRegisterExpr(\"al\")));\n                //                instrs.add(new ASMAnd(al, new ASMConstExpr(1))); in clang but not in gcc\n                instrs.add(new ASMMov(destTemp, new ASMRegisterExpr(\"al\")));\n                break;\n            case GT:\n                binop.bestCost = binop.left().getBestCost() +\n                        binop.right().getBestCost() + 4;\n                instrs.add(new ASMMov(destTemp, l1));\n                instrs.add(new ASMCmp(destTemp, l2));\n                instrs.add(new ASMSetg(new ASMRegisterExpr(\"al\")));\n//                instrs.add(new ASMAnd(al, new ASMConstExpr(1))); in clang but not in gcc\n                instrs.add(new ASMMov(destTemp, new ASMRegisterExpr(\"al\")));\n                break;\n            case LEQ:\n                binop.bestCost = binop.left().getBestCost() +\n                        binop.right().getBestCost() + 4;\n                instrs.add(new ASMMov(destTemp, l1));\n                instrs.add(new ASMCmp(destTemp, l2));\n                instrs.add(new ASMSetle(new ASMRegisterExpr(\"al\")));\n//                instrs.add(new ASMAnd(al, new ASMConstExpr(1))); in clang but not in gcc\n                instrs.add(new ASMMov(destTemp, new ASMRegisterExpr(\"al\")));\n                break;\n            case GEQ:\n                binop.bestCost = binop.left().getBestCost() +\n                        binop.right().getBestCost() + 4;\n                instrs.add(new ASMMov(destTemp, l1));\n                instrs.add(new ASMCmp(destTemp, l2));\n                instrs.add(new ASMSetge(new ASMRegisterExpr(\"al\")));\n//                instrs.add(new ASMAnd(al, new ASMConstExpr(1))); in clang but not in gcc\n                instrs.add(new ASMMov(destTemp, new ASMRegisterExpr(\"al\")));\n                break;\n        }\n        binop.bestInstructions = instrs;\n        binop.visited = true;\n        return destTemp;\n    }\n\n\n\n\n    public ArrayList<ASMInstruction> visit(IRSeq node){\n        ArrayList<ASMInstruction> instructions = new ArrayList<>();\n        for (IRStmt stmt : node.stmts()) {\n            ArrayList<ASMInstruction> stmtInstrs = stmt.accept(this);\n            instructions.addAll(stmtInstrs);\n        }\n        return instructions;\n    }\n    public ArrayList<ASMInstruction> visit(IRReturn node) {\n        //\n        ArrayList<ASMInstruction> returnInstructions = new ArrayList<>();\n        int returnSize = node.rets().size();\n\n        ArrayList<String> tempNames = new ArrayList<>();\n        //in case returns stop being temporaries in the future.\n        for (IRExpr e: node.rets()){\n             if (e instanceof IRTemp t){\n                tempNames.add(t.name());\n             }else{\n                 System.out.println(\"return is not a temp? \" + e);\n                 String nxtName = nxtTemp();\n                 tempNames.add(nxtName);\n//                 ASMTempExpr tmp = new ASMTempExpr(nxtName);\n                 // need to translate\n                 throw new InternalCompilerError(\"return has an element that isn't a temp\");\n             }\n        }\n//        functionToTemps.get(curFunction).addAll(tempNames);\n        // looping in reverse so rax can be used temporarily until the end\n        for (int i = 1; i <= returnSize; i++) {\n            // move expression to Return Location\n            // Move ret into reti. reti <- RDI\n            ASMExpr retI = switch (i) {\n                case 1 -> new ASMRegisterExpr(\"rax\");\n                case 2 -> new ASMRegisterExpr(\"rdx\");\n                default -> new ASMMemExpr(\n                        new ASMBinOpAddExpr(\n                                new ASMTempExpr(\"_returnBase\"),\n                                new ASMConstExpr(8L*(i-3))));\n            };\n//\n//            if (i >2){\n//                if (i == 3){\n//                    returnInstructions.add(new ASMMov(new ASMRegisterExpr(\"rsi\"),\n//                            new ASMTempExpr(\"_returnBase\")));\n//                }\n//                System.out.println(\"greater than 3\");\n//                // just in case we just put everything on the stack lol need intermediate\n//                // rcx <- [origin]\n//                returnInstructions.add(new ASMMov(new ASMRegisterExpr(\"rcx\"),new ASMTempExpr(tempNames.get(i-1)))); // check this\n//                // [dest] <- rcx\n//                returnInstructions.add(new ASMMov(retI,new ASMRegisterExpr(\"rcx\")));\n//            }else{\n//                returnInstructions.add(new ASMMov(retI,new ASMTempExpr(tempNames.get(i-1))));\n//            }\n            returnInstructions.add(new ASMMov(retI,new ASMTempExpr(tempNames.get(i-1))));\n        }\n\n        // leave\n        // ret\n        returnInstructions.add(new ASMLeave());\n        returnInstructions.add(new ASMRet());\n        return returnInstructions;\n    }\n    public ArrayList<ASMInstruction> visit(IRCallStmt node) {\n        ArrayList<ASMInstruction> instructions = new ArrayList<>();\n        IRName functionName = (IRName) node.target();\n        int argSiz = node.args().size();\n        ArrayList<String> tempNames = new ArrayList<>();\n        //in case returns stop being temporaries in the future.\n        // Will have to revisit translation too if we change iRCALLSTMT\n        // Move the Push translations to later\n        for (IRExpr e: node.args()){\n            if (e instanceof IRTemp t){\n                tempNames.add(t.name());\n            }else{\n                System.out.println(\"call is not a temp? \" + e);\n                String nxtName = nxtTemp();\n                tempNames.add(nxtName);\n                ASMTempExpr tmp = new ASMTempExpr(nxtName);\n                // need to translate\n                throw new InternalCompilerError(\"return has an element that isn't a temp\");\n            }\n        }\n//        functionToTemps.get(curFunction).addAll(tempNames);\n        instructions.add(new ASMComment(\"Add Padding\",functionName.name()));\n        // add extra stack space for returns\n        if (node.n_returns() >2){\n            instructions.add(new ASMSub(\n                    new ASMRegisterExpr(\"rsp\"),\n                    new ASMConstExpr(8* (node.n_returns()-2))));\n            instructions.add(new ASMMov(\n                    new ASMRegisterExpr(\"rdi\"),\n                    new ASMRegisterExpr(\"rsp\")));\n        }\n        // pushes for Arguments\n        if (argSiz >= 6){\n            int end = node.n_returns() > 2 ? 6 : 7;\n            int ind = tempNames.size();\n            while (ind >= end){\n                instructions.add(new ASMPush(new ASMTempExpr(tempNames.get(ind-1))));\n                ind--;\n            }\n        }\n        int start = node.n_returns() > 2 ? Math.min(argSiz+1,6): Math.min(argSiz,6);\n        int end = node.n_returns() > 2 ? 2 : 1;\n        for (int i = start; i >= end; i--) {\n            // move expression from temp to required register\n            // Move ret into reti. reti <- RDI\n            ASMExpr argI = switch (i) {\n                case 1 -> new ASMRegisterExpr(\"rdi\");\n                case 2 -> new ASMRegisterExpr(\"rsi\");\n                case 3 -> new ASMRegisterExpr(\"rdx\");\n                case 4 -> new ASMRegisterExpr(\"rcx\");\n                case 5 -> new ASMRegisterExpr(\"r8\");\n                case 6 -> new ASMRegisterExpr(\"r9\");\n                default -> throw new InternalCompilerError(\"should not be in default for Function Call\");\n            };\n            int loc = node.n_returns() > 2? i-2: i-1;\n            String tempName = tempNames.get(loc);\n            instructions.add(new ASMMov(argI,new ASMTempExpr(tempName)));\n        }\n        // Align by 16 bytes I have no idea how\n        functionsNameToSig.put(functionName.name(),new Pair<>(argSiz,node.n_returns().intValue()));\n        instructions.add(new ASMCall(new ASMNameExpr(functionName.name())));\n\n        if (argSiz > 6 && node.n_returns() <= 2){\n            instructions.add(new ASMAdd(new ASMRegisterExpr(\"rsp\"),\n                    new ASMConstExpr(8L*(argSiz-6))));\n        }else if (argSiz > 5 && node.n_returns() > 2){\n//            System.out.println(\"im here\");\n            instructions.add(new ASMAdd(new ASMRegisterExpr(\"rsp\"),\n                    new ASMConstExpr(8L*(argSiz-5))));\n        }\n        String ret = \"_RV\";\n        for (int i = 1; i<= node.n_returns();i++){\n            ASMTempExpr temp = new ASMTempExpr(ret+i);\n            if (i == 1){\n                instructions.add(new ASMMov(temp,new ASMRegisterExpr(\"rax\")));\n            }else if (i == 2){\n                instructions.add(new ASMMov(temp,new ASMRegisterExpr(\"rdx\")));\n            }else{\n                instructions.add(new ASMPop(temp));\n            }\n        }\n        instructions.add(new ASMComment(\"Undo Padding\",functionName.name()));\n        return instructions;\n    }\n\n    public ArrayList<ASMInstruction> visit(IRExp irExp) {\n        System.out.println(\"don't have irExp\");\n        return new ArrayList<>();\n    }\n\n    public ArrayList<ASMInstruction> visit(IRTemp irTemp) {\n        return null;\n    }\n\n    public ArrayList<ASMInstruction> visit(IRName irName) {\n        return null;\n    }\n\n    public ArrayList<ASMInstruction> visit(IRMem irMem) {\n        return null;\n    }\n\n    public ArrayList<ASMInstruction> visit(IRBinOp irBinOp) {\n        return null;\n    }\n\n    public ArrayList<ASMInstruction> visit(IRESeq ireSeq) {\n        System.out.println(\"don't have ireSeq\");\n        return new ArrayList<>();\n    }\n\n    public ArrayList<ASMInstruction> visit(IRCall irCall) {\n        System.out.println(\"don't have irCall\");\n        return new ArrayList<>();\n    }\n\n    private ArrayList<ASMInstruction> visitExpression(IRExpr expr) {\n        if (expr instanceof IRBinOp bop)\n            return visit(bop);\n        else if (expr instanceof IRCallStmt call)\n            return visit(call);\n        else if (expr instanceof IRConst cnst)\n            return visit(cnst);\n        else if (expr instanceof IRMem mem)\n            return visit(mem);\n        else if (expr instanceof IRName name)\n            return visit(name);\n        else if (expr instanceof IRTemp tmp)\n            return visit(tmp);\n        else throw new InternalCompilerError(\"Invalid expression for visitExpression\");\n    }\n\n//    private void replaceTemps(ArrayList<ASMInstruction> instructions, String functionName){\n//        functionToTemps.get(functionName);\n//        int index = 1;\n//        HashMap<String, Integer> tempToStack = new HashMap<>();\n//        for (String temp: functionToTemps.get(functionName)){\n//            tempToStack.put(temp,index*8);\n//            index++;\n//        }\n//        for (ASMInstruction instr: instructions){\n//            instr.createPrint(tempToStack);\n//            System.out.println(instr);\n//        }\n//    }\n\n    // TODO: 4/1/2023\n    // move\n    // TODO: 4/1/2023\n    // temp\n    // TODO: 4/1/2023\n    // mem\n    // TODO: 4/1/2023\n    // call_stmt\n    // TODO: 4/1/2023\n    // name\n    // TODO: 4/1/2023\n    // RETURN\n}\n\n//    int index = numParams;\n//            while (index < seq.stmts().size()){\n//        IRStmt stmt = seq.stmts().get(index);\n//        bodyInstructions.addAll(stmt.accept(this));\n//        if (stmt instanceof IRCallStmt call){\n//        int rvMoves = Math.toIntExact(call.n_returns());\n//        for (int i = 1; i <= rvMoves;i++){\n//        int getInd = (rvMoves + i-1);\n//        IRMove nameAndArg = (IRMove) body.stmts().get(getInd);\n//        IRTemp name = (IRTemp) nameAndArg.target();\n//        ASMTempExpr retName = new ASMTempExpr(name.name());\n//        if (i == 1){\n//        bodyInstructions.add(new ASMMov(retName,new ASMRegisterExpr(\"rax\")));\n//        }else if (i == 2){\n//        bodyInstructions.add(new ASMMov(retName,new ASMRegisterExpr(\"rdx\")));\n//        }else{\n//        bodyInstructions.add(new ASMPop(retName));\n//        }\n//        }\n//        index += rvMoves+1;\n//        }else{\n//        index++;\n//        }\n//        }\n\n//        if (dest instanceof IRTemp t1 && source instanceof IRTemp t2){ // random case for testing atm\n//            functionToTemps.get(curFunction).add(t1.name());\n//            functionToTemps.get(curFunction).add(t2.name());\n//            instructions.add(new ASMMov(new ASMTempExpr(t1.name()),new ASMTempExpr(t2.name())));\n//        }else if (dest instanceof IRTemp t1 && source instanceof IRConst x){\n//            functionToTemps.get(curFunction).add(t1.name());\n//            boolean isInt = x.value() <= Integer.MAX_VALUE && x.value() >= Integer.MIN_VALUE;\n//            ASMArg2 instruction = (isInt) ? new ASMMov(new ASMTempExpr(t1.name()),new ASMConstExpr(x.value()))\n//                    : new ASMMovabs(new ASMTempExpr(t1.name()),new ASMConstExpr(x.value()));\n//            instructions.add(instruction);\n//        }else{\n//            throw new InternalCompilerError(\"TODO Other moves\");\n//        }
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/aar226_akc55_ayc62_ahl88/src/edu/cornell/cs/cs4120/xic/ir/visit/AbstractASMVisitor.java b/src/main/java/aar226_akc55_ayc62_ahl88/src/edu/cornell/cs/cs4120/xic/ir/visit/AbstractASMVisitor.java
--- a/src/main/java/aar226_akc55_ayc62_ahl88/src/edu/cornell/cs/cs4120/xic/ir/visit/AbstractASMVisitor.java	(revision 6f637fce7826c8703ade4b7b0afc8637d41fdb40)
+++ b/src/main/java/aar226_akc55_ayc62_ahl88/src/edu/cornell/cs/cs4120/xic/ir/visit/AbstractASMVisitor.java	(date 1681158838948)
@@ -94,6 +94,18 @@
     public ASMInstruction binopCondToOpCode(IRBinOp bin,IRCJump node){
         ASMNameExpr label = new ASMNameExpr(node.trueLabel());
         return switch (bin.opType()){
+//            case ADD -> null;
+//            case SUB -> null;
+//            case MUL -> null;
+//            case HMUL -> null;
+//            case DIV -> null;
+//            case MOD -> null;
+//            case AND -> null;
+//            case OR -> null;
+//            case XOR -> null;
+//            case LSHIFT -> null;
+//            case RSHIFT -> null;
+//            case ARSHIFT -> null;
             case EQ -> new ASMJumpEqual(label);
             case NEQ -> new ASMJumpNotEqual(label);
             case LT -> new ASMJumpLT(label);
Index: tests/pa5Eth/conv.eti
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/tests/pa5Eth/conv.eti b/tests/pa5Eth/conv.eti
new file mode 100644
--- /dev/null	(date 1674940885000)
+++ b/tests/pa5Eth/conv.eti	(date 1674940885000)
@@ -0,0 +1,9 @@
+// String conversion functions
+
+// If "str" contains a sequence of ASCII characters that correctly represent
+// an integer constant n, return (n, true). Otherwise return (0, false).
+parseInt(str: int[]): int, bool
+
+// Return a sequence of ASCII characters representing the
+// integer n.
+unparseInt(n: int): int[]
