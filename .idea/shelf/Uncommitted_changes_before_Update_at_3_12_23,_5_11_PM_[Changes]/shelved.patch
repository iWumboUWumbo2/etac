Index: src/main/java/aar226_akc55_ayc62_ahl88/src/edu/cornell/cs/cs4120/xic/ir/visit/IRLoweringVisitor.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package aar226_akc55_ayc62_ahl88.src.edu.cornell.cs.cs4120.xic.ir.visit;\n\nimport aar226_akc55_ayc62_ahl88.newast.stmt.Block;\nimport aar226_akc55_ayc62_ahl88.newast.stmt.Stmt;\nimport aar226_akc55_ayc62_ahl88.src.edu.cornell.cs.cs4120.xic.ir.*;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\n\n// Need to think about what to add\nclass BasicBlock {\n    public static int id = 0;\n    public boolean marked;\n    public boolean visited;\n\n    public ArrayList<BasicBlock> predecessors;\n    public ArrayList<BasicBlock> neighbors;\n\n    public BasicBlock() {\n        id++;\n        marked = false;\n        visited = false;\n    }\n}\n\npublic class IRLoweringVisitor extends IRVisitor {\n    private static final int WORD_BYTES = 8;\n    private static final String OUT_OF_BOUNDS = \"_xi_out_of_bounds\";\n    private int labelCnt;\n    private int tempCnt;\n\n    private ArrayList<BasicBlock> blocks;\n    private ArrayList<BasicBlock> orderedBlocks;\n\n    private String nxtLabel() {\n        return String.format(\"l%d\", (labelCnt++));\n    }\n\n    private String nxtTemp() {\n        return String.format(\"tl%d\", (tempCnt++));\n    }\n    public IRLoweringVisitor (IRNodeFactory inf) {\n        super(inf);\n        labelCnt = 0;\n        tempCnt = 0;\n    }\n\n    @Override\n    protected IRNode leave(IRNode parent, IRNode n, IRNode n_, IRVisitor v_) {\n        if (n_ instanceof IRBinOp irbin) return canon(irbin);\n        if (n_ instanceof IRCall irc) return canon(irc);\n        if (n_ instanceof IRCallStmt ircstmt) return canon(ircstmt);\n        if (n_ instanceof IRCJump ircj) return canon(ircj);\n        if (n_ instanceof IRCompUnit icu) return canon(icu);\n        if (n_ instanceof IRConst ic) return canon(ic);\n        if (n_ instanceof IRESeq ireseq) return canon(ireseq);\n        if (n_ instanceof IRExp irexp) return  canon(irexp);\n        if (n_ instanceof IRFuncDecl irfunc) return canon(irfunc);\n        if (n_ instanceof IRJump irj) return canon(irj);\n        if (n_ instanceof IRLabel irl) return canon(irl);\n        if (n_ instanceof IRMem irmem) return canon(irmem);\n        if (n_ instanceof IRMove irmove) return canon(irmove);\n        if (n_ instanceof IRName irname) return canon(irname);\n        if (n_ instanceof IRReturn irret) return canon(irret);\n        if (n_ instanceof IRSeq irseq) return canon(irseq);\n        if (n_ instanceof IRTemp irtem) return canon(irtem);\n\n        throw new Error(\"Why is node not found\");\n    }\n\n    private boolean hasNoUnmarkedPredecessors(BasicBlock block) {\n        block.visited = true;\n\n        boolean noUnmarkedPredecessor = true;\n\n        for (BasicBlock pred : block.predecessors) {\n            if (!pred.visited) {\n                if (pred.marked) {\n                    noUnmarkedPredecessor &= hasNoUnmarkedPredecessors(pred);\n                } else {\n                    return false;\n                }\n            }\n        }\n\n        block.visited = false;\n\n        return noUnmarkedPredecessor;\n    }\n\n    private BasicBlock selectBlock() {\n        boolean allMarked = true;\n        BasicBlock best = null;\n        for (BasicBlock block : blocks) {\n            if (hasNoUnmarkedPredecessors(block)) {\n                return block;\n            }\n            if (!block.marked){\n                best = block;\n                allMarked = false;\n            }\n        }\n        if (allMarked){\n            return null;\n        }else{\n            return best;\n        }\n    }\n\n    private boolean greedyReordering() {\n        BasicBlock blk = selectBlock();\n\n        if (blk == null) {\n            return true;\n        }\n\n        while (!blk.marked) {\n            blk.marked = true;\n            orderedBlocks.add(blk);\n            boolean found = false;\n            for (BasicBlock neighbor : blk.neighbors) {\n                if (!neighbor.marked) {\n                    blk = neighbor;\n                    found = true;\n                    break;\n                }\n            }\n            if (!found){\n                break;\n            }\n        }\n\n        return false;\n    }\n\n    private void reorderBlocks(){\n\n        orderedBlocks = new ArrayList<>();\n        while (!greedyReordering()){\n\n        }\n    }\n\n    private ArrayList<BasicBlock> createBasicBlocks(IRSeq body){\n        ArrayList<BasicBlock> blocks = new ArrayList<>();\n        // loop through each stmt\n\n        // add to current block if not jump / cjump / return\n\n        // if jump/cjump/return stop block push then create new block\n        // a block is just a list of Stmts\n        // if anything left at the end then add to blocks too\n\n    }\n    // Lower each statment then flatten all sequences\n    private IRNode canon(IRSeq node) {\n//        System.out.println(node);\n        ArrayList<IRStmt> flatten = new ArrayList<>();\n        for (IRStmt stmt: node.stmts()){\n            if (stmt instanceof IRSeq seq){\n//                System.out.println(\"start\");\n//                System.out.println(node);\n//                System.out.println(seq);\n                flatten.addAll(seq.stmts());\n            }else{\n                flatten.add(stmt);\n            }\n        }\n        return new IRSeq(flatten);\n    }\n\n    // Lower each return expressions then add Return\n    private IRNode canon(IRReturn node) {\n        ArrayList<IRStmt> stmts = new ArrayList<>();\n        ArrayList<String> temps_strs = new ArrayList<>();\n\n        for (IRExpr expr : node.rets()) {\n            String ti = nxtTemp();\n            temps_strs.add(ti);\n            if (expr instanceof IRESeq eseq) {\n                if (eseq.stmt() instanceof IRSeq seq){\n                    stmts.addAll(seq.stmts());\n                }else{\n                    stmts.add(eseq.stmt());\n                }\n                stmts.add(new IRMove(new IRTemp(ti),eseq.expr()));\n            }else{\n                stmts.add(new IRMove(new IRTemp(ti),expr));\n            }\n        }\n        List<IRExpr> temps = new ArrayList<>();\n        for (String tmp : temps_strs) {\n            temps.add(new IRTemp(tmp));\n        }\n\n        stmts.add(new IRReturn(temps));\n        return new IRSeq(stmts);\n    }\n\n    // Lower Move be very careful look at slides\n    private IRNode canon(IRMove node) {\n        IRExpr target = node.target();\n        IRExpr source = node.source();\n//\n        if (target instanceof IRMem mem){\n            return moveCommute(node) ? moveNaive(mem,source) : moveGeneral(mem,source);\n        }\n        return easyMove(node);\n    }\n\n    private IRNode easyMove(IRMove node){\n        ArrayList<IRStmt> stmts = new ArrayList<>();\n        IRExpr targ = node.target();\n        IRExpr source = node.source();\n        if (node.target() instanceof IRESeq ires1){\n            if (ires1.stmt() instanceof IRSeq seq){\n                stmts.addAll(seq.stmts());\n            }else{\n                stmts.add(ires1.stmt());\n            }\n            targ = ires1.expr();\n        }\n        if (node.source() instanceof IRESeq ires){\n            if (ires.stmt() instanceof IRSeq seq2){\n                stmts.addAll(seq2.stmts());\n            }else{\n                stmts.add(ires.stmt());\n            }\n            source = ires.expr();\n        }\n        if (stmts.size() != 0){\n            stmts.add(new IRMove(targ,source));\n            return new IRSeq(stmts);\n        }\n        return node;\n    }\n    // to do\n    private boolean moveCommute(IRMove node){\n        return false;\n    }\n    private IRStmt moveNaive(IRMem targ, IRExpr src){\n        ArrayList<IRStmt> stmts = new ArrayList<>();\n        IRExpr e1 = targ.expr();\n        IRExpr e2 = src;\n        if (targ.expr() instanceof IRESeq ires){\n            if (ires.stmt() instanceof IRSeq seq){\n                stmts.addAll(seq.stmts());\n            }else{\n                stmts.add(ires.stmt());\n            }\n            e1 = ires.expr();\n        }\n        if (src instanceof  IRESeq ires2){\n            if (ires2.stmt() instanceof IRSeq seq1){\n                stmts.addAll(seq1.stmts());\n            }else{\n                stmts.add(ires2.stmt());\n            }\n            e2 = ires2.expr();\n        }\n        if (stmts.size() != 0){\n            stmts.add(new IRMove(new IRMem(e1),e2));\n            return new IRSeq(stmts);\n        }\n        return new IRMove(targ,src);\n    }\n\n    private IRStmt moveGeneral(IRMem targ, IRExpr src){\n        ArrayList<IRStmt> stmts = new ArrayList<>();\n        IRExpr e1 = targ.expr();\n        IRExpr e2 = src;\n        if (targ.expr() instanceof IRESeq ires){\n            if (ires.stmt() instanceof IRSeq seq){\n                stmts.addAll(seq.stmts());\n            }else{\n                stmts.add(ires.stmt());\n            }\n            e1 = ires.expr();\n        }\n        String t = nxtTemp();\n        stmts.add(new IRMove(new IRTemp(t),e1));\n        if (src instanceof  IRESeq ires2){\n            if (ires2.stmt() instanceof IRSeq seq1){\n                stmts.addAll(seq1.stmts());\n            }else{\n                stmts.add(ires2.stmt());\n            }\n            e2 = ires2.expr();\n        }\n        stmts.add(new IRMove(new IRMem(new IRTemp(t)),e2));\n        return new IRSeq(stmts);\n    }\n\n    // Create Basic Blocks And reorder all the body\n    private IRNode canon(IRFuncDecl node) {\n//        if (node.name().equals(\"_IAck_iii\")) {\n//            System.out.println(node.body());\n//        }\n        return node;\n    }\n\n\n    // Lift Statement that is it\n    private IRNode canon(IRExp node) {\n        if (node.expr() instanceof IRESeq ire) {\n            if (ire.stmt() instanceof IRSeq seq){\n                return new IRSeq(seq.stmts());\n            }else{\n                return ire.stmt();\n            }\n        }\n        return new IRSeq();\n    }\n\n    // do nothing\n    private IRNode canon(IRCompUnit node) {\n        return node;\n    }\n\n    // Lower each Expr\n    private IRNode canon(IRCallStmt node) {\n        ArrayList<IRStmt> stmts = new ArrayList<>();\n        ArrayList<String> temps_strs = new ArrayList<>();\n\n        for (IRExpr expr : node.args()) {\n            String ti = nxtTemp();\n            temps_strs.add(ti);\n            if (expr instanceof IRESeq eseq) {\n                if (eseq.stmt() instanceof IRSeq seq){\n                    stmts.addAll(seq.stmts());\n                }else{\n                    stmts.add(eseq.stmt());\n                }\n                stmts.add(new IRMove(new IRTemp(ti),eseq.expr()));\n            }else{\n                stmts.add(new IRMove(new IRTemp(ti),expr));\n            }\n        }\n\n        List<IRExpr> temps = new ArrayList<>();\n        for (String tmp : temps_strs) {\n            temps.add(new IRTemp(tmp));\n        }\n\n        stmts.add(new IRCallStmt(node.target(), node.n_returns(), temps));\n//        stmts.add(new IRMove(new IRTemp(t), new IRTemp(\"_RV1\")));\n//        System.out.println(new IRSeq(stmts));\n\n        return new IRSeq(stmts);\n    }\n    // Lower each Expr we never call this lol?\n    private IRNode canon(IRCall node) {\n        return node;\n    }\n\n    // if commute do that otherwise do normal\n    private IRNode canon(IRBinOp node) {\n        return doesBinopCommunte(node) ? commuteBinop(node) : defaultBinop(node);\n    }\n\n    // to do\n    private boolean doesBinopCommunte(IRBinOp node){\n        return false;\n    }\n\n    private IRNode commuteBinop(IRBinOp node){\n        ArrayList<IRStmt> hoisted = new ArrayList<>();\n        IRExpr e1 = node.left();\n        IRExpr e2 = node.right();\n        if (node.left() instanceof IRESeq ires1){\n            if (ires1.stmt() instanceof IRSeq seq){\n                hoisted.addAll(seq.stmts());\n            }else{\n                hoisted.add(ires1.stmt());\n            }\n            e1 = ires1.expr();\n        }\n        if (node.right() instanceof  IRESeq ires2){\n            if (ires2.stmt() instanceof IRSeq seq2){\n                hoisted.addAll(seq2.stmts());\n            }else{\n                hoisted.add(ires2.stmt());\n            }\n            e2 = ires2.expr();\n        }\n        if (hoisted.size() != 0){\n            return new IRESeq(new IRSeq(hoisted),new IRBinOp(node.opType(),e1,e2));\n        }\n        return node;\n    }\n    private IRNode defaultBinop(IRBinOp node){\n        ArrayList<IRStmt> stmts = new ArrayList<>();\n        String t1 = nxtTemp();\n        IRExpr e2 = node.right();\n        if (node.left() instanceof IRESeq ires1){\n            if (ires1.stmt() instanceof IRSeq seq){\n                stmts.addAll(seq.stmts());\n            }else{\n                stmts.add(ires1.stmt());\n            }\n            stmts.add(new IRMove(new IRTemp(t1), ires1.expr()));\n        }else{\n            stmts.add(new IRMove(new IRTemp(t1), node.left()));\n        }\n\n        if (node.right() instanceof IRESeq ires2){\n            if (ires2.stmt() instanceof IRSeq seq2){\n                stmts.addAll(seq2.stmts());\n            }else{\n                stmts.add(ires2.stmt());\n            }\n            e2 = ires2.expr();\n        }\n//        System.out.println(new IRSeq(stmts));\n        return new IRESeq(new IRSeq(stmts),\n                new IRBinOp(node.opType(),new IRTemp(t1),e2));\n    }\n\n    // canonical\n    private IRNode canon(IRConst node){\n        return node;\n    }\n    // canonical\n    private IRNode canon(IRLabel node){\n        return node;\n    }\n    // canonical\n    private IRNode canon(IRName node){\n        return node;\n    }\n    // canonical\n    private IRNode canon(IRTemp node) {\n        return node;\n    }\n    // MEM\n    private IRNode canon(IRMem node){\n        if (node.expr() instanceof IRESeq ireseq) { // lift expression\n            IRStmt svec = ireseq.stmt();\n            IRExpr ire = ireseq.expr();\n            return new IRESeq(svec, new IRMem(ire));\n        }\n        return node;\n    }\n    // Conditional Jump\n    private IRNode canon(IRCJump node){\n        if (node.cond() instanceof IRESeq ireseq) {\n            ArrayList<IRStmt> stmts = new ArrayList<>();\n            if (ireseq.stmt() instanceof IRSeq seq){\n                stmts.addAll(seq.stmts());\n            }else{\n                stmts.add(ireseq.stmt());\n            }\n            IRExpr ire = ireseq.expr();\n            stmts.add(new IRCJump(ire, node.trueLabel(), node.falseLabel()));\n            return new IRSeq(stmts);\n        }\n        return node;\n    }\n    // Jump\n    private IRNode canon(IRJump node){\n        if (node.target() instanceof IRESeq ireseq) {\n            ArrayList<IRStmt> stmts = new ArrayList<>();\n            if (ireseq.stmt() instanceof IRSeq seq){\n                stmts.addAll(seq.stmts());\n            }else{\n                stmts.add(ireseq.stmt());\n            }\n            IRExpr ire = ireseq.expr();\n            stmts.add(new IRJump(ire));\n            return new IRSeq(stmts);\n        }\n        return node;\n    }\n    // ESEQ\n    private IRNode canon(IRESeq node){\n        if (node.expr() instanceof IRESeq ireseq) {\n            IRExpr ire = ireseq.expr();\n            ArrayList<IRStmt> stmts = new ArrayList<>();\n            if (node.stmt() instanceof  IRSeq seqNode){\n                stmts.addAll(seqNode.stmts());\n            }else{\n                stmts.add(node.stmt());\n            }\n            if (ireseq.stmt() instanceof IRSeq seq){\n                stmts.addAll(seq.stmts());\n            }else{\n                stmts.add(ireseq.stmt());\n            }\n            return new IRESeq(new IRSeq(stmts), ire);\n        }\n        return node;\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/aar226_akc55_ayc62_ahl88/src/edu/cornell/cs/cs4120/xic/ir/visit/IRLoweringVisitor.java b/src/main/java/aar226_akc55_ayc62_ahl88/src/edu/cornell/cs/cs4120/xic/ir/visit/IRLoweringVisitor.java
--- a/src/main/java/aar226_akc55_ayc62_ahl88/src/edu/cornell/cs/cs4120/xic/ir/visit/IRLoweringVisitor.java	(revision 3499b9699c803e2872915ce5573934736aa8c472)
+++ b/src/main/java/aar226_akc55_ayc62_ahl88/src/edu/cornell/cs/cs4120/xic/ir/visit/IRLoweringVisitor.java	(date 1678655431051)
@@ -1,11 +1,10 @@
 package aar226_akc55_ayc62_ahl88.src.edu.cornell.cs.cs4120.xic.ir.visit;
 
 import aar226_akc55_ayc62_ahl88.newast.stmt.Block;
-import aar226_akc55_ayc62_ahl88.newast.stmt.Stmt;
 import aar226_akc55_ayc62_ahl88.src.edu.cornell.cs.cs4120.xic.ir.*;
+import aar226_akc55_ayc62_ahl88.src.polyglot.util.InternalCompilerError;
 
 import java.util.*;
-import java.util.stream.Collectors;
 
 // Need to think about what to add
 class BasicBlock {
@@ -14,12 +13,24 @@
     public boolean visited;
 
     public ArrayList<BasicBlock> predecessors;
-    public ArrayList<BasicBlock> neighbors;
+    public ArrayList<BasicBlock> successors;
+    public ArrayList<IRStmt> statements;
+
+    public ArrayList<String> destLabels; // we contain this
+
+    public ArrayList<String> originLabels; // we want to go there
+
+
 
     public BasicBlock() {
         id++;
         marked = false;
         visited = false;
+        predecessors = new ArrayList<>();
+        successors = new ArrayList<>();
+        statements = new ArrayList<>();
+        destLabels = new ArrayList<>();
+        originLabels = new ArrayList<>();
     }
 }
 
@@ -33,7 +44,7 @@
     private ArrayList<BasicBlock> orderedBlocks;
 
     private String nxtLabel() {
-        return String.format("l%d", (labelCnt++));
+        return String.format("lb%d", (labelCnt++));
     }
 
     private String nxtTemp() {
@@ -118,7 +129,7 @@
             blk.marked = true;
             orderedBlocks.add(blk);
             boolean found = false;
-            for (BasicBlock neighbor : blk.neighbors) {
+            for (BasicBlock neighbor : blk.successors) {
                 if (!neighbor.marked) {
                     blk = neighbor;
                     found = true;
@@ -141,16 +152,58 @@
         }
     }
 
-    private ArrayList<BasicBlock> createBasicBlocks(IRSeq body){
+    private boolean stop(IRStmt stmt){
+        return (stmt instanceof IRJump || stmt instanceof IRCJump || stmt instanceof IRReturn);
+    }
+
+    private void compareBlocks(BasicBlock block1, BasicBlock block2){
+        for (String originLabel : block1.originLabels) {
+            for (String destLabel : block2.destLabels) {
+                if (originLabel.equals(destLabel)) {
+                    block1.successors.add(block2);
+                    block2.predecessors.add(block1);
+                }
+            }
+        }
+    }
+
+    private ArrayList<BasicBlock> createBasicBlocksAndGraph(IRSeq body){
         ArrayList<BasicBlock> blocks = new ArrayList<>();
+
         // loop through each stmt
+        BasicBlock curBlock = new BasicBlock();
+        for (IRStmt stmt: body.stmts()){
+            curBlock.statements.add(stmt);
+            if (stop(stmt)) {
+                if (stmt instanceof IRJump jmp) {
+                    String destName = ((IRName) jmp.target()).name();
+                    curBlock.originLabels.add(destName);
+                }
+                else if (stmt instanceof IRCJump cjmp) {
+                    curBlock.originLabels.add(cjmp.trueLabel());
+                    curBlock.originLabels.add(cjmp.falseLabel());
+                }
 
-        // add to current block if not jump / cjump / return
+                blocks.add(curBlock);
+                curBlock = new BasicBlock();
+            }
+            if (stmt instanceof IRLabel label) {
+                curBlock.destLabels.add(label.name());
+            }
+        }
+        if (curBlock.statements.size() != 0) {
+            blocks.add(curBlock);
+        }
 
-        // if jump/cjump/return stop block push then create new block
-        // a block is just a list of Stmts
-        // if anything left at the end then add to blocks too
+        for (int i = 0; i < blocks.size(); i++) {
+            for (int j = i + 1; j < blocks.size(); j++) {
+                BasicBlock bi = blocks.get(i), bj = blocks.get(j);
+                compareBlocks(bi, bj);
+                compareBlocks(bj, bi);
+            }
+        }
 
+        return blocks;
     }
     // Lower each statment then flatten all sequences
     private IRNode canon(IRSeq node) {
@@ -296,6 +349,12 @@
 //        if (node.name().equals("_IAck_iii")) {
 //            System.out.println(node.body());
 //        }
+        if (node.body() instanceof IRSeq irs){
+            createBasicBlocksAndGraph(irs);
+        }else{
+            throw new InternalCompilerError("METHOD BODY NOT SEQ");
+        }
+
         return node;
     }
 
