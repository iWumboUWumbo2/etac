Index: src/main/java/aar226_akc55_ayc62_ahl88/src/edu/cornell/cs/cs4120/xic/ir/visit/IRLoweringVisitor.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package aar226_akc55_ayc62_ahl88.src.edu.cornell.cs.cs4120.xic.ir.visit;\n\nimport aar226_akc55_ayc62_ahl88.newast.stmt.Stmt;\nimport aar226_akc55_ayc62_ahl88.src.edu.cornell.cs.cs4120.xic.ir.*;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\npublic class IRLoweringVisitor extends IRVisitor {\n    private static final int WORD_BYTES = 8;\n    private static final String OUT_OF_BOUNDS = \"_xi_out_of_bounds\";\n    private int labelCnt;\n    private int tempCnt;\n    private String nxtLabel() {\n        return String.format(\"l%d\", (labelCnt++));\n    }\n\n    private String nxtTemp() {\n        return String.format(\"tl%d\", (tempCnt++));\n    }\n    public IRLoweringVisitor (IRNodeFactory inf) {\n        super(inf);\n        labelCnt = 0;\n        tempCnt = 0;\n    }\n\n    private class BasicBlock {} // Need to think about what to add\n\n    @Override\n    protected IRNode leave(IRNode parent, IRNode n, IRNode n_, IRVisitor v_) {\n        if (n_ instanceof IRBinOp irbin) return canon(irbin);\n        if (n_ instanceof IRCall irc) return canon(irc);\n        if (n_ instanceof IRCallStmt ircstmt) return canon(ircstmt);\n        if (n_ instanceof IRCJump ircj) return canon(ircj);\n        if (n_ instanceof IRCompUnit icu) return canon(icu);\n        if (n_ instanceof IRConst ic) return canon(ic);\n        if (n_ instanceof IRESeq ireseq) return canon(ireseq);\n        if (n_ instanceof IRExp irexp) return  canon(irexp);\n        if (n_ instanceof IRFuncDecl irfunc) return canon(irfunc);\n        if (n_ instanceof IRJump irj) return canon(irj);\n        if (n_ instanceof IRLabel irl) return canon(irl);\n        if (n_ instanceof IRMem irmem) return canon(irmem);\n        if (n_ instanceof IRMove irmove) return canon(irmove);\n        if (n_ instanceof IRName irname) return canon(irname);\n        if (n_ instanceof IRReturn irret) return canon(irret);\n        if (n_ instanceof IRSeq irseq) return canon(irseq);\n        if (n_ instanceof IRTemp irtem) return canon(irtem);\n\n        throw new Error(\"Why is node not found\");\n    }\n\n\n    // Lower each statment then flatten all sequences\n    private IRNode canon(IRSeq node) {\n//        System.out.println(node);\n        ArrayList<IRStmt> flatten = new ArrayList<>();\n        for (IRStmt stmt: node.stmts()){\n            if (stmt instanceof IRSeq seq){\n//                System.out.println(\"start\");\n//                System.out.println(node);\n//                System.out.println(seq);\n                flatten.addAll(seq.stmts());\n            }else{\n                flatten.add(stmt);\n            }\n        }\n        return new IRSeq(flatten);\n    }\n\n    // Lower each return expressions then add Return\n    private IRNode canon(IRReturn node) {\n        ArrayList<IRStmt> stmts = new ArrayList<>();\n        ArrayList<String> temps_strs = new ArrayList<>();\n\n        for (IRExpr expr : node.rets()) {\n            String ti = nxtTemp();\n            temps_strs.add(ti);\n            if (expr instanceof IRESeq eseq) {\n                stmts.add(eseq.stmt());\n                stmts.add(new IRMove(new IRTemp(ti),eseq.expr()));\n            }else{\n                stmts.add(new IRMove(new IRTemp(ti),expr));\n            }\n        }\n        List<IRExpr> temps = new ArrayList<>();\n        for (String tmp : temps_strs) {\n            temps.add(new IRTemp(tmp));\n        }\n\n        stmts.add(new IRReturn(temps));\n        return new IRSeq(stmts);\n    }\n\n    // Lower Move be very careful look at slides\n    private IRNode canon(IRMove node) {\n        IRExpr target = node.target();\n        IRExpr source = node.source();\n//\n        if (target instanceof IRTemp){\n            return tempMove(node);\n        }else if (target instanceof IRMem mem){\n            return moveCommute(node) ? moveNaive(mem,source) : moveGeneral(mem,source);\n        }\n\n        return node;\n    }\n\n    private IRNode tempMove(IRMove node){\n        if (node.source() instanceof IRESeq ires){\n            return new IRSeq(ires.stmt(),new IRMove(node.target(),ires.expr()));\n        }\n        return node;\n    }\n    // to do\n    private boolean moveCommute(IRMove node){\n        return false;\n    }\n    private IRStmt moveNaive(IRMem targ, IRExpr src){\n        ArrayList<IRStmt> stmts = new ArrayList<>();\n        IRExpr e1 = targ.expr();\n        IRExpr e2 = src;\n        if (targ.expr() instanceof IRESeq ires){\n            stmts.add(ires.stmt());\n            e1 = ires.expr();\n        }\n        if (src instanceof  IRESeq ires2){\n            stmts.add(ires2.stmt());\n            e2 = ires2.expr();\n        }\n        if (stmts.size() != 0){\n            stmts.add(new IRMove(new IRMem(e1),e2));\n            return new IRSeq(stmts);\n        }\n        return new IRMove(targ,src);\n    }\n\n    private IRStmt moveGeneral(IRMem targ, IRExpr src){\n        ArrayList<IRStmt> stmts = new ArrayList<>();\n        IRExpr e1 = targ.expr();\n        IRExpr e2 = src;\n        if (targ.expr() instanceof IRESeq ires){\n            stmts.add(ires.stmt());\n            e1 = ires.expr();\n        }\n        String t = nxtTemp();\n        stmts.add(new IRMove(new IRTemp(t),e1));\n        if (src instanceof  IRESeq ires2){\n            stmts.add(ires2.stmt());\n            e2 = ires2.expr();\n        }\n        stmts.add(new IRMove(new IRMem(new IRTemp(t)),e2));\n        return new IRSeq(stmts);\n    }\n\n    // Create Basic Blocks And reorder all the body\n    private IRNode canon(IRFuncDecl node) {\n//        if (node.name().equals(\"_IAck_iii\")) {\n//            System.out.println(node.body());\n//        }\n        return node;\n    }\n\n\n    // Lift Statement that is it\n    private IRNode canon(IRExp node) {\n        if (node.expr() instanceof IRESeq ire) {\n            return ire.stmt();\n        }\n        return new IRSeq();\n    }\n\n    // do nothing\n    private IRNode canon(IRCompUnit node) {\n        return node;\n    }\n\n    // Lower each Expr\n    private IRNode canon(IRCallStmt node) {\n        ArrayList<IRStmt> stmts = new ArrayList<>();\n        ArrayList<String> temps_strs = new ArrayList<>();\n\n        for (IRExpr expr : node.args()) {\n            String ti = nxtTemp();\n            temps_strs.add(ti);\n            if (expr instanceof IRESeq eseq) {\n                stmts.add(eseq.stmt());\n                stmts.add(new IRMove(new IRTemp(ti),eseq.expr()));\n            }else{\n                stmts.add(new IRMove(new IRTemp(ti),expr));\n            }\n        }\n\n        List<IRExpr> temps = new ArrayList<>();\n        for (String tmp : temps_strs) {\n            temps.add(new IRTemp(tmp));\n        }\n\n        stmts.add(new IRCallStmt(node.target(), node.n_returns(), temps));\n//        stmts.add(new IRMove(new IRTemp(t), new IRTemp(\"_RV1\")));\n//        System.out.println(new IRSeq(stmts));\n        return new IRSeq(stmts);\n    }\n    // Lower each Expr we never call this lol?\n    private IRNode canon(IRCall node) {\n        return node;\n    }\n\n    // if commute do that otherwise do normal\n    private IRNode canon(IRBinOp node) {\n        return doesBinopCommunte(node) ? commuteBinop(node) : defaultBinop(node);\n    }\n\n    // to do\n    private boolean doesBinopCommunte(IRBinOp node){\n        return false;\n    }\n\n    private IRNode commuteBinop(IRBinOp node){\n        ArrayList<IRStmt> hoisted = new ArrayList<>();\n        IRExpr e1 = node.left();\n        IRExpr e2 = node.right();\n        if (node.left() instanceof IRESeq ires1){\n            hoisted.add(ires1.stmt());\n            e1 = ires1.expr();\n        }\n        if (node.right() instanceof  IRESeq ires2){\n            hoisted.add(ires2.stmt());\n            e2 = ires2.expr();\n        }\n        if (hoisted.size() != 0){\n            return new IRESeq(new IRSeq(hoisted),new IRBinOp(node.opType(),e1,e2));\n        }\n        return node;\n    }\n    private IRNode defaultBinop(IRBinOp node){\n        ArrayList<IRStmt> stmts = new ArrayList<>();\n        String t1 = nxtTemp();\n        if (node.left() instanceof IRESeq ires1){\n            stmts.add(ires1.stmt());\n            stmts.add(new IRMove(new IRTemp(t1), ires1.expr()));\n        }else{\n            stmts.add(new IRMove(new IRTemp(t1), node.left()));\n        }\n        if (node.right() instanceof IRESeq ires2){\n            stmts.add(ires2.stmt());\n            return new IRESeq(new IRSeq(stmts),new IRBinOp(node.opType(),new IRTemp(t1),ires2.expr()));\n        }else{\n            \n        }\n        return node;\n    }\n\n    // canonical\n    private IRNode canon(IRConst node){\n        return node;\n    }\n    // canonical\n    private IRNode canon(IRLabel node){\n        return node;\n    }\n    // canonical\n    private IRNode canon(IRName node){\n        return node;\n    }\n    // canonical\n    private IRNode canon(IRTemp node) {\n        return node;\n    }\n    // MEM\n    private IRNode canon(IRMem node){\n        if (node.expr() instanceof IRESeq ireseq) { // lift expression\n            IRStmt svec = ireseq.stmt();\n            IRExpr ire = ireseq.expr();\n            return new IRESeq(svec, new IRMem(ire));\n        }\n        return node;\n    }\n    // Conditional Jump\n    private IRNode canon(IRCJump node){\n        if (node.cond() instanceof IRESeq ireseq) {\n            IRStmt svec = ireseq.stmt();\n            IRExpr ire = ireseq.expr();\n            return new IRSeq(svec, new IRCJump(ire, node.trueLabel(), node.falseLabel()));\n        }\n        return node;\n    }\n    // Jump\n    private IRNode canon(IRJump node){\n        if (node.target() instanceof IRESeq ireseq) {\n            IRStmt svec = ireseq.stmt();\n            IRExpr ire = ireseq.expr();\n            return new IRSeq(svec, new IRJump(ire));\n        }\n        return node;\n    }\n    // ESEQ\n    private IRNode canon(IRESeq node){\n        if (node.expr() instanceof IRESeq ireseq) {\n            IRStmt svec = ireseq.stmt();\n            IRExpr ire = ireseq.expr();\n            return new IRESeq(new IRSeq(node.stmt(), svec), ire);\n        }\n        return node;\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/aar226_akc55_ayc62_ahl88/src/edu/cornell/cs/cs4120/xic/ir/visit/IRLoweringVisitor.java b/src/main/java/aar226_akc55_ayc62_ahl88/src/edu/cornell/cs/cs4120/xic/ir/visit/IRLoweringVisitor.java
--- a/src/main/java/aar226_akc55_ayc62_ahl88/src/edu/cornell/cs/cs4120/xic/ir/visit/IRLoweringVisitor.java	(revision b1075ede668d50c2c31e135676f0a5424ad8c1aa)
+++ b/src/main/java/aar226_akc55_ayc62_ahl88/src/edu/cornell/cs/cs4120/xic/ir/visit/IRLoweringVisitor.java	(date 1678640731157)
@@ -198,7 +198,7 @@
 
         stmts.add(new IRCallStmt(node.target(), node.n_returns(), temps));
 //        stmts.add(new IRMove(new IRTemp(t), new IRTemp("_RV1")));
-//        System.out.println(new IRSeq(stmts));
+        System.out.println(new IRSeq(stmts));
         return new IRSeq(stmts);
     }
     // Lower each Expr we never call this lol?
Index: src/main/java/aar226_akc55_ayc62_ahl88/Main.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package aar226_akc55_ayc62_ahl88;\n\nimport aar226_akc55_ayc62_ahl88.Errors.EtaError;\nimport aar226_akc55_ayc62_ahl88.SymbolTable.SymbolTable;\nimport aar226_akc55_ayc62_ahl88.newast.AstNode;\nimport aar226_akc55_ayc62_ahl88.newast.Program;\nimport aar226_akc55_ayc62_ahl88.newast.Type;\nimport aar226_akc55_ayc62_ahl88.newast.interfaceNodes.EtiInterface;\nimport aar226_akc55_ayc62_ahl88.src.edu.cornell.cs.cs4120.xic.ir.IRCompUnit;\nimport aar226_akc55_ayc62_ahl88.src.edu.cornell.cs.cs4120.xic.ir.IRConst;\nimport aar226_akc55_ayc62_ahl88.src.edu.cornell.cs.cs4120.xic.ir.IRNode;\nimport aar226_akc55_ayc62_ahl88.src.edu.cornell.cs.cs4120.xic.ir.IRNodeFactory_c;\nimport aar226_akc55_ayc62_ahl88.src.edu.cornell.cs.cs4120.xic.ir.interpret.IRSimulator;\nimport aar226_akc55_ayc62_ahl88.src.edu.cornell.cs.cs4120.xic.ir.visit.IRLoweringVisitor;\nimport aar226_akc55_ayc62_ahl88.visitors.IRVisitor;\nimport java_cup.runtime.Symbol;\nimport java_cup.runtime.lr_parser;\nimport org.apache.commons.cli.*;\nimport java.io.*;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\n\nimport aar226_akc55_ayc62_ahl88.src.edu.cornell.cs.cs4120.util.CodeWriterSExpPrinter;\n\npublic class Main {\n    private static String outputDirectory;\n    private static String inputDirectory;\n    public static String libpathDirectory;\n\n    private static boolean isOutputDirSpecified;\n    private static boolean isInputDirSpecified;\n    public static boolean isLibpathDirSpecified;\n\n    public static Optimizations opts;\n\n    // Write the lexed string into the corresponding file name\n    private static void writeOutput(String filename, String output, String extension) {\n        Path path = (isOutputDirSpecified)\n                        ? Paths.get(outputDirectory, filename)\n                        : Paths.get(filename);\n\n        String pathname = path.toString();\n        pathname = pathname.substring(0, pathname.length() - 3) + extension;\n//        System.out.println(pathname);\n        Path parentPath = path.getParent();\n        String dirname = (parentPath == null) ? \"\" : parentPath.toString();\n//        System.out.println(dirname);\n        // Create directory\n        File dir = new File(dirname);\n        dir.mkdirs();\n\n        // Create file\n        try {\n            File file = new File(pathname);\n            file.createNewFile();\n        }\n        catch (IOException e) {\n            System.out.println(\"An error occurred when creating the file \" + filename);\n            return;\n        }\n\n        // Write to file\n        try {\n            FileWriter myWriter = new FileWriter(pathname);\n\n            myWriter.write(output);\n            myWriter.close();\n        }\n        catch (IOException e) {\n            System.out.println(\"An error occurred when writing to the file \" + filename);\n        }\n    }\n\n    private static String prettyOut(Symbol s){\n        String out = s.value().toString();\n        switch (s.sym){\n            case (sym.INTEGER_LITERAL):\n                if (out.length() > 1){\n                    out = out.substring(1);\n                }\n                out = \"integer \" + out;\n                break;\n            case (sym.BOOL_LITERAL):\n                out = \"boolean \" + out;\n                break;\n            case (sym.IDENTIFIER):\n                out = \"id \" +  out;\n                break;\n            case (sym.CHARACTER_LITERAL):\n                out = \"character \" +  out;\n                break;\n            case (sym.STRING_LITERAL):\n                out = \"string \" + out;\n                break;\n            default:\n                break;\n        }\n        return String.format(\"%d:%d %s\\n\", s.left, s.right, out);\n    }\n\n    private static String getZhenFilename(String filename) {\n        return (isInputDirSpecified)\n                ? Paths.get(inputDirectory, filename).toString()\n                : filename;\n    }\n\n    private static void lexFile(String filename, StringBuilder lexedOutput, boolean shouldWrite) throws IOException {\n        try {\n            if (filename.endsWith(\".eta\") || filename.endsWith(\".eti\")) {\n                String zhenFilename = getZhenFilename(filename);\n\n                Lexer etaLexer;\n                try {\n                    etaLexer = new Lexer(new FileReader(zhenFilename));\n                } catch (Exception e) {\n                    System.out.println(\"File without name \" + filename + \" found\");\n                    return;\n                }\n\n                try {\n                    while (true) {\n                        Symbol t = etaLexer.next_token();\n                        if (t.sym == sym.EOF) break;\n                        String lexed = prettyOut(t);\n                        lexedOutput.append(lexed);\n                    }\n                }\n                catch (EtaError e) {\n                    lexedOutput.append(e.getMessage());\n                }\n            }\n            else {\n                throw new FileNotFoundException(\n                        \"Invalid filename \"\n                                + filename\n                                + \" provided: All files passed to etac must have a .eta extension\");\n            }\n        }\n        catch (FileNotFoundException invalidFilename) {\n            System.out.println(invalidFilename.getMessage());\n            return;\n        }\n\n        if (shouldWrite) {\n            writeOutput(filename, lexedOutput.toString(), \"lexed\");\n        }\n    }\n\n    private static void parseFile(String filename, boolean shouldWrite) throws IOException {\n        try {\n            String zhenFilename = getZhenFilename(filename);\n\n            Lexer lex;\n            try {\n                lex = new Lexer(new FileReader(zhenFilename));\n            } catch (Exception e) {\n                System.out.println(\"File without name \" + filename + \" found\");\n                return;\n            }\n\n            lr_parser p = null;\n            if (filename.endsWith(\".eta\")) p = new EtaParser(lex);\n            else if (filename.endsWith(\".eti\")) p = new EtiParser(lex);\n            else throw new FileNotFoundException(\n                        \"Invalid filename \"\n                                + filename\n                                + \" provided: All files passed to etac must have a .eta extension\");\n\n            try {\n                StringWriter out = new StringWriter();\n                PrintWriter cw = new PrintWriter(out);\n                CodeWriterSExpPrinter printer = new CodeWriterSExpPrinter(cw);\n\n                if (filename.endsWith(\".eta\")) {\n                    Program result = (Program) p.parse().value;\n                    result.prettyPrint(printer);\n                }\n                else if (filename.endsWith(\".eti\")) {\n                    EtiInterface result = (EtiInterface) p.parse().value;\n                    result.prettyPrint(printer);\n                }\n\n                printer.close();\n                if (shouldWrite) {\n                    writeOutput(filename, out.toString(), \"parsed\");\n                }\n            } catch (EtaError e) {\n                if (shouldWrite) {\n                    writeOutput(filename, e.getMessage(), \"parsed\");\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n                System.out.println(\"File without name \" + filename + \" found\");\n            }\n        }\n        catch (FileNotFoundException invalidFilename) {\n            System.out.println(invalidFilename.getMessage());\n        }\n    }\n\n    private static void typeCheckFile(String filename, boolean shouldWrite) throws IOException {\n        try {\n            String zhenFilename = getZhenFilename(filename);\n\n            Lexer lex = null;\n            try {\n                lex = new Lexer(new FileReader(zhenFilename));\n            } catch (Exception e) {\n                System.out.println(\"No file found with filename \" + filename);\n                return;\n            }\n\n            lr_parser p;\n            if (filename.endsWith(\".eta\")) p = new EtaParser(lex);\n            else if (filename.endsWith(\".eti\")) p = new EtiParser(lex);\n            else throw new FileNotFoundException(\n                        \"Invalid filename \"\n                                + filename\n                                + \" provided: All files passed to etac must have a .eta extension\");\n\n            try {\n                if (filename.endsWith(\".eta\")) {\n                    Program result = (Program) p.parse().value;\n                    result.typeCheck(new SymbolTable<>(), zhenFilename);\n                } else if (filename.endsWith(\".eti\")) {\n                    EtiInterface result = (EtiInterface) p.parse().value;\n                    result.firstPass(); // Just to throw EtaErrors\n                }\n\n                if (shouldWrite) {\n                    writeOutput(filename, \"Valid Eta Program\", \"typed\");\n                }\n            } catch (EtaError e) {\n                e.printError(zhenFilename);\n                if (shouldWrite) {\n                    writeOutput(filename, e.getMessage(), \"typed\");\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n                System.out.println(\"File without name \" + filename + \" found\");\n            }\n        }\n        catch (FileNotFoundException invalidFilename) {\n            System.out.println(invalidFilename.getMessage());\n        }\n    }\n\n\n\n    private static IRNode irbuild(String filename) throws Exception {\n        try {\n            String zhenFilename = getZhenFilename(filename);\n\n            Lexer lex;\n            try {\n                lex = new Lexer(new FileReader(zhenFilename));\n            } catch (Exception e) {\n                System.out.println(\"No file found with filename \" + filename);\n                return null;\n            }\n\n            lr_parser p;\n            if (filename.endsWith(\".eta\")) p = new EtaParser(lex);\n            else if (filename.endsWith(\".eti\")) p = new EtiParser(lex);\n            else throw new FileNotFoundException(\n                        \"Invalid filename \"\n                                + filename\n                                + \" provided: All files passed to etac must have a .eta extension\");\n\n            try {\n                if (filename.endsWith(\".eta\")) {\n                    Program result = (Program) p.parse().value;\n                    result.typeCheck(new SymbolTable<>(), zhenFilename);\n//                    filename.substring(0, filename.length() - 2)\n                    IRNode ir = result.accept(new IRVisitor(\"CompUnit\"));\n//                    ir = new IRLoweringVisitor(new IRNodeFactory_c()).visit(ir);\n                    return ir;\n                } else if (filename.endsWith(\".eti\")) {\n                    EtiInterface result = (EtiInterface) p.parse().value;\n                    result.firstPass(); // Just to throw EtaErrors\n                }\n                else {\n                    System.out.println(\"Why are we here\");\n                }\n\n//                if (opts.isSet(OptimizationTypes.CONSTANT_FOLDING)) {\n//\n//                }\n\n            } catch (EtaError e) {\n                e.printError(zhenFilename);\n                throw e;\n            } catch (Exception e) {\n                e.printStackTrace();\n                throw e;\n            }\n        }\n        catch (FileNotFoundException invalidFilename) {\n            System.out.println(invalidFilename.getMessage());\n        }\n\n        return null;\n    }\n\n    private static void irgenFile(String filename, boolean shouldWrite) {\n        String zhenFilename = getZhenFilename(filename);\n\n        try {\n            IRNode ir = irbuild(zhenFilename);\n\n            StringWriter out = new StringWriter();\n            PrintWriter pw = new PrintWriter(out);\n\n            CodeWriterSExpPrinter printer = new CodeWriterSExpPrinter(pw);\n//            System.out.println(ir);\n//            System.out.println(ir instanceof IRCompUnit);\n            ir.printSExp(printer);\n\n            printer.close();\n\n            if (shouldWrite) {\n                writeOutput(filename, out.toString(), \"ir\");\n            }\n        }\n        catch (EtaError e) {\n            e.printError(zhenFilename);\n        }\n        catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void irrunFile(String filename, boolean shouldWrite) {\n        String zhenFilename = getZhenFilename(filename);\n\n        try {\n            IRNode ir = irbuild(zhenFilename);\n\n            StringWriter out = new StringWriter();\n            PrintWriter pw = new PrintWriter(out);\n\n            CodeWriterSExpPrinter printer = new CodeWriterSExpPrinter(pw);\n\n            IRSimulator sim = new IRSimulator((IRCompUnit) ir);\n            sim.call(\"_Imain_paai\", 0);\n\n            ir.printSExp(printer);\n\n            printer.close();\n\n            if (shouldWrite) {\n                writeOutput(filename, out.toString(), \"ir\");\n            }\n        }\n        catch (EtaError e) {\n            e.printError(zhenFilename);\n        }\n        catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void main(String[] args) throws java.io.IOException {\n        ArrayList<String> filenames = new ArrayList<>();\n        for (int i = args.length - 1; i >= 0; i--) {\n            if (args[i].endsWith(\".eta\") || args[i].endsWith(\".eti\")) {\n                filenames.add(args[i]);\n            }\n        }\n\n        // Create the command line parser\n        CommandLineParser parser = new DefaultParser();\n\n        // Create the Options\n        Options options = new Options();\n\n        Option helpOpt = new Option(\"h\", \"help\", false,\n                \"Print a synopsis of options.\");\n\n        Option lexOpt = new Option(null, \"lex\", false,\n                \"Generate output from lexical analysis.\");\n        Option parseOpt = new Option(null, \"parse\", false,\n                \"Generate output from syntactic analysis.\");\n        Option typeOpt = new Option(null, \"typecheck\", false,\n                \"Generate output from semantic analysis.\");\n        Option irgenOpt = new Option (null, \"irgen\", false,\n                \"Generate intermediate code.\");\n\n\n        Option sourcepathOpt   = new Option (\"sourcepath\", true,\n                \"Specify where to find input source files.\");\n        Option libpathOpt = new Option (\"libpath\", true,\n                \"Specify where to find library interface files.\");\n\n        Option dirOpt   = new Option (\"D\", true,\n                \"Specify where to place generated diagnostic files.\");\n        Option optOpt   = new Option (\"O\", false,\n                \" Disable optimizations.\");\n        Option irrunOpt = new Option (null, \"irrun\", false,\n                \"Generate and interpret intermediate code.\");\n\n        options.addOption(helpOpt);\n        options.addOption(lexOpt);\n        options.addOption(parseOpt);\n        options.addOption(typeOpt);\n        options.addOption(irgenOpt);\n\n        options.addOption(sourcepathOpt);\n        options.addOption(libpathOpt);\n        options.addOption(optOpt);\n        options.addOption(dirOpt);\n        options.addOption(irrunOpt);\n\n        HelpFormatter formatter = new HelpFormatter();\n\n        opts = new Optimizations();\n        opts.setOptimizations(OptimizationTypes.CONSTANT_FOLDING, OptimizationTypes.IR_LOWERING);\n\n        isOutputDirSpecified = isInputDirSpecified = isLibpathDirSpecified = false;\n        outputDirectory = inputDirectory = libpathDirectory = Paths.get(\"\").toAbsolutePath().toString();\n\n//        System.out.println(outputDirectory);\n\n        try {\n            CommandLine cmd = parser.parse(options, args);\n            if (args.length == 0 || cmd.hasOption(\"help\")) {\n                formatter.printHelp(\"etac [options] <source files>\", options);\n                return;\n            }\n\n            if (cmd.hasOption(\"D\")) {\n                outputDirectory = cmd.getOptionValue(\"D\");\n                isOutputDirSpecified = true;\n            }\n\n            if (cmd.hasOption(\"O\")) {\n                System.out.println(opts);\n                opts.clearOptimizations(OptimizationTypes.CONSTANT_FOLDING, OptimizationTypes.IR_LOWERING);\n                System.out.println(opts);\n            }\n\n            if (cmd.hasOption(\"sourcepath\")) {\n                inputDirectory = cmd.getOptionValue(\"sourcepath\");\n                isInputDirSpecified = true;\n            }\n\n            if (cmd.hasOption(\"libpath\")) {\n                libpathDirectory = cmd.getOptionValue(\"libpath\");\n                isLibpathDirSpecified = true;\n            }\n\n            if (cmd.hasOption(\"lex\")) {\n                for (String filename : filenames) {\n                    typeCheckFile(filename, false);\n                    lexFile(filename, new StringBuilder(), true);\n                }\n            }\n\n            if (cmd.hasOption(\"parse\")) {\n                for (String filename : filenames) {\n                    typeCheckFile(filename, false);\n                    parseFile(filename, true);\n                }\n            }\n\n            if (cmd.hasOption(\"typecheck\")) {\n                for (String filename : filenames) {\n                    typeCheckFile(filename, true);\n                }\n            }\n\n            if (cmd.hasOption(\"irgen\")) {\n                for (String filename : filenames) {\n                    irgenFile(filename, true);\n                }\n            }\n\n            if (cmd.hasOption(\"irrun\")) {\n                for (String filename : filenames) {\n                    irrunFile(filename, true);\n                }\n            }\n\n        }\n        catch (ParseException parseException) {\n            formatter.printHelp(\"etac [options] <source files>\", options);\n            System.out.println(\"Unexpected exception: \" + parseException.getMessage());\n        }\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/aar226_akc55_ayc62_ahl88/Main.java b/src/main/java/aar226_akc55_ayc62_ahl88/Main.java
--- a/src/main/java/aar226_akc55_ayc62_ahl88/Main.java	(revision b1075ede668d50c2c31e135676f0a5424ad8c1aa)
+++ b/src/main/java/aar226_akc55_ayc62_ahl88/Main.java	(date 1678640837966)
@@ -274,7 +274,7 @@
                     result.typeCheck(new SymbolTable<>(), zhenFilename);
 //                    filename.substring(0, filename.length() - 2)
                     IRNode ir = result.accept(new IRVisitor("CompUnit"));
-//                    ir = new IRLoweringVisitor(new IRNodeFactory_c()).visit(ir);
+                    ir = new IRLoweringVisitor(new IRNodeFactory_c()).visit(ir);
                     return ir;
                 } else if (filename.endsWith(".eti")) {
                     EtiInterface result = (EtiInterface) p.parse().value;
