Index: src/main/java/aar226_akc55_ayc62_ahl88/src/edu/cornell/cs/cs4120/xic/ir/visit/ASMVisitor.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package aar226_akc55_ayc62_ahl88.src.edu.cornell.cs.cs4120.xic.ir.visit;\n\nimport aar226_akc55_ayc62_ahl88.asm.*;\nimport aar226_akc55_ayc62_ahl88.asm.Expressions.*;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.ASMArg2;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.ASMInstruction;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.ASMLabel;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.jumps.ASMJumpNotEqual;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.mov.ASMMov;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.mov.ASMMovabs;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.stackops.ASMPush;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.tstcmp.ASMTest;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.jumps.ASMJumpAlways;\nimport aar226_akc55_ayc62_ahl88.src.edu.cornell.cs.cs4120.xic.ir.*;\nimport aar226_akc55_ayc62_ahl88.src.polyglot.util.InternalCompilerError;\n\nimport java.util.ArrayList;\nimport java.util.HashSet;\n\n/**\n * NOTES:\n * - branches: use cmp then corresponding jump\n * - multireturn: store first argument in rax, push rest on stack\n * - function args: rdi, rsi, rdx, rcx, r8, r9, push rest on stack\n * - callee saved: rbx, rbp, and r12â€“r15\n * - caller saved: everything else\n *\n * THINGS WE NEEEEEEEEEEEDDDDDDDDD\n * - ir compunit ->\n *      add glob mem locations\n *      call visit to all functions\n * - ir func decl ->\n *      create new label at the top for function name\n *      follow abi for args and register alloc\n *      call visit on each statement\n *      flatten arraylist we get back\n *      follow abi for correct func exit\n * - jump -> jr <label name>\n * - cjump ->\n *      two args: cmp <t1> <t2>; j<flag> <label name>\n *      if instance of IRConst and is boolliteral: true -> jr / false -> nothing\n * - move ->\n *      mooooooooooooove\n *      contains expr: used for dynamic tiling\n *      tiling\n * - mem\n * - binop\n * - call stmt ->\n *      init function call follow abi for function call (store func args correctly)\n *      jump to function\n *      clean accroding to ABI spec (be careful about multireturns and stack dead space)\n *      pop from function\n * - IR Label -> ASM label\n *\n *\n * Generic ASM Class will be called ASMNode\n */\n\npublic class ASMVisitor {\n    private int tempCnt;\n\n\n    private String nxtTemp() {\n        return String.format(\"_ASMReg_t%d\", (tempCnt++));\n    }\n    private ASMDirectives getType(String name) {\n        String type = name.split(\"_\")[0];\n        if (type.equals(\"i\") || type.equals(\"b\")) {\n            return ASMDirectives.QUAD;\n        }\n        return ASMDirectives.ZERO;\n    }\n    // converts an IR TEMP to an ASM TEMP\n    private ASMTempExpr tempToASM(IRTemp t) {\n        return new ASMTempExpr(t.name());\n    }\n    // change te parameters if needed\n    private ArrayList<ASMInstruction> cJumpBinop(IRBinOp binop){\n        ArrayList<ASMInstruction> instructions = new ArrayList<ASMInstruction>();\n//        switch (binop.opType()) {\n//            case EQ:\n//            case NEQ:\n//            case LT:\n//            case ULT:\n//            case GT:\n//            case LEQ:\n//            case GEQ:\n////                ASMArg2 instr1 = new ASMCmp(binop.left(), binop.right());\n//\n//        }\n        return instructions;\n    }\n    public ArrayList<ASMInstruction> visit(IRCallStmt node){\n        return null;\n    }\n    public ArrayList<ASMInstruction> visit(IRData node){\n        ArrayList<ASMInstruction> instructions = new ArrayList<ASMInstruction>();\n\n        return instructions;\n    }\n    public ArrayList<ASMInstruction> visit(IRCJump node) {\n        ArrayList<ASMInstruction> instructions = new ArrayList<ASMInstruction>();\n\n        IRExpr condition = node.cond();\n\n        if (condition instanceof IRBinOp c) {\n            // create function for IRBINOP\n            // DO A CMP instead\n            return cJumpBinop(c);\n        } else if (condition instanceof IRConst c) {\n            if (c.value() != 0L){ // jump\n                instructions.add(new ASMJumpAlways(new ASMNameExpr(node.trueLabel())));\n            }\n        } else if (condition instanceof IRTemp c) {\n            ASMTempExpr tempName = tempToASM(c);\n            instructions.add(new ASMTest(tempName,tempName));\n            instructions.add(new ASMJumpNotEqual(new ASMNameExpr(node.trueLabel())));\n            //test t, t\n            //jnz l\n        } else if (condition instanceof IRMem c) {\n            ASMTempExpr tempForMem = new ASMTempExpr(nxtTemp());\n            // accept mem for this temp\n            // add move instruction\n            // do temp test and ASM Jump no Equal\n            return null;\n        }else{\n            throw new InternalCompilerError(\"CJUMP guard has another type\");\n        }\n        return instructions;\n    }\n    public ArrayList<ASMInstruction> visit(IRCompUnit node) {\n        ArrayList<ASMInstruction> instructions = new ArrayList<ASMInstruction>();\n\n        for (IRData data : node.dataMap().values()) {\n            ASMLabel data_label = new ASMLabel(data.name());\n//            ASMData data_instr = new ASMData(getType(data.name()), new ASMConstExpr(data.data()));\n        }\n\n        for (IRFuncDecl func : node.functions().values()) {\n            instructions.addAll(visit(func));\n        }\n\n        return instructions;\n    }\n    public ArrayList<ASMInstruction> visit (IRConst x) {\n        ArrayList<ASMInstruction> instructions = new ArrayList<ASMInstruction>();\n        boolean isInt = x.value() <= Integer.MAX_VALUE && x.value() >= Integer.MIN_VALUE;\n        ASMArg2 instruction = (isInt) ? new ASMMov(new ASMTempExpr(nxtTemp()),new ASMConstExpr(x.value()))\n                : new ASMMovabs(new ASMTempExpr(nxtTemp()),new ASMConstExpr(x.value()));\n        instructions.add(instruction);\n        return instructions;\n    }\n    public ArrayList<ASMInstruction> visit(IRFuncDecl node) {\n        ArrayList<ASMInstruction> result = new ArrayList<>();\n\n        // create new Starting label for this Function\n        result.add(new ASMLabel(node.name()));\n\n        // push rbp\n        // mov rbp rsp\n        result.add(new ASMPush(new ASMRegisterExpr(\"rbp\")));\n        result.add(new ASMMov(new ASMRegisterExpr(\"rbp\"),new ASMRegisterExpr(\"rsp\")));\n\n        // need to calculate number of temporaries used\n        // sub rsp, 8*l\n        HashSet<String> asmTempNames = new HashSet<>();\n\n\n        // foo(1,2,3,4,5,6,7....) -> rdi, rsi, rdx, rcx, r8, r9, stack\n        int numParams = node.functionSig.inputTypes.size();\n        ArrayList<ASMInstruction> bodyInstructions = new ArrayList<>();\n        for (int i = 1; i<=numParams;i++){\n\n            // Move arg into argI. argI <- RDI\n            ASMExpr ARGI = switch (i) {\n                case 1 -> new ASMRegisterExpr(\"rdi\");\n                case 2 -> new ASMRegisterExpr(\"rsi\");\n                case 3 -> new ASMRegisterExpr(\"rdx\");\n                case 4 -> new ASMRegisterExpr(\"rcx\");\n                case 5 -> new ASMRegisterExpr(\"r8\");\n                case 6 -> new ASMRegisterExpr(\"r9\");\n                default ->\n                        new ASMMemExpr(\n                                new ASMBinOpAddExpr(\n                                        new ASMRegisterExpr(\"rbp\"),\n                                        new ASMConstExpr(8L * (i - 7 + 2))));\n            };\n            String tempName = nxtTemp();\n            asmTempNames.add(tempName);\n            // can't do [stack location] <- [stack location2]\n            // need intermediate rax <- [stack location2]\n            // then [stack location] <- temp rax\n            if (i>=7){\n                bodyInstructions.add(new ASMMov(new ASMRegisterExpr(\"rax\"),ARGI));\n                bodyInstructions.add(new ASMMov(new ASMTempExpr(tempName),new ASMRegisterExpr(\"rax\")));\n            }\n            // just do MOV [stack location] <- register\n            else{\n                bodyInstructions.add(new ASMMov(new ASMTempExpr(tempName),ARGI));\n            }\n        }\n        return null;\n    }\n    public ArrayList<ASMInstruction> visit(IRJump jump) {\n        ArrayList<ASMInstruction> instructions = new ArrayList<ASMInstruction>();\n        if (jump.target() instanceof IRName) {\n            instructions.add(new ASMJumpAlways(new ASMNameExpr(jump.label())));\n        }\n        return instructions;\n    }\n    public ArrayList<ASMInstruction> visit(IRLabel node) {\n        ArrayList<ASMInstruction> instructions = new ArrayList<ASMInstruction>();\n        instructions.add(new ASMLabel(node.name()));\n        return instructions;\n    }\n    public ArrayList<ASMInstruction> visit(IRMove node){\n        return null;\n    }\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/aar226_akc55_ayc62_ahl88/src/edu/cornell/cs/cs4120/xic/ir/visit/ASMVisitor.java b/src/main/java/aar226_akc55_ayc62_ahl88/src/edu/cornell/cs/cs4120/xic/ir/visit/ASMVisitor.java
--- a/src/main/java/aar226_akc55_ayc62_ahl88/src/edu/cornell/cs/cs4120/xic/ir/visit/ASMVisitor.java	(revision 9b53b468f07067f1b06bb95d5c08417ed97ca0ef)
+++ b/src/main/java/aar226_akc55_ayc62_ahl88/src/edu/cornell/cs/cs4120/xic/ir/visit/ASMVisitor.java	(date 1680382719890)
@@ -9,6 +9,7 @@
 import aar226_akc55_ayc62_ahl88.asm.Instructions.mov.ASMMov;
 import aar226_akc55_ayc62_ahl88.asm.Instructions.mov.ASMMovabs;
 import aar226_akc55_ayc62_ahl88.asm.Instructions.stackops.ASMPush;
+import aar226_akc55_ayc62_ahl88.asm.Instructions.subroutine.ASMEnter;
 import aar226_akc55_ayc62_ahl88.asm.Instructions.tstcmp.ASMTest;
 import aar226_akc55_ayc62_ahl88.asm.Instructions.jumps.ASMJumpAlways;
 import aar226_akc55_ayc62_ahl88.src.edu.cornell.cs.cs4120.xic.ir.*;
@@ -158,8 +159,8 @@
 
         // push rbp
         // mov rbp rsp
-        result.add(new ASMPush(new ASMRegisterExpr("rbp")));
-        result.add(new ASMMov(new ASMRegisterExpr("rbp"),new ASMRegisterExpr("rsp")));
+//        result.add(new ASMPush(new ASMRegisterExpr("rbp")));
+//        result.add(new ASMMov(new ASMRegisterExpr("rbp"),new ASMRegisterExpr("rsp")));
 
         // need to calculate number of temporaries used
         // sub rsp, 8*l
@@ -185,7 +186,7 @@
                                         new ASMRegisterExpr("rbp"),
                                         new ASMConstExpr(8L * (i - 7 + 2))));
             };
-            String tempName = nxtTemp();
+            String tempName = "_ARG" + i;
             asmTempNames.add(tempName);
             // can't do [stack location] <- [stack location2]
             // need intermediate rax <- [stack location2]
@@ -198,7 +199,17 @@
             else{
                 bodyInstructions.add(new ASMMov(new ASMTempExpr(tempName),ARGI));
             }
+//            if (node.body() instanceof IRSeq seq){
+//                for (IRStmt stmt: seq.stmts()){
+//                    bodyInstructions.addAll(stmt.accept(this));
+//                }
+//            }else{
+//                throw new InternalCompilerError("node body is not seq");
+//            }
+
         }
+        result.add(new ASMEnter(new ASMConstExpr(8L*asmTempNames.size()),new ASMConstExpr(0)));
+
         return null;
     }
     public ArrayList<ASMInstruction> visit(IRJump jump) {
