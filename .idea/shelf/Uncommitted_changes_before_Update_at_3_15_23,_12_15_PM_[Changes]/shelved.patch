Index: src/main/java/aar226_akc55_ayc62_ahl88/Main.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package aar226_akc55_ayc62_ahl88;\n\nimport aar226_akc55_ayc62_ahl88.Errors.EtaError;\nimport aar226_akc55_ayc62_ahl88.SymbolTable.SymbolTable;\nimport aar226_akc55_ayc62_ahl88.newast.AstNode;\nimport aar226_akc55_ayc62_ahl88.newast.Program;\nimport aar226_akc55_ayc62_ahl88.newast.Type;\nimport aar226_akc55_ayc62_ahl88.newast.interfaceNodes.EtiInterface;\nimport aar226_akc55_ayc62_ahl88.src.edu.cornell.cs.cs4120.xic.ir.IRCompUnit;\nimport aar226_akc55_ayc62_ahl88.src.edu.cornell.cs.cs4120.xic.ir.IRConst;\nimport aar226_akc55_ayc62_ahl88.src.edu.cornell.cs.cs4120.xic.ir.IRNode;\nimport aar226_akc55_ayc62_ahl88.src.edu.cornell.cs.cs4120.xic.ir.IRNodeFactory_c;\nimport aar226_akc55_ayc62_ahl88.src.edu.cornell.cs.cs4120.xic.ir.interpret.IRSimulator;\nimport aar226_akc55_ayc62_ahl88.src.edu.cornell.cs.cs4120.xic.ir.visit.IRLoweringVisitor;\nimport aar226_akc55_ayc62_ahl88.visitors.IRVisitor;\nimport java_cup.runtime.Symbol;\nimport java_cup.runtime.lr_parser;\nimport org.apache.commons.cli.*;\nimport java.io.*;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\n\nimport aar226_akc55_ayc62_ahl88.src.edu.cornell.cs.cs4120.util.CodeWriterSExpPrinter;\n\npublic class Main {\n    private static String outputDirectory;\n    private static String inputDirectory;\n    public static String libpathDirectory;\n\n    private static boolean isOutputDirSpecified;\n    private static boolean isInputDirSpecified;\n    public static boolean isLibpathDirSpecified;\n\n    public static Optimizations opts;\n\n    // Write the lexed string into the corresponding file name\n    private static void writeOutput(String filename, String output, String extension) {\n        Path path = (isOutputDirSpecified)\n                        ? Paths.get(outputDirectory, filename)\n                        : Paths.get(filename);\n\n        String pathname = path.toString();\n        pathname = pathname.substring(0, pathname.length() - 3) + extension;\n//        System.out.println(pathname);\n        Path parentPath = path.getParent();\n        String dirname = (parentPath == null) ? \"\" : parentPath.toString();\n//        System.out.println(dirname);\n        // Create directory\n        File dir = new File(dirname);\n        dir.mkdirs();\n\n        // Create file\n        try {\n            File file = new File(pathname);\n            file.createNewFile();\n        }\n        catch (IOException e) {\n            System.out.println(\"An error occurred when creating the file \" + filename);\n            return;\n        }\n\n        // Write to file\n        try {\n            FileWriter myWriter = new FileWriter(pathname);\n\n            myWriter.write(output);\n            myWriter.close();\n        }\n        catch (IOException e) {\n            System.out.println(\"An error occurred when writing to the file \" + filename);\n        }\n    }\n\n    private static String prettyOut(Symbol s){\n        String out = s.value().toString();\n        switch (s.sym){\n            case (sym.INTEGER_LITERAL):\n                if (out.length() > 1){\n                    out = out.substring(1);\n                }\n                out = \"integer \" + out;\n                break;\n            case (sym.BOOL_LITERAL):\n                out = \"boolean \" + out;\n                break;\n            case (sym.IDENTIFIER):\n                out = \"id \" +  out;\n                break;\n            case (sym.CHARACTER_LITERAL):\n                out = \"character \" +  out;\n                break;\n            case (sym.STRING_LITERAL):\n                out = \"string \" + out;\n                break;\n            default:\n                break;\n        }\n        return String.format(\"%d:%d %s\\n\", s.left, s.right, out);\n    }\n\n    private static String getZhenFilename(String filename) {\n        return (isInputDirSpecified)\n                ? Paths.get(inputDirectory, filename).toString()\n                : filename;\n    }\n\n    private static void lexFile(String filename, StringBuilder lexedOutput, boolean shouldWrite) throws IOException {\n        try {\n            if (filename.endsWith(\".eta\") || filename.endsWith(\".eti\")) {\n                String zhenFilename = getZhenFilename(filename);\n\n                Lexer etaLexer;\n                try {\n                    etaLexer = new Lexer(new FileReader(zhenFilename));\n                } catch (Exception e) {\n                    System.out.println(\"File without name \" + filename + \" found\");\n                    return;\n                }\n\n                try {\n                    while (true) {\n                        Symbol t = etaLexer.next_token();\n                        if (t.sym == sym.EOF) break;\n                        String lexed = prettyOut(t);\n                        lexedOutput.append(lexed);\n                    }\n                }\n                catch (EtaError e) {\n                    lexedOutput.append(e.getMessage());\n                }\n            }\n            else {\n                throw new FileNotFoundException(\n                        \"Invalid filename \"\n                                + filename\n                                + \" provided: All files passed to etac must have a .eta extension\");\n            }\n        }\n        catch (FileNotFoundException invalidFilename) {\n            System.out.println(invalidFilename.getMessage());\n            return;\n        }\n\n        if (shouldWrite) {\n            writeOutput(filename, lexedOutput.toString(), \"lexed\");\n        }\n    }\n\n    private static void parseFile(String filename, boolean shouldWrite) throws IOException {\n        try {\n            String zhenFilename = getZhenFilename(filename);\n\n            Lexer lex;\n            try {\n                lex = new Lexer(new FileReader(zhenFilename));\n            } catch (Exception e) {\n                System.out.println(\"File without name \" + filename + \" found\");\n                return;\n            }\n\n            lr_parser p = null;\n            if (filename.endsWith(\".eta\")) p = new EtaParser(lex);\n            else if (filename.endsWith(\".eti\")) p = new EtiParser(lex);\n            else throw new FileNotFoundException(\n                        \"Invalid filename \"\n                                + filename\n                                + \" provided: All files passed to etac must have a .eta extension\");\n\n            try {\n                StringWriter out = new StringWriter();\n                PrintWriter cw = new PrintWriter(out);\n                CodeWriterSExpPrinter printer = new CodeWriterSExpPrinter(cw);\n\n                if (filename.endsWith(\".eta\")) {\n                    Program result = (Program) p.parse().value;\n                    result.prettyPrint(printer);\n                }\n                else if (filename.endsWith(\".eti\")) {\n                    EtiInterface result = (EtiInterface) p.parse().value;\n                    result.prettyPrint(printer);\n                }\n\n                printer.close();\n                if (shouldWrite) {\n                    writeOutput(filename, out.toString(), \"parsed\");\n                }\n            } catch (EtaError e) {\n                if (shouldWrite) {\n                    writeOutput(filename, e.getMessage(), \"parsed\");\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n                System.out.println(\"File without name \" + filename + \" found\");\n            }\n        }\n        catch (FileNotFoundException invalidFilename) {\n            System.out.println(invalidFilename.getMessage());\n        }\n    }\n\n    private static void typeCheckFile(String filename, boolean shouldWrite) throws IOException {\n        try {\n            String zhenFilename = getZhenFilename(filename);\n\n            Lexer lex = null;\n            try {\n                lex = new Lexer(new FileReader(zhenFilename));\n            } catch (Exception e) {\n                System.out.println(\"No file found with filename \" + filename);\n                return;\n            }\n\n            lr_parser p;\n            if (filename.endsWith(\".eta\")) p = new EtaParser(lex);\n            else if (filename.endsWith(\".eti\")) p = new EtiParser(lex);\n            else throw new FileNotFoundException(\n                        \"Invalid filename \"\n                                + filename\n                                + \" provided: All files passed to etac must have a .eta extension\");\n\n            try {\n                if (filename.endsWith(\".eta\")) {\n                    Program result = (Program) p.parse().value;\n                    result.typeCheck(new SymbolTable<>(), zhenFilename);\n                } else if (filename.endsWith(\".eti\")) {\n                    EtiInterface result = (EtiInterface) p.parse().value;\n                    result.firstPass(); // Just to throw EtaErrors\n                }\n\n                if (shouldWrite) {\n                    writeOutput(filename, \"Valid Eta Program\", \"typed\");\n                }\n            } catch (EtaError e) {\n                e.printError(zhenFilename);\n                if (shouldWrite) {\n                    writeOutput(filename, e.getMessage(), \"typed\");\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n                System.out.println(\"File without name \" + filename + \" found\");\n            }\n        }\n        catch (FileNotFoundException invalidFilename) {\n            System.out.println(invalidFilename.getMessage());\n        }\n    }\n\n\n\n    private static IRNode irbuild(String filename) throws Exception {\n        try {\n            String zhenFilename = getZhenFilename(filename);\n\n            Lexer lex;\n            try {\n                lex = new Lexer(new FileReader(zhenFilename));\n            } catch (Exception e) {\n                System.out.println(\"No file found with filename \" + filename);\n                return null;\n            }\n\n            lr_parser p;\n            if (filename.endsWith(\".eta\")) p = new EtaParser(lex);\n            else if (filename.endsWith(\".eti\")) p = new EtiParser(lex);\n            else throw new FileNotFoundException(\n                        \"Invalid filename \"\n                                + filename\n                                + \" provided: All files passed to etac must have a .eta extension\");\n\n            try {\n                if (filename.endsWith(\".eta\")) {\n                    Program result = (Program) p.parse().value;\n                    result.typeCheck(new SymbolTable<>(), zhenFilename);\n//                    filename.substring(0, filename.length() - 2)\n                    IRNode ir = result.accept(new IRVisitor(\"CompUnit\"));\n                    ir = new IRLoweringVisitor(new IRNodeFactory_c()).visit(ir);\n                    return ir;\n                } else if (filename.endsWith(\".eti\")) {\n                    EtiInterface result = (EtiInterface) p.parse().value;\n                    result.firstPass(); // Just to throw EtaErrors\n                }\n                else {\n                    System.out.println(\"Why are we here\");\n                }\n\n//                if (opts.isSet(OptimizationTypes.CONSTANT_FOLDING)) {\n//\n//                }\n\n            } catch (EtaError e) {\n                e.printError(zhenFilename);\n                throw e;\n            } catch (Exception e) {\n                e.printStackTrace();\n                throw e;\n            }\n        }\n        catch (FileNotFoundException invalidFilename) {\n            System.out.println(invalidFilename.getMessage());\n        }\n\n        return null;\n    }\n\n    private static void irgenFile(String filename, boolean shouldWrite) {\n        String zhenFilename = getZhenFilename(filename);\n\n        try {\n            IRNode ir = irbuild(zhenFilename);\n\n            StringWriter out = new StringWriter();\n            PrintWriter pw = new PrintWriter(out);\n\n            CodeWriterSExpPrinter printer = new CodeWriterSExpPrinter(pw);\n//            System.out.println(ir);\n//            System.out.println(ir instanceof IRCompUnit);\n            ir.printSExp(printer);\n\n            printer.close();\n\n            if (shouldWrite) {\n                writeOutput(filename, out.toString(), \"ir\");\n            }\n        }\n        catch (EtaError e) {\n            e.printError(zhenFilename);\n        }\n        catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void irrunFile(String filename, boolean shouldWrite) {\n        String zhenFilename = getZhenFilename(filename);\n\n        try {\n            IRNode ir = irbuild(zhenFilename);\n\n            StringWriter out = new StringWriter();\n            PrintWriter pw = new PrintWriter(out);\n\n            CodeWriterSExpPrinter printer = new CodeWriterSExpPrinter(pw);\n\n            IRSimulator sim = new IRSimulator((IRCompUnit) ir);\n            sim.call(\"_Imain_paai\", 0);\n\n            ir.printSExp(printer);\n\n            printer.close();\n\n            if (shouldWrite) {\n                writeOutput(filename, out.toString(), \"ir\");\n            }\n        }\n        catch (EtaError e) {\n            e.printError(zhenFilename);\n        }\n        catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void main(String[] args) throws java.io.IOException {\n        ArrayList<String> filenames = new ArrayList<>();\n        for (int i = args.length - 1; i >= 0; i--) {\n            if (args[i].endsWith(\".eta\") || args[i].endsWith(\".eti\")) {\n                filenames.add(args[i]);\n            }\n        }\n\n        // Create the command line parser\n        CommandLineParser parser = new DefaultParser();\n\n        // Create the Options\n        Options options = new Options();\n\n        Option helpOpt = new Option(\"h\", \"help\", false,\n                \"Print a synopsis of options.\");\n\n        Option lexOpt = new Option(null, \"lex\", false,\n                \"Generate output from lexical analysis.\");\n        Option parseOpt = new Option(null, \"parse\", false,\n                \"Generate output from syntactic analysis.\");\n        Option typeOpt = new Option(null, \"typecheck\", false,\n                \"Generate output from semantic analysis.\");\n        Option irgenOpt = new Option (null, \"irgen\", false,\n                \"Generate intermediate code.\");\n\n\n        Option sourcepathOpt   = new Option (\"sourcepath\", true,\n                \"Specify where to find input source files.\");\n        Option libpathOpt = new Option (\"libpath\", true,\n                \"Specify where to find library interface files.\");\n\n        Option dirOpt   = new Option (\"D\", true,\n                \"Specify where to place generated diagnostic files.\");\n        Option optOpt   = new Option (\"O\", true,\n                \" Disable optimizations.\");\n\n        Option irrunOpt = new Option (null, \"irrun\", false,\n                \"Generate and interpret intermediate code.\");\n\n        optOpt.setOptionalArg(true);\n\n        options.addOption(helpOpt);\n        options.addOption(lexOpt);\n        options.addOption(parseOpt);\n        options.addOption(typeOpt);\n        options.addOption(irgenOpt);\n\n        options.addOption(sourcepathOpt);\n        options.addOption(libpathOpt);\n        options.addOption(optOpt);\n        options.addOption(dirOpt);\n        options.addOption(irrunOpt);\n\n        HelpFormatter formatter = new HelpFormatter();\n\n        opts = new Optimizations();\n        opts.setOptimizations(OptimizationTypes.CONSTANT_FOLDING, OptimizationTypes.IR_LOWERING);\n\n        isOutputDirSpecified = isInputDirSpecified = isLibpathDirSpecified = false;\n        outputDirectory = inputDirectory = libpathDirectory = Paths.get(\"\").toAbsolutePath().toString();\n\n//        System.out.println(outputDirectory);\n\n        try {\n            CommandLine cmd = parser.parse(options, args);\n            if (args.length == 0 || cmd.hasOption(\"help\")) {\n                formatter.printHelp(\"etac [options] <source files>\", options);\n                return;\n            }\n\n            if (cmd.hasOption(\"D\")) {\n                outputDirectory = cmd.getOptionValue(\"D\");\n                isOutputDirSpecified = true;\n            }\n\n            if (cmd.hasOption(\"O\")) {\n//                System.out.println(opts);\n\n                int level;\n                try {\n                    level = Integer.parseInt(cmd.getOptionValue(\"O\"));\n                }\n                catch (Exception e) {\n                    level = 3;\n                }\n\n                switch (level) {\n                    case 0:\n                        opts.clearOptimizations(OptimizationTypes.CONSTANT_FOLDING, OptimizationTypes.IR_LOWERING);\n                        break;\n                    case 1:\n                        opts.clearOptimizations(OptimizationTypes.IR_LOWERING);\n                        break;\n                    default:\n                        break;\n                }\n\n//                System.out.println(opts);\n            }\n\n            if (cmd.hasOption(\"sourcepath\")) {\n                inputDirectory = cmd.getOptionValue(\"sourcepath\");\n                isInputDirSpecified = true;\n            }\n\n            if (cmd.hasOption(\"libpath\")) {\n                libpathDirectory = cmd.getOptionValue(\"libpath\");\n                isLibpathDirSpecified = true;\n            }\n\n            if (cmd.hasOption(\"lex\")) {\n                for (String filename : filenames) {\n                    typeCheckFile(filename, false);\n                    lexFile(filename, new StringBuilder(), true);\n                }\n            }\n\n            if (cmd.hasOption(\"parse\")) {\n                for (String filename : filenames) {\n                    typeCheckFile(filename, false);\n                    parseFile(filename, true);\n                }\n            }\n\n            if (cmd.hasOption(\"typecheck\")) {\n                for (String filename : filenames) {\n                    typeCheckFile(filename, true);\n                }\n            }\n\n            if (cmd.hasOption(\"irgen\")) {\n                for (String filename : filenames) {\n                    irgenFile(filename, true);\n                }\n            }\n\n            if (cmd.hasOption(\"irrun\")) {\n                for (String filename : filenames) {\n                    irrunFile(filename, true);\n                }\n            }\n\n        }\n        catch (ParseException parseException) {\n            formatter.printHelp(\"etac [options] <source files>\", options);\n            System.out.println(\"Unexpected exception: \" + parseException.getMessage());\n        }\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/aar226_akc55_ayc62_ahl88/Main.java b/src/main/java/aar226_akc55_ayc62_ahl88/Main.java
--- a/src/main/java/aar226_akc55_ayc62_ahl88/Main.java	(revision 708b6e4f0ea4fdfd9cb521cd536275eab8f78599)
+++ b/src/main/java/aar226_akc55_ayc62_ahl88/Main.java	(date 1678889377937)
@@ -11,6 +11,8 @@
 import aar226_akc55_ayc62_ahl88.src.edu.cornell.cs.cs4120.xic.ir.IRNode;
 import aar226_akc55_ayc62_ahl88.src.edu.cornell.cs.cs4120.xic.ir.IRNodeFactory_c;
 import aar226_akc55_ayc62_ahl88.src.edu.cornell.cs.cs4120.xic.ir.interpret.IRSimulator;
+import aar226_akc55_ayc62_ahl88.src.edu.cornell.cs.cs4120.xic.ir.visit.CheckCanonicalIRVisitor;
+import aar226_akc55_ayc62_ahl88.src.edu.cornell.cs.cs4120.xic.ir.visit.CheckConstFoldedIRVisitor;
 import aar226_akc55_ayc62_ahl88.src.edu.cornell.cs.cs4120.xic.ir.visit.IRLoweringVisitor;
 import aar226_akc55_ayc62_ahl88.visitors.IRVisitor;
 import java_cup.runtime.Symbol;
@@ -274,7 +276,23 @@
                     result.typeCheck(new SymbolTable<>(), zhenFilename);
 //                    filename.substring(0, filename.length() - 2)
                     IRNode ir = result.accept(new IRVisitor("CompUnit"));
-                    ir = new IRLoweringVisitor(new IRNodeFactory_c()).visit(ir);
+                    if (opts.isSet(OptimizationTypes.IR_LOWERING)) {
+                        ir = new IRLoweringVisitor(new IRNodeFactory_c()).visit(ir);
+                        // IR canonical checker demo
+                        {
+                            CheckCanonicalIRVisitor cv = new CheckCanonicalIRVisitor();
+                            System.out.print("Canonical?: ");
+                            System.out.println(cv.visit(ir));
+                        }
+                    }
+                    if (opts.isSet(OptimizationTypes.CONSTANT_FOLDING)) {
+                        // IR constant-folding checker demo
+                        {
+                            CheckConstFoldedIRVisitor cv = new CheckConstFoldedIRVisitor();
+                            System.out.print("Constant-folded?: ");
+                            System.out.println(cv.visit(ir));
+                        }
+                    }
                     return ir;
                 } else if (filename.endsWith(".eti")) {
                     EtiInterface result = (EtiInterface) p.parse().value;
@@ -459,7 +477,7 @@
                         break;
                 }
 
-//                System.out.println(opts);
+                System.out.println(opts);
             }
 
             if (cmd.hasOption("sourcepath")) {
Index: src/main/java/aar226_akc55_ayc62_ahl88/visitors/IRVisitor.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package aar226_akc55_ayc62_ahl88.visitors;\n\nimport aar226_akc55_ayc62_ahl88.Main;\nimport aar226_akc55_ayc62_ahl88.OptimizationTypes;\nimport aar226_akc55_ayc62_ahl88.newast.Dimension;\nimport aar226_akc55_ayc62_ahl88.newast.Program;\nimport aar226_akc55_ayc62_ahl88.newast.Type;\nimport aar226_akc55_ayc62_ahl88.newast.Use;\nimport aar226_akc55_ayc62_ahl88.newast.declarations.*;\nimport aar226_akc55_ayc62_ahl88.newast.definitions.Globdecl;\nimport aar226_akc55_ayc62_ahl88.newast.definitions.Method;\nimport aar226_akc55_ayc62_ahl88.newast.definitions.MultiGlobalDecl;\nimport aar226_akc55_ayc62_ahl88.newast.expr.*;\nimport aar226_akc55_ayc62_ahl88.newast.expr.arrayaccessexpr.ArrayAccessExpr;\nimport aar226_akc55_ayc62_ahl88.newast.expr.arrayliteral.ArrayValueLiteral;\nimport aar226_akc55_ayc62_ahl88.newast.expr.binop.boolbop.*;\nimport aar226_akc55_ayc62_ahl88.newast.expr.binop.intbop.IntOutBinop;\nimport aar226_akc55_ayc62_ahl88.newast.expr.binop.intbop.PlusBinop;\nimport aar226_akc55_ayc62_ahl88.newast.expr.unop.booluop.NotUnop;\nimport aar226_akc55_ayc62_ahl88.newast.expr.unop.intuop.IntegerNegExpr;\nimport aar226_akc55_ayc62_ahl88.newast.stmt.*;\nimport aar226_akc55_ayc62_ahl88.newast.stmt.declstmt.DeclAssignStmt;\nimport aar226_akc55_ayc62_ahl88.newast.stmt.declstmt.DeclNoAssignStmt;\nimport aar226_akc55_ayc62_ahl88.newast.stmt.declstmt.MultiDeclAssignStmt;\nimport aar226_akc55_ayc62_ahl88.src.edu.cornell.cs.cs4120.xic.ir.*;\nimport aar226_akc55_ayc62_ahl88.src.edu.cornell.cs.cs4120.xic.ir.IRBinOp;\nimport aar226_akc55_ayc62_ahl88.src.edu.cornell.cs.cs4120.xic.ir.IRConst;\nimport aar226_akc55_ayc62_ahl88.src.edu.cornell.cs.cs4120.xic.ir.IRExpr;\nimport aar226_akc55_ayc62_ahl88.src.edu.cornell.cs.cs4120.xic.ir.IRNode;\nimport aar226_akc55_ayc62_ahl88.src.polyglot.util.InternalCompilerError;\nimport org.apache.commons.text.StringEscapeUtils;\n\nimport javax.naming.Name;\nimport java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class IRVisitor implements Visitor<IRNode>{\n    private static final int WORD_BYTES = 8;\n    private static final String OUT_OF_BOUNDS = \"_eta_out_of_bounds\";\n    private int labelCnt;\n    private int tempCnt;\n    private int stringCnt;\n    private final String compUnitName;\n    private ArrayList<String> globalIds;\n    private boolean constantFold;\n    private ArrayList<IRData> string_consts;\n    public IRVisitor(String name) {\n        labelCnt = 0;\n        tempCnt = 0;\n        stringCnt = 1;\n        compUnitName = name;\n        string_consts = new ArrayList<>();\n        constantFold = Main.opts.isSet(OptimizationTypes.CONSTANT_FOLDING);\n    }\n    private String nxtLabel() {\n        return String.format(\"l%d\", (labelCnt++));\n    }\n    private String nxtTemp() {\n        return String.format(\"t%d\", (tempCnt++));\n    }\n    private String nxtString() {\n        return String.format(\"string_const%d\", (stringCnt++));\n    }\n\n    @Override\n    public IRExpr visit(IntOutBinop node) {\n//        DIVIDE, HIGHMULT, MINUS, MODULO, TIMES\n        Expr e1 = node.getLeftExpr();\n        Expr e2 = node.getRightExpr();\n\n        IRExpr ire1 = e1.accept(this);\n        IRExpr ire2 = e2.accept(this);\n        IRBinOp.OpType op = node.getOpType();\n\n        if (constantFold && ire1.isConstant() && ire2.isConstant()) {\n            long e1int = ire1.constant();\n            long e2int = ire2.constant();\n\n            switch (op) {\n                case DIV: if (e2int != 0) {\n                    return new IRConst(e1int / e2int);\n                }\n                    throw new Error(\"DIVIDE BY ZERO\");\n                case HMUL: BigInteger a = BigInteger.valueOf(e1int).multiply(BigInteger.valueOf(e2int));\n                            return new IRConst(a.shiftRight(64).longValue());\n                case SUB: return new IRConst(e1int - e2int);\n                case MOD: if (e2int != 0) {\n                    return new IRConst(e1int % e2int);\n                }\n                    throw new Error(\"DIVIDE BY ZERO\");\n                case MUL: return new IRConst(e1int * e2int);\n                default: throw new Error(\"NOT INTEGER ARITHMETIC BINOP\");\n            }\n        }\n        return new IRBinOp(op, ire1, ire2);\n    }\n\n    private IRExpr plusArrays(IRExpr ire1, IRExpr ire2){\n        String size1 = nxtTemp();\n        String size2 = nxtTemp();\n        String size3 = nxtTemp();\n        IRMove get_size1 = new IRMove(new IRTemp(size1), new IRMem( //store size1\n                new IRBinOp(IRBinOp.OpType.SUB, ire1, new IRConst(WORD_BYTES))));\n        IRMove get_size2 = new IRMove(new IRTemp(size2), new IRMem( // store size2\n                new IRBinOp(IRBinOp.OpType.SUB, ire2, new IRConst(WORD_BYTES))));\n        IRMove get_size3 = new IRMove(new IRTemp(size3), // size3 <= size1 + size2\n                new IRBinOp(IRBinOp.OpType.ADD, new IRTemp(size1), new IRTemp(size2)));\n\n        // 8*n+8\n        IRBinOp malloc_size = new IRBinOp(IRBinOp.OpType.ADD,\n                new IRBinOp(IRBinOp.OpType.MUL,\n                        new IRTemp(size3),\n                        new IRConst(WORD_BYTES)),\n                new IRConst(WORD_BYTES));\n\n        String head_pointer = nxtTemp();\n        // CALL(NAME(malloc), size)\n        IRCallStmt alloc_call = new IRCallStmt(new IRName(\"_eta_alloc\"), 1L, malloc_size);\n//        IRMove malloc_move = new IRMove(new IRTemp(head_pointer),alloc_call);\n        IRSeq malloc_move = new IRSeq(alloc_call,new IRMove(new IRTemp(head_pointer), new IRTemp(\"_RV1\")));\n\n        IRMove move_len = new IRMove(new IRMem(new IRTemp(head_pointer)),new IRTemp(size3));\n        // move len into -1\n\n        // increment pointer to head\n        IRBinOp add_8 = new IRBinOp(IRBinOp.OpType.ADD,new IRTemp(head_pointer), new IRConst(WORD_BYTES));\n        IRMove inc_pointer_to_head = new IRMove(new IRTemp(head_pointer),add_8);\n        // do all the top level shit first\n        IRSeq top_level_Order = new IRSeq(get_size1,get_size2,get_size3,malloc_move,move_len,inc_pointer_to_head);\n\n        /* START LOOP 1 */\n        // now time to recrusively alloc\n        String lh = nxtLabel();\n        String l1 = nxtLabel();\n        String le = nxtLabel();\n        String counter = nxtTemp();\n        IRBinOp guard = new IRBinOp(IRBinOp.OpType.LT,new IRTemp(counter), new IRTemp(size1));\n        // set counter = 0;\n        IRMove set0Counter = new IRMove(new IRTemp(counter), new IRConst(0));\n        IRLabel whileHead = new IRLabel(lh);\n        // check if counter < irExp\n        IRCJump loopCheck = new IRCJump(guard,l1,le);\n        IRLabel whileBody = new IRLabel(l1);\n        // create memory location for destination\n        IRMem leftMem = new IRMem(\n                new IRBinOp(IRBinOp.OpType.ADD,\n                        new IRBinOp(IRBinOp.OpType.MUL,new IRConst(WORD_BYTES),new IRTemp(counter)),\n                        new IRTemp(head_pointer))\n        );\n\n        IRMem rightMem = new IRMem(\n                new IRBinOp(IRBinOp.OpType.ADD,\n                        new IRBinOp(IRBinOp.OpType.MUL,new IRConst(WORD_BYTES),new IRTemp(counter)),\n                        ire1)\n        );\n\n        IRMove load_element = new IRMove(leftMem, rightMem);\n        IRMove inc_counter = new IRMove(new IRTemp(counter),\n                new IRBinOp(IRBinOp.OpType.ADD, new IRTemp(counter), new IRConst(1)));\n        // jump back to loop head\n        IRJump go_back_to_head = new IRJump(new IRName(lh));\n        IRLabel afterLoop = new IRLabel(le);\n\n        IRSeq loopComponent1 = new IRSeq(set0Counter,whileHead,loopCheck,whileBody,\n                load_element,inc_counter,go_back_to_head,afterLoop);\n        /* END LOOP 1 */\n\n        /* START LOOP 2 */\n        String lh2 = nxtLabel();\n        String l12 = nxtLabel();\n        String le2 = nxtLabel();\n        String counter2 = nxtTemp();\n        IRBinOp guard2 = new IRBinOp(IRBinOp.OpType.LT,new IRTemp(counter2), new IRTemp(size2));\n        // set counter = 0;\n        IRMove set0Counter2 = new IRMove(new IRTemp(counter2), new IRConst(0));\n        IRLabel whileHead2 = new IRLabel(lh2);\n        // check if counter < irExp\n        IRCJump loopCheck2 = new IRCJump(guard2,l12,le2);\n        IRLabel whileBody2 = new IRLabel(l12);\n        // create memory location for destination\n        IRMem leftMem2 = new IRMem(\n                new IRBinOp(IRBinOp.OpType.ADD,\n                        new IRBinOp(IRBinOp.OpType.MUL,new IRConst(WORD_BYTES),\n                                new IRBinOp(IRBinOp.OpType.ADD, new IRTemp(counter2), new IRTemp(size1))),\n                        new IRTemp(head_pointer))\n        );\n\n        IRMem rightMem2 = new IRMem(\n                new IRBinOp(IRBinOp.OpType.ADD,\n                        new IRBinOp(IRBinOp.OpType.MUL,new IRConst(WORD_BYTES),new IRTemp(counter2)),\n                        ire2)\n        );\n\n        IRMove load_element2 = new IRMove(leftMem2, rightMem2);\n        IRMove inc_counter2 = new IRMove(new IRTemp(counter2),\n                new IRBinOp(IRBinOp.OpType.ADD, new IRTemp(counter2), new IRConst(1)));\n        // jump back to loop head\n        IRJump go_back_to_head2 = new IRJump(new IRName(lh2));\n        IRLabel afterLoop2 = new IRLabel(le2);\n\n        IRSeq loopComponent2 = new IRSeq(set0Counter2,whileHead2,loopCheck2,whileBody2,\n                load_element2,inc_counter2,go_back_to_head2,afterLoop2);\n        /* END LOOP 2 */\n\n\n        IRSeq final_seq = new IRSeq(top_level_Order,loopComponent1, loopComponent2);\n        return new IRESeq(final_seq, new IRTemp(head_pointer));\n    }\n\n    @Override\n    public IRExpr visit(PlusBinop node) {\n\n        Expr e1 = node.getLeftExpr();\n        Expr e2 = node.getRightExpr();\n        IRExpr ire1 = e1.accept(this);\n        IRExpr ire2 = e2.accept(this);\n\n        // if both arrays, add\n        // if one unknown array and other array, return array\n        if  (e1.getNodeType().isArray() && e2.getNodeType().isArray()) {\n            if (e1.getNodeType().isUnknownArray() && !e2.getNodeType().isUnknownArray()) {\n                return ire2;\n            } else {\n                // ESEQ\n                // SEQ -> ACCEPT E1 -> MOVE E1 to new TEMP -> ACCEPT E2 -> MOVE E2 to new TEMP ->\n                // EXPR is the second ESEQ from plus arrays\n                return plusArrays(ire1,ire2);\n            }\n        }\n\n        // if both ints, return irbinop\n        // if one unknown and other int, return int\n        if (constantFold && ire1.isConstant() && ire2.isConstant()) {\n            return new IRConst(ire1.constant() + ire2.constant());\n        } else {\n                return new IRBinOp(IRBinOp.OpType.ADD, ire1, ire2);\n        }\n    }\n\n    @Override\n    public IRNode visit(IntegerComparisonBinop node) {\n//        < , <= , > , >=\n        Expr e1 = node.getLeftExpr();\n        Expr e2 = node.getRightExpr();\n\n        IRExpr ire1 = e1.accept(this);\n        IRExpr ire2 = e2.accept(this);\n        IRBinOp.OpType op = node.getOpType();\n\n        if (constantFold && ire1.isConstant() && ire2.isConstant()) {\n            long e1int = ire1.constant();\n            long e2int = ire2.constant();\n\n            return switch (op) {\n                case LT -> new IRConst(e1int < e2int ? 1 : 0);\n                case LEQ -> new IRConst(e1int <= e2int ? 1 : 0);\n                case GT -> new IRConst(e1int > e2int ? 1 : 0);\n                case GEQ -> new IRConst(e1int >= e2int ? 1 : 0);\n                default -> throw new Error(\"NOT INTEGER COMPARISON BINOP\");\n            };\n        }\n        return new IRBinOp(op, ire1, ire2);\n    }\n\n    @Override\n    public IRExpr visit(EquivalenceBinop node) {\n        Expr e1 = node.getLeftExpr();\n        Expr e2 = node.getRightExpr();\n\n        IRExpr ire1 = e1.accept(this);\n        IRExpr ire2 = e2.accept(this);\n        IRBinOp.OpType op = node.getOpType();\n\n        if (constantFold && ire1.isConstant() && ire2.isConstant()) {\n            long e1int = ire1.constant();\n            long e2int = ire2.constant();\n\n            return new IRConst(e1int == e2int ? 1 : 0);\n        }\n        return new IRBinOp(op, ire1, ire2);\n    }\n\n    @Override\n    public IRExpr visit(LogicalBinop node) {\n        String l1 = nxtLabel();\n        String l2 = nxtLabel();\n        String lend = nxtLabel();\n        String x = nxtTemp();\n        Expr e1 = node.getLeftExpr();\n        Expr e2 = node.getRightExpr();\n        IRExpr ire1 = e1.accept(this);\n        IRExpr ire2 = e2.accept(this);\n\n        if (constantFold && ire1.isConstant() && ire2.isConstant()) {\n            return switch (node.getBinopType()) {\n                case AND -> new IRConst((ire1.constant() == 1)  && (ire2.constant() == 1)  ? 1 : 0);\n                case OR -> new IRConst((ire1.constant() == 1)  || (ire2.constant() == 1)  ? 1 : 0);\n                default -> throw new Error(\"NOT LOGICAL BINOP\");\n            };\n        }\n\n        return switch (node.getBinopType()) {\n            case AND -> new IRESeq(new IRSeq(new IRMove(new IRTemp(x), new IRConst(0)),\n                    new IRCJump(ire1, l1, lend),\n                    new IRLabel(l1), new IRCJump(ire2, l2, lend),\n                    new IRLabel(l2), new IRMove(new IRTemp(x), new IRConst(1)),\n                    new IRLabel(lend)),\n                    new IRTemp(x));\n            case OR -> new IRESeq(new IRSeq(new IRMove(new IRTemp(x), new IRConst(1)),\n                    new IRCJump(ire1, lend, l1),\n                    new IRLabel(l1), new IRCJump(ire2, lend, l2),\n                    new IRLabel(l2), new IRMove(new IRTemp(x), new IRConst(0)),\n                    new IRLabel(lend)),\n                    new IRTemp(x));\n            default -> throw new Error(\"NOT LOGICAL BINOP\");\n        };\n    }\n\n    @Override\n    public IRExpr visit(NotUnop node) {\n        IRExpr ire = node.getE().accept(this);\n\n        if (constantFold && ire.isConstant()) {\n            return new IRConst(1-ire.constant());\n        }\n        return new IRBinOp(IRBinOp.OpType.XOR, new IRConst(1), ire);\n    }\n\n    @Override\n    public IRExpr visit(IntegerNegExpr node) {\n        IRExpr ire = node.getE().accept(this);\n        if (constantFold && ire.isConstant()) {\n            return new IRConst(-1 * ire.constant());\n        }\n        return new IRBinOp(IRBinOp.OpType.SUB, new IRConst(0), ire);\n    }\n\n    @Override\n    public IRExpr visit(BoolLiteral node) {\n        return new IRConst(node.boolVal ? 1 : 0);\n    }\n\n    @Override\n    public IRExpr visit(IntLiteral node) {\n        return new IRConst(node.number);\n    }\n\n    @Override\n    public IRExpr visit(Length node) {\n        String x = nxtTemp();\n        IRMem mem = new IRMem(new IRBinOp(IRBinOp.OpType.SUB, node.getArg().accept(this), new IRConst(WORD_BYTES)));\n        IRMove move = new IRMove(new IRTemp(x), mem);\n        return new IRESeq(move, new IRTemp(x));\n    }\n\n    @Override\n    public IRExpr visit(FunctionCallExpr node) {\n        IRName func = new IRName(genABIFunc(node.getFunctionSig(),node.getId()));\n        ArrayList<IRExpr> paramListIR = new ArrayList<>();\n        for (Expr param: node.getArgs()){\n            paramListIR.add(param.accept(this));\n        }\n        long num = node.getFunctionSig().outputTypes.size();\n        return new IRESeq(new IRCallStmt(func,num,paramListIR),new IRTemp(\"_RV1\"));\n//        return new IRESeq(new IRExp(new IRCall(func,paramListIR)),new IRTemp(\"_RV1\"));\n    }\n\n    @Override\n    public IRExpr visit(Id node) { // x = andy; this is only a\n        if (globalIds.contains(node.toString())){\n            return new IRMem(new IRName( \"_\" + node.toString()));\n        }\n        return new IRTemp(node.toString());\n    }\n\n    @Override\n    public IRExpr visit(ArrayValueLiteral node) { // Going to have to be DATA if String\n        if (node.getRaw() != null){ // it is a string\n            String stringName = nxtString();\n            long[] res  = new long[node.getValues().size()+1];\n            String escapeString  = StringEscapeUtils.unescapeJava(node.getRaw());\n            res[0] = escapeString.length();\n            for (int i = 0; i< escapeString.length();i++){\n                char c = escapeString.charAt(i);\n                res[i+1] = (int) c;\n            }\n            IRData str =  new IRData(stringName,res); // we never use lmao\n            string_consts.add(str);\n        }\n        String t = nxtTemp();   // temp label for malloc\n        ArrayList<Expr> values = node.getValues();\n        long n = values.size();\n        String l = nxtTemp();\n\n        // reg[l] <- length\n        IRMove length_to_l = new IRMove(new IRTemp(l), new IRConst(n));\n\n        // 8*n+8\n        IRBinOp size = new IRBinOp(IRBinOp.OpType.ADD,\n                new IRBinOp(IRBinOp.OpType.MUL,\n                        new IRTemp(l),\n                        new IRConst(WORD_BYTES)),\n                new IRConst(WORD_BYTES));\n\n        // CALL(NAME(malloc), size)\n        IRCallStmt alloc_call = new IRCallStmt(new IRName(\"_eta_alloc\"),1L, size);\n\n        // reg[t] <- call malloc\n        IRMove malloc_move = new IRMove(new IRTemp(t), new IRTemp(\"_RV1\"));\n\n        IRMove size_move = new IRMove(new IRMem(new IRTemp(t)), new IRTemp(l));\n\n        List<IRStmt> seq_list = new ArrayList<>(List.of(length_to_l, alloc_call, malloc_move, size_move));\n\n        for(int i = 0; i < n; i++) {\n            IRExpr ire = values.get(i).accept(this);\n            IRMove move_elmnt = new IRMove(new IRMem(new IRBinOp(\n                    IRBinOp.OpType.ADD,\n                    new IRTemp(t),\n                    new IRConst(8L*(i+1)))),\n                    ire );\n            seq_list.add(move_elmnt);\n        }\n\n        IRSeq ir_seq = new IRSeq(seq_list);\n\n        return new IRESeq(ir_seq,\n                new IRBinOp(IRBinOp.OpType.ADD,\n                        new IRTemp(t),\n                        new IRConst(WORD_BYTES)));\n\n    }\n    @Override\n    public IRExpr visit(ArrayAccessExpr node) {\n        IRExpr arrIR = node.getOrgArray().accept(this);\n        assert(node.getIndicies().size() >= 1);\n        return accessRecur(0,node.getIndicies(),arrIR);\n    }\n//\n\n    @Override\n    public IRStmt visit(Block node) {\n        ArrayList<Stmt> statements = node.getStatementList();\n        ArrayList<IRStmt> IRstmtList = new ArrayList<>();\n        for (Stmt stmt: statements) {\n            IRstmtList.add(stmt.accept(this));\n        }\n        return new IRSeq(IRstmtList);\n    }\n\n    @Override\n    public IRStmt visit(IfElse node) {\n        IRStmt iFStatement = node.getIfState().accept(this);\n        IRStmt elseStatement = node.getElseState().accept(this);\n        String lt = nxtLabel();\n        String lf = nxtLabel();\n        String lafter = nxtLabel();\n        IRStmt condStmt = booleanAsControlFlow(node.getGuard(),lt,lf);\n        IRJump endJmp = new IRJump(new IRName(lafter));\n        return new IRSeq(condStmt,\n                new IRLabel(lt),\n                iFStatement,\n                endJmp,\n                new IRLabel(lf),\n                elseStatement,\n                new IRLabel(lafter)\n        );\n    }\n\n    @Override\n    public IRStmt visit(IfOnly node) {\n        String l1 = nxtLabel();\n        String l2 = nxtLabel();\n        IRStmt condStmt = booleanAsControlFlow(node.guard,l1,l2);\n        IRStmt statement = node.ifState.accept(this);\n        return new IRSeq(condStmt,new IRLabel(l1),statement, new IRLabel(l2));\n    }\n\n    @Override\n    public IRStmt visit(ProcedureCall node) {\n        IRName func = new IRName(genABIFunc(node.getFunctionSig(),node.getIdentifier()));\n        ArrayList<IRExpr> paramListIR = new ArrayList<>();\n        for (Expr param: node.getParamList()){\n            paramListIR.add(param.accept(this));\n        }\n        return new IRCallStmt(func,1L,paramListIR);\n    }\n\n    @Override\n    public IRStmt visit(Return node) {\n        ArrayList<Expr> retList = node.getReturnArgList();\n        ArrayList<IRExpr> IRRet = new ArrayList<>();\n        for (Expr ret: retList){\n            IRRet.add(ret.accept(this));\n        }\n        return new IRReturn(IRRet);\n    }\n    @Override\n    public IRStmt visit(While node) {\n        String lh = nxtLabel();\n        String l1 = nxtLabel();\n        String le = nxtLabel();\n        IRStmt condStmt = booleanAsControlFlow(node.getGuard(),l1,le);\n        IRStmt bodyStmt = node.getStmt().accept(this);\n        return new IRSeq(\n                new IRLabel(lh),\n                condStmt,\n                new IRLabel(l1),\n                bodyStmt,\n                new IRJump(new IRName(lh)),\n                new IRLabel(le));\n    }\n    @Override\n    public IRStmt visit(DeclAssignStmt node) {\n//        if (node.getDecl() instanceof UnderScore){\n//        }\n        // might need to do call stmt\n        IRExpr right = node.getExpression().accept(this);\n        IRExpr exec = node.getExpression() instanceof FunctionCallExpr ?\n                new IRESeq(new IRExp(right),new IRTemp(\"_RV1\")): right;\n\n        if (node.getDecl() instanceof AnnotatedTypeDecl atd){\n            if (atd.type.isArray()){\n                if (atd.type.dimensions.allEmpty){ // random init is fine\n                    return new IRMove(new IRTemp(atd.identifier.toString()),exec);\n                }else{\n                    IRExpr iden = atd.getIdentifier().accept(this); // x:int[e1][e2][e3]\n                    return initArrayDecl(0,atd.type.dimensions,iden); // passed in temp x\n//                    throw new InternalCompilerError(\"Gotta create init array malloc thing\");\n                }\n            }else if (atd.type.isBasic()){\n                return new IRMove(new IRTemp(atd.identifier.toString()),exec);\n            }\n            throw new InternalCompilerError(\"Annotated can only be array or basic\");\n        }else if (node.getDecl() instanceof ArrAccessDecl aad){\n            assert(aad.getIndices().size() >= 1);\n            if (aad.getFuncParams() ==  null){ // a[e1][e2]\n                IRExpr arrIdIR = aad.getIdentifier().accept(this);\n                IRExpr memComponent = accessRecur(0,aad.getIndices(), arrIdIR);\n                return new IRMove(memComponent,exec);\n            }else{ // g1(e1,e2)[4][5]\n                String funcName = genABIFunc(aad.getFunctionSig(),aad.getIdentifier());\n                ArrayList<IRExpr> argsList = new ArrayList<>();\n                for (Expr param: aad.getFuncParams()){\n                    argsList.add(param.accept(this));\n                }\n                IRCallStmt funcCall = new IRCallStmt(new IRName(funcName),1L,argsList);\n                IRESeq sideEffects = new IRESeq(funcCall, new IRTemp(\"_RV1\"));\n                IRExpr memComponent = accessRecur(0,aad.getIndices(), sideEffects);\n                return new IRMove(memComponent,exec);\n            }// find a[e1][e2]\n        }else if (node.getDecl() instanceof NoTypeDecl){\n            return new IRMove(node.getDecl().identifier.accept(this),exec);\n        }else if (node.getDecl() instanceof UnderScore){\n            return new IRExp(exec);\n        }\n        throw new InternalCompilerError(\"NOT A DECL?\");\n    }\n\n    @Override\n    public IRStmt visit(DeclNoAssignStmt node) {\n        if (!(node.getDecl() instanceof AnnotatedTypeDecl atd)){\n            throw new InternalCompilerError(\"no assign can only be annotated\");\n        }\n        return atd.accept(this);\n        //Annotated Type Decl\n\n        // ArrAccessDecl Can't\n\n        // No Type Decl  Can't\n\n        // UnderScore Can't\n    }\n\n    @Override\n    public IRStmt visit(MultiDeclAssignStmt node) {\n        List<IRExpr> right = node.getExpressions().stream().map(expr -> expr.accept(this)).toList();\n        ArrayList<Expr> exprs = node.getExpressions();\n        ArrayList<IRStmt> order =new ArrayList<>();\n        ArrayList<String> tempNames = new ArrayList<>();\n        if (exprs.get(0) instanceof FunctionCallExpr) {\n            assert (right.size() == 1);\n            order.add(new IRExp(right.get(0)));\n            for (int i = 0; i < node.getDecls().size(); i++) {\n                String tempName = nxtTemp();\n                IRMove curMove = new IRMove(new IRTemp(tempName), new IRTemp(\"_RV\" + (i + 1)));\n                order.add(curMove);\n                tempNames.add(tempName);\n            }\n        }else{\n            for (int i = 0; i< node.getDecls().size();i++){\n                IRExpr e = right.get(i);\n                String tempName = nxtTemp();\n                IRMove curMove = new IRMove(new IRTemp(tempName),e);\n                order.add(curMove);\n                tempNames.add(tempName);\n            }\n        }\n        for (int i = 0 ;i< node.getDecls().size();i++){ // need to check if global VAR\n            String curTemp = tempNames.get(i);\n            Decl d = node.getDecls().get(i);\n            if (d instanceof AnnotatedTypeDecl atd){\n                if (atd.type.isArray()){\n                    if (atd.type.dimensions.allEmpty){ // random init is fine\n                        order.add(new IRMove(new IRTemp(atd.identifier.toString()), new IRTemp(curTemp)));\n                    }else{\n                        IRExpr iden = atd.getIdentifier().accept(this); // x:int[e1][e2][e3]\n                        order.add(initArrayDecl(0,atd.type.dimensions,iden)); // passed in temp x\n//                            throw new InternalCompilerError(\"Gotta create init array malloc thing\");\n                    }\n                }else if (atd.type.isBasic()){\n                    order.add(new IRMove(new IRTemp(atd.identifier.toString()),new IRTemp(curTemp)));\n                }else {\n                    throw new InternalCompilerError(\"Annotated can only be array or basic\");\n                }\n            }else if (d instanceof ArrAccessDecl aad){\n                assert(aad.getIndices().size() >= 1);\n                if (aad.getFuncParams() ==  null){ // a[e1][e2]\n                    IRExpr arrIdIR = aad.getIdentifier().accept(this);\n                    IRExpr memComponent = accessRecur(0,aad.getIndices(), arrIdIR);\n                    order.add (new IRMove(memComponent,new IRTemp(curTemp)));\n                }else{ // g1(e1,e2)[4][5]\n                    String funcName = genABIFunc(aad.getFunctionSig(),aad.getIdentifier());\n                    ArrayList<IRExpr> argsList = new ArrayList<>();\n                    for (Expr param: aad.getFuncParams()){\n                        argsList.add(param.accept(this));\n                    }\n                    IRCallStmt funcCall = new IRCallStmt(new IRName(funcName),1L,argsList);\n                    IRESeq sideEffects = new IRESeq(funcCall, new IRTemp(\"_RV1\"));\n                    IRExpr memComponent = accessRecur(0,aad.getIndices(), sideEffects);\n                    order.add(new IRMove(memComponent,new IRTemp(curTemp)));\n                }// find a[e1][e2]\n            }else if (d instanceof NoTypeDecl){\n                order.add(new IRMove(d.identifier.accept(this),new IRTemp(curTemp))); // might need to check for Globals\n            }else if (d instanceof UnderScore){\n                order.add(new IRExp(new IRTemp(curTemp)));\n            }else {\n                throw new InternalCompilerError(\"NOT A DECL?\");\n            }\n        }\n        return new IRSeq(order);\n    }\n\n    @Override\n    public IRStmt visit(Globdecl node) { // going have to be IRDATA\n        // Don't visit create function that adds to Global MAP\n        return null;\n    }\n\n    @Override\n    public IRFuncDecl visit(Method node) {\n        ArrayList<IRStmt> stmtList = new ArrayList<>();\n        // MOVE ARGS INTO PARAMS\n        for (int i = 0;i < node.getDecls().size();i++){\n            AnnotatedTypeDecl atd = node.getDecls().get(i);\n            stmtList.add(new IRMove(new IRTemp(atd.identifier.toString()),new IRTemp(\"_ARG\" + (i+1))));\n        }\n\n        // EXECUTE BLOCK\n        stmtList.add(node.getBlock().accept(this)); // might need to move return inside\n        // ADD RET IF NEEDED\n        if (node.getBlock().getNodeType().getType() == Type.TypeCheckingType.UNIT){\n            stmtList.add(new IRReturn());\n        }\n\n        String abiName = genABIFunc(node.getFunctionSig(), node.getId());\n        // CREATE NODE\n        IRFuncDecl ret =  new IRFuncDecl(abiName, new IRSeq(stmtList));\n        ret.functionSig = node.getFunctionSig();\n        return ret;\n    }\n\n    @Override\n    public IRStmt visit(MultiGlobalDecl node) {\n    // Don't visit create function that adds to Global MAP\n        return null;\n    }\n\n    @Override // Visit only on No Assign\n    public IRStmt visit(AnnotatedTypeDecl node) { // could be IREXPR\n        if (node.type.isArray()){\n            if (node.type.dimensions.allEmpty){ // random init is fine\n                return new IRMove(new IRTemp(node.identifier.toString()),new IRConst(0));\n            }else{\n                IRExpr iden = node.getIdentifier().accept(this); // x:int[e1][e2][e3]\n                return initArrayDecl(0, node.type.dimensions,iden); // passed in temp x\n            }\n        }else if (node.type.isBasic()){\n            return new IRMove(new IRTemp(node.identifier.toString()),new IRConst(0));\n        }\n        throw new InternalCompilerError(\"Annotated can only be array or basic\");\n    }\n\n    @Override\n    public IRExpr visit(ArrAccessDecl node) {// no need to visit\n        return null;\n    }\n\n    @Override\n    public IRExpr visit(NoTypeDecl node) {// no need to visit\n        return new IRTemp(node.getIdentifier().toString());\n    }\n\n    @Override\n    public IRExpr visit(UnderScore node) {// no need to visit\n        return new IRTemp(\"_\");\n    }\n\n    @Override\n    public IRStmt visit(Use node) { // no need to visit\n        return null;\n    }\n\n    @Override\n    public IRCompUnit visit(Program node) {\n\n        // Arun TODO\n        // Create  Comp Unit\n        IRCompUnit compUnit = new IRCompUnit(compUnitName);\n        globalIds = node.getGlobalsID();\n        node.getDefinitions().forEach(definition -> {\n            // Add Single Global Decls to the DATA MAP USE FUNC BELOW\n            if (definition instanceof Globdecl) {\n                compUnit.appendData(initSingleGlobal((Globdecl) definition));\n\n            }\n            // Add multi global decls to the DATA map use the Func Below\n            else if (definition instanceof MultiGlobalDecl) {\n                initMultiGlobal((MultiGlobalDecl) definition).forEach(compUnit::appendData);\n            }\n            // Add Function Decls and Name\n            else if (definition instanceof Method) {\n                compUnit.appendFunc(((Method) definition).accept(this));\n            }\n        });\n\n        for (IRData ird: string_consts){\n            compUnit.appendData(ird);\n        }\n\n        // Return Comp Unit\n\n        return compUnit;\n    }\n\n    private IRStmt booleanAsControlFlow(Expr e, String lt, String lf) {\n        if (e instanceof BoolLiteral) { // C[true/false, t, f]  = JUMP(NAME(t/f))\n            boolean val = ((BoolLiteral) e).boolVal;\n            return new IRJump(new IRName(val ? lt : lf));\n        } else if (e instanceof AndBinop){ // C[e1 & e2, t, f]  = SEQ(C[e1,l1,f],l1,C[e2,t,f])\n            Expr e1 = ((AndBinop) e).getLeftExpr();\n            Expr e2 = ((AndBinop) e).getRightExpr();\n            String l1 = nxtLabel();\n            IRStmt first = booleanAsControlFlow(e1,l1,lf);\n            IRStmt second = booleanAsControlFlow(e2,lt,lf);\n            return new IRSeq(first,new IRLabel(l1),second);\n        }else if (e instanceof OrBinop){ // C[e1 | e2, t, f]  = SEQ(C[e1,t,l1],l1,C[e2,t,f])\n            Expr e1 = ((OrBinop) e).getLeftExpr();\n            Expr e2 = ((OrBinop) e).getRightExpr();\n            String l1 = nxtLabel();\n            IRStmt first = booleanAsControlFlow(e1,lt,l1);\n            IRStmt second = booleanAsControlFlow(e2,lt,lf);\n            return new IRSeq(first,new IRLabel(l1),second);\n        }else if (e instanceof NotUnop){ // C[!e, t, f]  = C[e, f, t]\n            return booleanAsControlFlow(e,lf,lt);\n        }\n        IRExpr cond = e.accept(this);         // C[e, t, f]  = CJUMP(E[e], t, f)\n        return new IRCJump(cond, lt, lf);\n    }\n\n    private String genABIFunc(Type funcType, Id funcName){\n        if (funcType.getType() != Type.TypeCheckingType.FUNC){\n            throw new Error(\"HOW ARE WE HERE\");\n        }\n        String replaceName = funcName.toString().replaceAll(\"_\",\"__\");\n        String inputABIName = genABIArr(funcType.inputTypes,true);\n        String outputABIName = genABIArr(funcType.outputTypes,false);\n        return \"_I\" + replaceName +\"_\"+ outputABIName + inputABIName;\n    }\n    private String genABIArr(ArrayList<Type> arrTypes, boolean isInput){\n        if (arrTypes.size() == 0){\n            return isInput ? \"\": \"p\";\n        }\n        else if (arrTypes.size() == 1){\n            return genABIType(arrTypes.get(0));\n        }else{\n            StringBuilder temp = new StringBuilder(isInput ? \"\" : \"t\" + arrTypes.size());\n            for (Type t: arrTypes){\n                temp.append(genABIType(t));\n            }\n            return temp.toString();\n        }\n    }\n    private String genABIType(Type t){\n        if (t.isBasic()){\n            return (t.getType() == Type.TypeCheckingType.INT) ? \"i\": \"b\";\n        }else if (t.isArray()){\n            StringBuilder build = new StringBuilder();\n            for (int i = 0 ; i< t.dimensions.getDim();i++){\n                build.append(\"a\");\n            }\n            build.append((t.getType() == Type.TypeCheckingType.INTARRAY) ? \"i\":\"b\");\n            return build.toString();\n        }else{\n            throw new Error(\"WE SHOULD NOT BE IN GENTYPE\");\n        }\n    }\n    private IRStmt initArrayDecl(int ind, Dimension d, IRExpr curHead){ // this is for a:int[4][3][] etc\n        // a:int[e1][e2][][]\n        if (ind == d.getDim() || d.getIndices().get(ind) == null){\n//            System.out.println(ind);\n//            System.out.println(d.getDim());\n//            System.out.println(ind == d.getDim());\n//            System.out.println(\"here\");\n            return new IRMove(curHead,new IRConst(0)); // base case x: int[] x <- random val\n        }\n\n        Expr curExp = d.getIndices().get(ind);\n        IRExpr irExp = curExp.accept(this);\n\n        String tn = nxtTemp();\n        String tm = nxtTemp();\n\n        // reg[l] <- length\n        IRMove length_to_l1 = new IRMove(new IRTemp(tn), irExp);\n\n        // 8*n+8\n        IRBinOp size1 = new IRBinOp(IRBinOp.OpType.ADD,\n                new IRBinOp(IRBinOp.OpType.MUL,\n                        new IRTemp(tn),\n                        new IRConst(WORD_BYTES)),\n                new IRConst(WORD_BYTES));\n\n        // call alloc and move RV1 into val\n        IRCallStmt alloc_call1 = new IRCallStmt(new IRName(\"_eta_alloc\"),1L, size1);\n        IRSeq malloc_move1 = new IRSeq(alloc_call1,new IRMove(new IRTemp(tm), new IRTemp(\"_RV1\")));\n\n        // move len into -1\n        IRMove move_len = new IRMove(new IRMem(new IRTemp(tm)),new IRTemp(tn));\n\n        // increment pointer to head\n        IRBinOp add_8 = new IRBinOp(IRBinOp.OpType.ADD,new IRTemp(tm), new IRConst(WORD_BYTES));\n        IRMove inc_pointer_to_head = new IRMove(curHead,add_8);\n        // do all the top level shit first\n        IRSeq top_level_Order = new IRSeq(length_to_l1,malloc_move1,move_len,inc_pointer_to_head);\n\n\n        // now time to recrusively alloc\n        String lh = nxtLabel();\n        String l1 = nxtLabel();\n        String le = nxtLabel();\n        String counter = nxtTemp();\n        IRBinOp guard = new IRBinOp(IRBinOp.OpType.LT,new IRTemp(counter), irExp);\n        // set counter = 0;\n        IRMove set0Coutner = new IRMove(new IRTemp(counter), new IRConst(0));\n        IRLabel whileHead = new IRLabel(lh);\n        // check if counter < irExp\n        IRCJump loopCheck = new IRCJump(guard,l1,le);\n        IRLabel whileBody = new IRLabel(l1);\n        // create memory location for head of new array\n        IRMem memHead = new IRMem(new IRBinOp(IRBinOp.OpType.ADD,\n                curHead,\n                new IRBinOp(IRBinOp.OpType.MUL,\n                    new IRTemp(counter),\n                    new IRConst(WORD_BYTES))));\n        // if we were at int[4][5] we now are in the \"5\" after recur executes after 5 it will be in \"nothing\" which means base case\n        IRStmt recur = initArrayDecl(ind+1, d, memHead);\n        // increment counter\n        IRMove inc = new IRMove(new IRTemp(counter),new IRBinOp(IRBinOp.OpType.ADD,new IRTemp(counter), new IRConst(1)));\n        // jump back to loop head\n        IRJump go_back_to_head = new IRJump(new IRName(lh));\n        IRLabel afterLoop = new IRLabel(le);\n\n        IRSeq loopComponent = new IRSeq(set0Coutner,whileHead,loopCheck,whileBody,recur,inc,go_back_to_head,afterLoop);\n\n        return new IRSeq(top_level_Order,loopComponent);\n        // malloc 4\n\n        // for each of those Elements Recursively\n\n\n        // Create IR STMT recursively\n\n        // Malloc Then Move\n\n        // Go through all elements and Malloc and Move Again\n\n    }\n\n    private IRData initSingleGlobal(Globdecl node){\n        Expr e = node.getValue();\n        AnnotatedTypeDecl d = node.getDecl();\n        IRData irdata;\n        long[] data;\n        String name = \"_\" + d.getIdentifier();\n\n        if (e == null) {\n            irdata = new IRData(name, new long[]{});\n            return irdata;\n        }\n\n        if (e.getNodeType().getType() == Type.TypeCheckingType.INT) {\n            data = new long[]{((IntLiteral) e).getLong()};\n            irdata = new IRData(name, data);\n        } else if (e.getNodeType().getType() == Type.TypeCheckingType.BOOL) {\n            boolean b = ((BoolLiteral) e).getBoolVal();\n            if (b) {\n                data = new long[]{1};\n            } else {\n                data = new long[]{0};\n            }\n            irdata = new IRData(name, data);\n        } else {\n            throw new InternalCompilerError(\"Unable to global assign this type.\");\n        }\n        return irdata;\n        // Check if right side is null or not for initalized Value\n        // FOLLOW ABI For Naming Conventions\n        // Put Data into Single Global Decl\n        // Return IR DATA\n    }\n\n    private ArrayList<IRData> initMultiGlobal(MultiGlobalDecl node){\n\n        // Make sure each one lines up correctly\n\n        // FOLLOW ABI For Naming Conventions\n\n        // PUT DATA INTO Building GLOBAL DECLS\n\n        // Return Multiple Global Decls\n\n        // HELP ANGELA After finishing This.\n\n        ArrayList<AnnotatedTypeDecl> decls = node.getDecls();\n        ArrayList<Expr> exprs = node.getExpressions();\n\n        ArrayList<IRData> irDataList = new ArrayList<>(decls.size());\n        for (int i = 0; i < decls.size(); i++) {\n            Globdecl glob = new Globdecl(decls.get(i), exprs.get(i), -1 ,-1);\n            irDataList.set(i, initSingleGlobal(glob));\n        }\n\n        return irDataList;\n    }\n    private IRExpr accessRecur(int ind, ArrayList<Expr> indexes, IRExpr expr) {\n        if (ind == indexes.size()) {\n            return expr;\n        }\n        IRExpr curInd = indexes.get(ind).accept(this);\n        String ta = nxtTemp();\n        String ti = nxtTemp();\n        String lok = nxtLabel();\n        String ler = nxtLabel();\n        IRESeq sol = new IRESeq( // 1d array need loop for further\n                new IRSeq(\n                        new IRMove(new IRTemp(ta), expr),\n                        new IRMove(new IRTemp(ti), curInd),\n                        new IRCJump(\n                                new IRBinOp(IRBinOp.OpType.ULT,\n                                        new IRTemp(ti),\n                                        new IRMem(\n                                                new IRBinOp(IRBinOp.OpType.SUB,\n                                                        new IRTemp(ta),\n                                                        new IRConst(8)))),\n                                lok,ler),\n                        new IRLabel(ler),\n                        new IRCallStmt(new IRName(OUT_OF_BOUNDS), 0L,new ArrayList<>()),\n                        new IRLabel(lok)),\n                new IRMem(\n                        new IRBinOp(IRBinOp.OpType.ADD,\n                                new IRTemp(ta),\n                                new IRBinOp(IRBinOp.OpType.MUL,new IRTemp(ti),new IRConst(8))\n                        )));\n        return accessRecur(ind + 1, indexes, sol);\n    }\n\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/aar226_akc55_ayc62_ahl88/visitors/IRVisitor.java b/src/main/java/aar226_akc55_ayc62_ahl88/visitors/IRVisitor.java
--- a/src/main/java/aar226_akc55_ayc62_ahl88/visitors/IRVisitor.java	(revision 708b6e4f0ea4fdfd9cb521cd536275eab8f78599)
+++ b/src/main/java/aar226_akc55_ayc62_ahl88/visitors/IRVisitor.java	(date 1678889937191)
@@ -967,7 +967,8 @@
                                 lok,ler),
                         new IRLabel(ler),
                         new IRCallStmt(new IRName(OUT_OF_BOUNDS), 0L,new ArrayList<>()),
-                        new IRLabel(lok)),
+                        new IRLabel(lok)
+                ),
                 new IRMem(
                         new IRBinOp(IRBinOp.OpType.ADD,
                                 new IRTemp(ta),
