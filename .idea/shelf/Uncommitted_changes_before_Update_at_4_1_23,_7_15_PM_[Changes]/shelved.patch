Index: src/main/java/aar226_akc55_ayc62_ahl88/src/edu/cornell/cs/cs4120/xic/ir/visit/ASMVisitor.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package aar226_akc55_ayc62_ahl88.src.edu.cornell.cs.cs4120.xic.ir.visit;\n\nimport aar226_akc55_ayc62_ahl88.asm.*;\nimport aar226_akc55_ayc62_ahl88.asm.Expressions.*;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.ASMArg2;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.ASMInstruction;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.ASMLabel;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.jumps.ASMJumpNotEqual;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.mov.ASMMov;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.mov.ASMMovabs;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.stackops.ASMPush;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.subroutine.ASMEnter;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.subroutine.ASMLeave;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.subroutine.ASMRet;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.tstcmp.ASMTest;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.jumps.ASMJumpAlways;\nimport aar226_akc55_ayc62_ahl88.src.edu.cornell.cs.cs4120.xic.ir.*;\nimport aar226_akc55_ayc62_ahl88.src.polyglot.util.InternalCompilerError;\n\nimport java.util.ArrayList;\nimport java.util.HashSet;\n\n/**\n * NOTES:\n * - branches: use cmp then corresponding jump\n * - multireturn: store first argument in rax, push rest on stack\n * - function args: rdi, rsi, rdx, rcx, r8, r9, push rest on stack\n * - callee saved: rbx, rbp, and r12â€“r15\n * - caller saved: everything else\n *\n * THINGS WE NEEEEEEEEEEEDDDDDDDDD\n * - ir compunit ->\n *      add glob mem locations\n *      call visit to all functions\n * - ir func decl ->\n *      create new label at the top for function name\n *      follow abi for args and register alloc\n *      call visit on each statement\n *      flatten arraylist we get back\n *      follow abi for correct func exit\n * - jump -> jr <label name>\n * - cjump ->\n *      two args: cmp <t1> <t2>; j<flag> <label name>\n *      if instance of IRConst and is boolliteral: true -> jr / false -> nothing\n * - move ->\n *      mooooooooooooove\n *      contains expr: used for dynamic tiling\n *      tiling\n * - mem\n * - binop\n * - call stmt ->\n *      init function call follow abi for function call (store func args correctly)\n *      jump to function\n *      clean accroding to ABI spec (be careful about multireturns and stack dead space)\n *      pop from function\n * - IR Label -> ASM label\n *\n *\n * Generic ASM Class will be called ASMNode\n */\n\npublic class ASMVisitor {\n    private int tempCnt;\n\n\n    private String nxtTemp() {\n        return String.format(\"_ASMReg_t%d\", (tempCnt++));\n    }\n    private ASMDirectives getType(String name) {\n        String type = name.split(\"_\")[0];\n        if (type.equals(\"i\") || type.equals(\"b\")) {\n            return ASMDirectives.QUAD;\n        }\n        return ASMDirectives.ZERO;\n    }\n    // converts an IR TEMP to an ASM TEMP\n    private ASMTempExpr tempToASM(IRTemp t) {\n        return new ASMTempExpr(t.name());\n    }\n    // change te parameters if needed\n    private ArrayList<ASMInstruction> cJumpBinop(IRBinOp binop){\n        ArrayList<ASMInstruction> instructions = new ArrayList<ASMInstruction>();\n//        switch (binop.opType()) {\n//            case EQ:\n//            case NEQ:\n//            case LT:\n//            case ULT:\n//            case GT:\n//            case LEQ:\n//            case GEQ:\n////                ASMArg2 instr1 = new ASMCmp(binop.left(), binop.right());\n//\n//        }\n        return instructions;\n    }\n    public ArrayList<ASMInstruction> visit(IRCallStmt node){\n        return null;\n    }\n    public ArrayList<ASMInstruction> visit(IRData node){\n        ArrayList<ASMInstruction> instructions = new ArrayList<ASMInstruction>();\n\n        return instructions;\n    }\n    public ArrayList<ASMInstruction> visit(IRCJump node) {\n        ArrayList<ASMInstruction> instructions = new ArrayList<ASMInstruction>();\n\n        IRExpr condition = node.cond();\n\n        if (condition instanceof IRBinOp c) {\n            // create function for IRBINOP\n            // DO A CMP instead\n            return cJumpBinop(c);\n        } else if (condition instanceof IRConst c) {\n            if (c.value() != 0L){ // jump\n                instructions.add(new ASMJumpAlways(new ASMNameExpr(node.trueLabel())));\n            }\n        } else if (condition instanceof IRTemp c) {\n            ASMTempExpr tempName = tempToASM(c);\n            instructions.add(new ASMTest(tempName,tempName));\n            instructions.add(new ASMJumpNotEqual(new ASMNameExpr(node.trueLabel())));\n            //test t, t\n            //jnz l\n        } else if (condition instanceof IRMem c) {\n            ASMTempExpr tempForMem = new ASMTempExpr(nxtTemp());\n            // accept mem for this temp\n            // add move instruction\n            // do temp test and ASM Jump no Equal\n            return null;\n        }else{\n            throw new InternalCompilerError(\"CJUMP guard has another type\");\n        }\n        return instructions;\n    }\n    public ArrayList<ASMInstruction> visit(IRCompUnit node) {\n        ArrayList<ASMInstruction> instructions = new ArrayList<ASMInstruction>();\n\n        for (IRData data : node.dataMap().values()) {\n            ASMLabel data_label = new ASMLabel(data.name());\n//            ASMData data_instr = new ASMData(getType(data.name()), new ASMConstExpr(data.data()));\n        }\n\n        for (IRFuncDecl func : node.functions().values()) {\n            instructions.addAll(visit(func));\n        }\n\n        return instructions;\n    }\n    public ArrayList<ASMInstruction> visit (IRConst x) {\n        ArrayList<ASMInstruction> instructions = new ArrayList<ASMInstruction>();\n        boolean isInt = x.value() <= Integer.MAX_VALUE && x.value() >= Integer.MIN_VALUE;\n        ASMArg2 instruction = (isInt) ? new ASMMov(new ASMTempExpr(nxtTemp()),new ASMConstExpr(x.value()))\n                : new ASMMovabs(new ASMTempExpr(nxtTemp()),new ASMConstExpr(x.value()));\n        instructions.add(instruction);\n        return instructions;\n    }\n    public ArrayList<ASMInstruction> visit(IRFuncDecl node) {\n        ArrayList<ASMInstruction> result = new ArrayList<>();\n\n        // create new Starting label for this Function\n        result.add(new ASMLabel(node.name()));\n\n//        enter at Botoom\n//        push rbp\n//        mov rbp rsp\n//        sub rsp, 8*l\n//        result.add(new ASMPush(new ASMRegisterExpr(\"rbp\")));\n//        result.add(new ASMMov(new ASMRegisterExpr(\"rbp\"),new ASMRegisterExpr(\"rsp\")));\n\n        // need to calculate number of temporaries used\n        HashSet<String> asmTempNames = new HashSet<>();\n\n\n        // foo(1,2,3,4,5,6,7....) -> rdi, rsi, rdx, rcx, r8, r9, stack\n        int numParams = node.functionSig.inputTypes.size();\n        int numReturns = node.functionSig.outputTypes.size();\n        ArrayList<ASMInstruction> bodyInstructions = new ArrayList<>();\n\n        if (numReturns > 2){\n            asmTempNames.add(\"_ARG0\");\n            bodyInstructions.add(new ASMMov(\n                    new ASMTempExpr(\"_ARG0\"),\n                    new ASMRegisterExpr(\"rdi\")\n            ));\n        }\n\n        int start = numReturns > 2 ? 2: 1;\n        int end   = numParams > 2 ? numParams +1: numParams;\n        for (int i = start; i<=end;i++){\n\n            // Move arg into argI. argI <- RDI\n            ASMExpr ARGI = switch (i) {\n                case 1 -> new ASMRegisterExpr(\"rdi\");\n                case 2 -> new ASMRegisterExpr(\"rsi\");\n                case 3 -> new ASMRegisterExpr(\"rdx\");\n                case 4 -> new ASMRegisterExpr(\"rcx\");\n                case 5 -> new ASMRegisterExpr(\"r8\");\n                case 6 -> new ASMRegisterExpr(\"r9\");\n                default ->\n                        new ASMMemExpr(\n                                new ASMBinOpAddExpr(\n                                        new ASMRegisterExpr(\"rbp\"),\n                                        new ASMConstExpr(8L * (i - 7 + 2))));\n            };\n            String tempName = \"_ARG\" + i;\n            asmTempNames.add(tempName);\n            // can't do [stack location] <- [stack location2]\n            // need intermediate rax <- [stack location2]\n            // then [stack location] <- temp rax\n            if (i>=7){\n                bodyInstructions.add(new ASMMov(new ASMRegisterExpr(\"rax\"),ARGI));\n                bodyInstructions.add(new ASMMov(new ASMTempExpr(tempName),new ASMRegisterExpr(\"rax\")));\n            }\n            // just do MOV [stack location] <- register\n            else{\n                bodyInstructions.add(new ASMMov(new ASMTempExpr(tempName),ARGI));\n            }\n        }\n        if (node.body() instanceof  IRSeq seq){\n            for (IRStmt stmt: seq.stmts()){\n                bodyInstructions.addAll(stmt.accept(this,asmTempNames));\n            }\n        }else{\n            throw new InternalCompilerError(\"body isn't a seq\");\n        }\n        // add enter at begin.\n        // enter 8*L, 0\n        ASMEnter begin = new ASMEnter(new ASMConstExpr(8L*asmTempNames.size()),new ASMConstExpr(0));\n        bodyInstructions.add(0,begin);\n        return bodyInstructions;\n    }\n    public ArrayList<ASMInstruction> visit(IRJump jump) {\n        ArrayList<ASMInstruction> instructions = new ArrayList<ASMInstruction>();\n        if (jump.target() instanceof IRName) {\n            instructions.add(new ASMJumpAlways(new ASMNameExpr(jump.label())));\n        }\n        return instructions;\n    }\n    public ArrayList<ASMInstruction> visit(IRLabel node) {\n        ArrayList<ASMInstruction> instructions = new ArrayList<ASMInstruction>();\n        instructions.add(new ASMLabel(node.name()));\n        return instructions;\n    }\n    public ArrayList<ASMInstruction> visit(IRMove node){\n        return null;\n    }\n\n    public ArrayList<ASMInstruction> visit(IRSeq node, HashSet<String> hset){\n        ArrayList<ASMInstruction> instructions = new ArrayList<ASMInstruction>();\n        for (IRStmt stmt : node.stmts()) {\n            ArrayList<ASMInstruction> stmtInstrs = stmt.accept(this, hset);\n            instructions.addAll(stmtInstrs);\n        }\n        return instructions;\n    }\n    public ArrayList<ASMInstruction> visit(IRReturn node, HashSet<String> hset) {\n        //\n        ArrayList<ASMInstruction> returnInstructions = new ArrayList<>();\n        int returnSize = node.rets().size();\n        for (int i = 1; i <= returnSize; i++) {\n            //\n            // execute expression\n            // move expression to Return Location\n        }\n\n        // leave\n        // ret\n        returnInstructions.add(new ASMLeave());\n        returnInstructions.add(new ASMRet());\n        return returnInstructions;\n    }\n\n    // TODO: 4/1/2023\n    // move\n    // TODO: 4/1/2023\n    // temp\n    // TODO: 4/1/2023\n    // seq\n    // TODO: 4/1/2023\n    // mem\n    // TODO: 4/1/2023\n    // call_stmt\n    // TODO: 4/1/2023\n    // name\n    // TODO: 4/1/2023\n    // RETURN\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/aar226_akc55_ayc62_ahl88/src/edu/cornell/cs/cs4120/xic/ir/visit/ASMVisitor.java b/src/main/java/aar226_akc55_ayc62_ahl88/src/edu/cornell/cs/cs4120/xic/ir/visit/ASMVisitor.java
--- a/src/main/java/aar226_akc55_ayc62_ahl88/src/edu/cornell/cs/cs4120/xic/ir/visit/ASMVisitor.java	(revision 446abf03159c9411966a0f390f95d461ac25164e)
+++ b/src/main/java/aar226_akc55_ayc62_ahl88/src/edu/cornell/cs/cs4120/xic/ir/visit/ASMVisitor.java	(date 1680386110023)
@@ -256,9 +256,11 @@
         //
         ArrayList<ASMInstruction> returnInstructions = new ArrayList<>();
         int returnSize = node.rets().size();
+
         for (int i = 1; i <= returnSize; i++) {
-            //
             // execute expression
+        }
+        for (int i = 1; i <= returnSize; i++) {
             // move expression to Return Location
         }
 
