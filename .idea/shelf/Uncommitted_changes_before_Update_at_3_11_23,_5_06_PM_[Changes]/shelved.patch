Index: src/main/java/aar226_akc55_ayc62_ahl88/src/edu/cornell/cs/cs4120/xic/ir/visit/IRLoweringVisitor.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package aar226_akc55_ayc62_ahl88.src.edu.cornell.cs.cs4120.xic.ir.visit;\n\nimport aar226_akc55_ayc62_ahl88.src.edu.cornell.cs.cs4120.xic.ir.*;\n\npublic class IRLoweringVisitor extends IRVisitor {\n    private static final int WORD_BYTES = 8;\n    private static final String OUT_OF_BOUNDS = \"_xi_out_of_bounds\";\n    private int labelCnt;\n    private int tempCnt;\n    private String nxtLabel() {\n        return String.format(\"l%d\", (labelCnt++));\n    }\n\n    private String nxtTemp() {\n        return String.format(\"t%d\", (tempCnt++));\n    }\n    public IRLoweringVisitor (IRNodeFactory inf) {\n        super(inf);\n        labelCnt = 0;\n        tempCnt = 0;\n    }\n\n    private class BasicBlock {} // Need to think about what to add\n\n    @Override\n    protected IRNode leave(IRNode parent, IRNode n, IRNode n_, IRVisitor v_) {\n        if (n_ instanceof IRBinOp irbin) return canon(irbin);\n        if (n_ instanceof IRCall irc) return canon(irc);\n        if (n_ instanceof IRCallStmt ircstmt) return canon(ircstmt);\n        if (n_ instanceof IRCJump ircj) return canon(ircj);\n        if (n_ instanceof IRCompUnit icu) return canon(icu);\n        if (n_ instanceof IRConst ic) return canon(ic);\n        if (n_ instanceof IRESeq ireseq) return canon(ireseq);\n        if (n_ instanceof IRExp irexp) return  canon(irexp);\n        if (n_ instanceof IRFuncDecl irfunc) return canon(irfunc);\n        if (n_ instanceof IRJump irj) return canon(irj);\n        if (n_ instanceof IRLabel irl) return canon(irl);\n        if (n_ instanceof IRMem irmem) return canon(irmem);\n        if (n_ instanceof IRMove irmove) return canon(irmove);\n        if (n_ instanceof IRName irname) return canon(irname);\n        if (n_ instanceof IRReturn irret) return canon(irret);\n        if (n_ instanceof IRSeq irseq) return canon(irseq);\n        if (n_ instanceof IRTemp irtem) return canon(irtem);\n\n        throw new Error(\"Why is node not found\");\n    }\n\n\n    // Lower each statment then flatten all sequences\n    private IRNode canon(IRSeq node) {\n        return node;\n    }\n\n    // Lower each return expressions then add Return\n    private IRNode canon(IRReturn node) {\n        return node;\n    }\n\n    // Lower Move be very careful look at slides\n    private IRNode canon(IRMove node) {\n        return node;\n    }\n\n    // Create Basic Blocks And reorder all the body\n    private IRNode canon(IRFuncDecl node) {\n        return node;\n    }\n\n\n    // Lift Statement thats it\n    private IRNode canon(IRExp node) {\n        return node;\n    }\n\n    // do nothing\n    private IRNode canon(IRCompUnit node) {\n        return node;\n    }\n\n    // Lower each Expr\n    private IRNode canon(IRCallStmt node) {\n        return node;\n    }\n    // Lower each Expr\n    private IRNode canon(IRCall node) {\n        return node;\n    }\n\n    // if commute do that otherwise do normal\n    private IRNode canon(IRBinOp node) {\n        return node;\n    }\n\n    // canonical\n    private IRNode canon(IRConst node){\n        return node;\n    }\n    // canonical\n    private IRNode canon(IRLabel node){\n        return node;\n    }\n    // canonical\n    private IRNode canon(IRName node){\n        return node;\n    }\n    // canonical\n    private IRNode canon(IRTemp node) {\n        return node;\n    }\n    // MEM\n    private IRNode canon(IRMem node){\n        if (node.expr() instanceof IRESeq ireseq){ // lift expression\n            IRStmt svec = ireseq.stmt();\n            IRExpr ire = ireseq.expr();\n        }\n        return node;\n    }\n    // Conditional Jump\n    private IRNode canon(IRCJump node){\n        return node;\n    }\n    // Jump\n    private IRNode canon(IRJump node){\n\n        return node;\n    }\n    // ESEQ\n    private IRNode canon(IRESeq node){\n        return node;\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/aar226_akc55_ayc62_ahl88/src/edu/cornell/cs/cs4120/xic/ir/visit/IRLoweringVisitor.java b/src/main/java/aar226_akc55_ayc62_ahl88/src/edu/cornell/cs/cs4120/xic/ir/visit/IRLoweringVisitor.java
--- a/src/main/java/aar226_akc55_ayc62_ahl88/src/edu/cornell/cs/cs4120/xic/ir/visit/IRLoweringVisitor.java	(revision 8ec49e7bc2a0512569e4a197071c5a27e7121063)
+++ b/src/main/java/aar226_akc55_ayc62_ahl88/src/edu/cornell/cs/cs4120/xic/ir/visit/IRLoweringVisitor.java	(date 1678571863092)
@@ -2,6 +2,8 @@
 
 import aar226_akc55_ayc62_ahl88.src.edu.cornell.cs.cs4120.xic.ir.*;
 
+import java.util.ArrayList;
+
 public class IRLoweringVisitor extends IRVisitor {
     private static final int WORD_BYTES = 8;
     private static final String OUT_OF_BOUNDS = "_xi_out_of_bounds";
@@ -48,7 +50,15 @@
 
     // Lower each statment then flatten all sequences
     private IRNode canon(IRSeq node) {
-        return node;
+        ArrayList<IRStmt> flatten = new ArrayList<>();
+        for (IRStmt stmt: node.stmts()){
+            if (stmt instanceof IRSeq seq){
+                flatten.addAll(seq.stmts());
+            }else{
+                flatten.add(stmt);
+            }
+        }
+        return new IRSeq(flatten);
     }
 
     // Lower each return expressions then add Return
Index: src/main/java/aar226_akc55_ayc62_ahl88/Main.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package aar226_akc55_ayc62_ahl88;\n\nimport aar226_akc55_ayc62_ahl88.Errors.EtaError;\nimport aar226_akc55_ayc62_ahl88.SymbolTable.SymbolTable;\nimport aar226_akc55_ayc62_ahl88.newast.AstNode;\nimport aar226_akc55_ayc62_ahl88.newast.Program;\nimport aar226_akc55_ayc62_ahl88.newast.Type;\nimport aar226_akc55_ayc62_ahl88.newast.interfaceNodes.EtiInterface;\nimport aar226_akc55_ayc62_ahl88.src.edu.cornell.cs.cs4120.xic.ir.IRCompUnit;\nimport aar226_akc55_ayc62_ahl88.src.edu.cornell.cs.cs4120.xic.ir.IRConst;\nimport aar226_akc55_ayc62_ahl88.src.edu.cornell.cs.cs4120.xic.ir.IRNode;\nimport aar226_akc55_ayc62_ahl88.src.edu.cornell.cs.cs4120.xic.ir.interpret.IRSimulator;\nimport aar226_akc55_ayc62_ahl88.visitors.IRVisitor;\nimport java_cup.runtime.Symbol;\nimport java_cup.runtime.lr_parser;\nimport org.apache.commons.cli.*;\nimport java.io.*;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\n\nimport aar226_akc55_ayc62_ahl88.src.edu.cornell.cs.cs4120.util.CodeWriterSExpPrinter;\n\npublic class Main {\n    private static String outputDirectory;\n    private static String inputDirectory;\n    public static String libpathDirectory;\n\n    private static boolean isOutputDirSpecified;\n    private static boolean isInputDirSpecified;\n    public static boolean isLibpathDirSpecified;\n\n    private static Optimizations opts;\n\n    // Write the lexed string into the corresponding file name\n    private static void writeOutput(String filename, String output, String extension) {\n        Path path = (isOutputDirSpecified)\n                        ? Paths.get(outputDirectory, filename)\n                        : Paths.get(filename);\n\n        String pathname = path.toString();\n        pathname = pathname.substring(0, pathname.length() - 3) + extension;\n//        System.out.println(pathname);\n        Path parentPath = path.getParent();\n        String dirname = (parentPath == null) ? \"\" : parentPath.toString();\n//        System.out.println(dirname);\n        // Create directory\n        File dir = new File(dirname);\n        dir.mkdirs();\n\n        // Create file\n        try {\n            File file = new File(pathname);\n            file.createNewFile();\n        }\n        catch (IOException e) {\n            System.out.println(\"An error occurred when creating the file \" + filename);\n            return;\n        }\n\n        // Write to file\n        try {\n            FileWriter myWriter = new FileWriter(pathname);\n\n            myWriter.write(output);\n            myWriter.close();\n        }\n        catch (IOException e) {\n            System.out.println(\"An error occurred when writing to the file \" + filename);\n        }\n    }\n\n    private static String prettyOut(Symbol s){\n        String out = s.value().toString();\n        switch (s.sym){\n            case (sym.INTEGER_LITERAL):\n                if (out.length() > 1){\n                    out = out.substring(1);\n                }\n                out = \"integer \" + out;\n                break;\n            case (sym.BOOL_LITERAL):\n                out = \"boolean \" + out;\n                break;\n            case (sym.IDENTIFIER):\n                out = \"id \" +  out;\n                break;\n            case (sym.CHARACTER_LITERAL):\n                out = \"character \" +  out;\n                break;\n            case (sym.STRING_LITERAL):\n                out = \"string \" + out;\n                break;\n            default:\n                break;\n        }\n        return String.format(\"%d:%d %s\\n\", s.left, s.right, out);\n    }\n\n    private static String getZhenFilename(String filename) {\n        return (isInputDirSpecified)\n                ? Paths.get(inputDirectory, filename).toString()\n                : filename;\n    }\n\n    private static void lexFile(String filename, StringBuilder lexedOutput, boolean shouldWrite) throws IOException {\n        try {\n            if (filename.endsWith(\".eta\") || filename.endsWith(\".eti\")) {\n                String zhenFilename = getZhenFilename(filename);\n\n                Lexer etaLexer;\n                try {\n                    etaLexer = new Lexer(new FileReader(zhenFilename));\n                } catch (Exception e) {\n                    System.out.println(\"File without name \" + filename + \" found\");\n                    return;\n                }\n\n                try {\n                    while (true) {\n                        Symbol t = etaLexer.next_token();\n                        if (t.sym == sym.EOF) break;\n                        String lexed = prettyOut(t);\n                        lexedOutput.append(lexed);\n                    }\n                }\n                catch (EtaError e) {\n                    lexedOutput.append(e.getMessage());\n                }\n            }\n            else {\n                throw new FileNotFoundException(\n                        \"Invalid filename \"\n                                + filename\n                                + \" provided: All files passed to etac must have a .eta extension\");\n            }\n        }\n        catch (FileNotFoundException invalidFilename) {\n            System.out.println(invalidFilename.getMessage());\n            return;\n        }\n\n        if (shouldWrite) {\n            writeOutput(filename, lexedOutput.toString(), \"lexed\");\n        }\n    }\n\n    private static void parseFile(String filename, boolean shouldWrite) throws IOException {\n        try {\n            String zhenFilename = getZhenFilename(filename);\n\n            Lexer lex;\n            try {\n                lex = new Lexer(new FileReader(zhenFilename));\n            } catch (Exception e) {\n                System.out.println(\"File without name \" + filename + \" found\");\n                return;\n            }\n\n            lr_parser p = null;\n            if (filename.endsWith(\".eta\")) p = new EtaParser(lex);\n            else if (filename.endsWith(\".eti\")) p = new EtiParser(lex);\n            else throw new FileNotFoundException(\n                        \"Invalid filename \"\n                                + filename\n                                + \" provided: All files passed to etac must have a .eta extension\");\n\n            try {\n                StringWriter out = new StringWriter();\n                PrintWriter cw = new PrintWriter(out);\n                CodeWriterSExpPrinter printer = new CodeWriterSExpPrinter(cw);\n\n                if (filename.endsWith(\".eta\")) {\n                    Program result = (Program) p.parse().value;\n                    result.prettyPrint(printer);\n                }\n                else if (filename.endsWith(\".eti\")) {\n                    EtiInterface result = (EtiInterface) p.parse().value;\n                    result.prettyPrint(printer);\n                }\n\n                printer.close();\n                if (shouldWrite) {\n                    writeOutput(filename, out.toString(), \"parsed\");\n                }\n            } catch (EtaError e) {\n                if (shouldWrite) {\n                    writeOutput(filename, e.getMessage(), \"parsed\");\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n                System.out.println(\"File without name \" + filename + \" found\");\n            }\n        }\n        catch (FileNotFoundException invalidFilename) {\n            System.out.println(invalidFilename.getMessage());\n        }\n    }\n\n    private static void typeCheckFile(String filename, boolean shouldWrite) throws IOException {\n        try {\n            String zhenFilename = getZhenFilename(filename);\n\n            Lexer lex = null;\n            try {\n                lex = new Lexer(new FileReader(zhenFilename));\n            } catch (Exception e) {\n                System.out.println(\"No file found with filename \" + filename);\n                return;\n            }\n\n            lr_parser p;\n            if (filename.endsWith(\".eta\")) p = new EtaParser(lex);\n            else if (filename.endsWith(\".eti\")) p = new EtiParser(lex);\n            else throw new FileNotFoundException(\n                        \"Invalid filename \"\n                                + filename\n                                + \" provided: All files passed to etac must have a .eta extension\");\n\n            try {\n                if (filename.endsWith(\".eta\")) {\n                    Program result = (Program) p.parse().value;\n                    result.typeCheck(new SymbolTable<>(), zhenFilename);\n                } else if (filename.endsWith(\".eti\")) {\n                    EtiInterface result = (EtiInterface) p.parse().value;\n                    result.firstPass(); // Just to throw EtaErrors\n                }\n\n                if (shouldWrite) {\n                    writeOutput(filename, \"Valid Eta Program\", \"typed\");\n                }\n            } catch (EtaError e) {\n                e.printError(zhenFilename);\n                if (shouldWrite) {\n                    writeOutput(filename, e.getMessage(), \"typed\");\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n                System.out.println(\"File without name \" + filename + \" found\");\n            }\n        }\n        catch (FileNotFoundException invalidFilename) {\n            System.out.println(invalidFilename.getMessage());\n        }\n    }\n\n\n\n    private static IRNode irbuild(String filename) throws FileNotFoundException {\n        try {\n            String zhenFilename = getZhenFilename(filename);\n\n            Lexer lex = null;\n            try {\n                lex = new Lexer(new FileReader(zhenFilename));\n            } catch (Exception e) {\n                System.out.println(\"No file found with filename \" + filename);\n                return null;\n            }\n\n            lr_parser p;\n            if (filename.endsWith(\".eta\")) p = new EtaParser(lex);\n            else if (filename.endsWith(\".eti\")) p = new EtiParser(lex);\n            else throw new FileNotFoundException(\n                        \"Invalid filename \"\n                                + filename\n                                + \" provided: All files passed to etac must have a .eta extension\");\n\n            try {\n                if (filename.endsWith(\".eta\")) {\n                    Program result = (Program) p.parse().value;\n                    result.typeCheck(new SymbolTable<>(), zhenFilename);\n                    IRNode ir = result.accept(new IRVisitor(filename.substring(0, filename.length() - 2)));\n                    return ir;\n                } else if (filename.endsWith(\".eti\")) {\n                    EtiInterface result = (EtiInterface) p.parse().value;\n                    result.firstPass(); // Just to throw EtaErrors\n                }\n\n//                if (opts.isSet(OptimizationTypes.CONSTANT_FOLDING)) {\n//\n//                }\n\n            } catch (EtaError e) {\n                e.printError(zhenFilename);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        catch (FileNotFoundException invalidFilename) {\n            System.out.println(invalidFilename.getMessage());\n        }\n\n        return null;\n    }\n\n    private static void irgenFile(String filename, boolean shouldWrite) {\n        String zhenFilename = getZhenFilename(filename);\n\n        try {\n            IRNode ir = irbuild(zhenFilename);\n\n            StringWriter out = new StringWriter();\n            PrintWriter pw = new PrintWriter(out);\n\n            CodeWriterSExpPrinter printer = new CodeWriterSExpPrinter(pw);\n//            System.out.println(ir);\n//            System.out.println(ir instanceof IRCompUnit);\n            ir.printSExp(printer);\n\n            printer.close();\n\n            if (shouldWrite) {\n                writeOutput(filename, out.toString(), \"ir\");\n            }\n        }\n        catch (EtaError e) {\n            e.printError(zhenFilename);\n        }\n        catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void irrunFile(String filename, boolean shouldWrite) {\n        String zhenFilename = getZhenFilename(filename);\n\n        try {\n            IRNode ir = irbuild(zhenFilename);\n\n            StringWriter out = new StringWriter();\n            PrintWriter pw = new PrintWriter(out);\n\n            CodeWriterSExpPrinter printer = new CodeWriterSExpPrinter(pw);\n\n            IRSimulator sim = new IRSimulator((IRCompUnit) ir);\n            sim.call(\"_Imain_paai\", 0);\n\n            printer.close();\n\n            if (shouldWrite) {\n                writeOutput(filename, out.toString(), \"ir\");\n            }\n        }\n        catch (EtaError e) {\n            e.printError(zhenFilename);\n        }\n        catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void main(String[] args) throws java.io.IOException {\n        ArrayList<String> filenames = new ArrayList<>();\n        for (int i = args.length - 1; i >= 0; i--) {\n            if (args[i].endsWith(\".eta\") || args[i].endsWith(\".eti\")) {\n                filenames.add(args[i]);\n            }\n        }\n\n        // Create the command line parser\n        CommandLineParser parser = new DefaultParser();\n\n        // Create the Options\n        Options options = new Options();\n\n        Option helpOpt = new Option(\"h\", \"help\", false,\n                \"Print a synopsis of options.\");\n\n        Option lexOpt = new Option(null, \"lex\", false,\n                \"Generate output from lexical analysis.\");\n        Option parseOpt = new Option(null, \"parse\", false,\n                \"Generate output from syntactic analysis.\");\n        Option typeOpt = new Option(null, \"typecheck\", false,\n                \"Generate output from semantic analysis.\");\n        Option irgenOpt = new Option (null, \"irgen\", false,\n                \"Generate intermediate code.\");\n\n\n        Option sourcepathOpt   = new Option (\"sourcepath\", true,\n                \"Specify where to find input source files.\");\n        Option libpathOpt = new Option (\"libpath\", true,\n                \"Specify where to find library interface files.\");\n\n        Option dirOpt   = new Option (\"D\", true,\n                \"Specify where to place generated diagnostic files.\");\n        Option optOpt   = new Option (\"O\", false,\n                \" Disable optimizations.\");\n        Option irrunOpt = new Option (null, \"irrun\", false,\n                \"Generate and interpret intermediate code.\");\n\n        options.addOption(helpOpt);\n        options.addOption(lexOpt);\n        options.addOption(parseOpt);\n        options.addOption(typeOpt);\n        options.addOption(irgenOpt);\n\n        options.addOption(sourcepathOpt);\n        options.addOption(libpathOpt);\n        options.addOption(optOpt);\n        options.addOption(dirOpt);\n        options.addOption(irrunOpt);\n\n        HelpFormatter formatter = new HelpFormatter();\n\n        opts = new Optimizations();\n        opts.setOptimizations(OptimizationTypes.CONSTANT_FOLDING, OptimizationTypes.IR_LOWERING);\n\n        isOutputDirSpecified = isInputDirSpecified = isLibpathDirSpecified = false;\n        outputDirectory = inputDirectory = libpathDirectory = Paths.get(\"\").toAbsolutePath().toString();\n\n//        System.out.println(outputDirectory);\n\n        try {\n            CommandLine cmd = parser.parse(options, args);\n            if (args.length == 0 || cmd.hasOption(\"help\")) {\n                formatter.printHelp(\"etac [options] <source files>\", options);\n                return;\n            }\n\n            if (cmd.hasOption(\"D\")) {\n                outputDirectory = cmd.getOptionValue(\"D\");\n                isOutputDirSpecified = true;\n            }\n\n            if (cmd.hasOption(\"O\")) {\n                System.out.println(opts);\n                opts.clearOptimizations(OptimizationTypes.CONSTANT_FOLDING, OptimizationTypes.IR_LOWERING);\n                System.out.println(opts);\n            }\n\n            if (cmd.hasOption(\"sourcepath\")) {\n                inputDirectory = cmd.getOptionValue(\"sourcepath\");\n                isInputDirSpecified = true;\n            }\n\n            if (cmd.hasOption(\"libpath\")) {\n                libpathDirectory = cmd.getOptionValue(\"libpath\");\n                isLibpathDirSpecified = true;\n            }\n\n            if (cmd.hasOption(\"lex\")) {\n                for (String filename : filenames) {\n                    typeCheckFile(filename, false);\n                    lexFile(filename, new StringBuilder(), true);\n                }\n            }\n\n            if (cmd.hasOption(\"parse\")) {\n                for (String filename : filenames) {\n                    typeCheckFile(filename, false);\n                    parseFile(filename, true);\n                }\n            }\n\n            if (cmd.hasOption(\"typecheck\")) {\n                for (String filename : filenames) {\n                    typeCheckFile(filename, true);\n                }\n            }\n\n            if (cmd.hasOption(\"irgen\")) {\n                for (String filename : filenames) {\n                    irgenFile(filename, true);\n                }\n            }\n\n            if (cmd.hasOption(\"irrun\")) {\n                for (String filename : filenames) {\n                    irrunFile(filename, true);\n                }\n            }\n\n        }\n        catch (ParseException parseException) {\n            formatter.printHelp(\"etac [options] <source files>\", options);\n            System.out.println(\"Unexpected exception: \" + parseException.getMessage());\n        }\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/aar226_akc55_ayc62_ahl88/Main.java b/src/main/java/aar226_akc55_ayc62_ahl88/Main.java
--- a/src/main/java/aar226_akc55_ayc62_ahl88/Main.java	(revision 8ec49e7bc2a0512569e4a197071c5a27e7121063)
+++ b/src/main/java/aar226_akc55_ayc62_ahl88/Main.java	(date 1678571050798)
@@ -304,7 +304,7 @@
             PrintWriter pw = new PrintWriter(out);
 
             CodeWriterSExpPrinter printer = new CodeWriterSExpPrinter(pw);
-//            System.out.println(ir);
+            System.out.println(ir);
 //            System.out.println(ir instanceof IRCompUnit);
             ir.printSExp(printer);
 
