Index: src/main/java/aar226_akc55_ayc62_ahl88/asm/Instructions/ASMArg2.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package aar226_akc55_ayc62_ahl88.asm.Instructions;\n\nimport aar226_akc55_ayc62_ahl88.asm.Expressions.ASMExpr;\nimport aar226_akc55_ayc62_ahl88.asm.ASMOpCodes;\n\npublic abstract class ASMArg2 extends ASMInstruction {\n\n    ASMExpr left;\n    ASMExpr right;\n    public ASMArg2(ASMOpCodes op, ASMExpr arg1, ASMExpr arg2){\n        super(op);\n        left = arg1;\n        right = arg2;\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/aar226_akc55_ayc62_ahl88/asm/Instructions/ASMArg2.java b/src/main/java/aar226_akc55_ayc62_ahl88/asm/Instructions/ASMArg2.java
--- a/src/main/java/aar226_akc55_ayc62_ahl88/asm/Instructions/ASMArg2.java	(revision 879e6f54eb2f79e8076fda6062075a14032cb39c)
+++ b/src/main/java/aar226_akc55_ayc62_ahl88/asm/Instructions/ASMArg2.java	(date 1680443612244)
@@ -5,11 +5,19 @@
 
 public abstract class ASMArg2 extends ASMInstruction {
 
-    ASMExpr left;
-    ASMExpr right;
+    private ASMExpr left;
+    private ASMExpr right;
     public ASMArg2(ASMOpCodes op, ASMExpr arg1, ASMExpr arg2){
         super(op);
         left = arg1;
         right = arg2;
     }
+
+    public ASMExpr getLeft() {
+        return left;
+    }
+
+    public ASMExpr getRight() {
+        return right;
+    }
 }
Index: src/main/java/aar226_akc55_ayc62_ahl88/asm/Instructions/ASMArg1.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package aar226_akc55_ayc62_ahl88.asm.Instructions;\n\nimport aar226_akc55_ayc62_ahl88.asm.Expressions.ASMExpr;\nimport aar226_akc55_ayc62_ahl88.asm.ASMOpCodes;\n\npublic abstract class ASMArg1 extends ASMInstruction {\n\n    ASMExpr left;\n    public ASMArg1(ASMOpCodes op, ASMExpr arg1){\n        super(op);\n        left = arg1;\n    }\n\n    public static class ASMName extends ASMExpr {\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/aar226_akc55_ayc62_ahl88/asm/Instructions/ASMArg1.java b/src/main/java/aar226_akc55_ayc62_ahl88/asm/Instructions/ASMArg1.java
--- a/src/main/java/aar226_akc55_ayc62_ahl88/asm/Instructions/ASMArg1.java	(revision 879e6f54eb2f79e8076fda6062075a14032cb39c)
+++ b/src/main/java/aar226_akc55_ayc62_ahl88/asm/Instructions/ASMArg1.java	(date 1680443627702)
@@ -5,12 +5,13 @@
 
 public abstract class ASMArg1 extends ASMInstruction {
 
-    ASMExpr left;
+    private ASMExpr left;
     public ASMArg1(ASMOpCodes op, ASMExpr arg1){
         super(op);
         left = arg1;
     }
 
-    public static class ASMName extends ASMExpr {
+    public ASMExpr getLeft() {
+        return left;
     }
 }
Index: src/main/java/aar226_akc55_ayc62_ahl88/src/edu/cornell/cs/cs4120/xic/ir/visit/ASMVisitor.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package aar226_akc55_ayc62_ahl88.src.edu.cornell.cs.cs4120.xic.ir.visit;\n\nimport aar226_akc55_ayc62_ahl88.asm.*;\nimport aar226_akc55_ayc62_ahl88.asm.Expressions.*;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.ASMArg2;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.ASMInstruction;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.ASMLabel;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.jumps.ASMJumpNotEqual;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.mov.ASMMov;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.mov.ASMMovabs;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.stackops.ASMPush;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.subroutine.ASMEnter;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.subroutine.ASMLeave;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.subroutine.ASMRet;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.tstcmp.ASMTest;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.jumps.ASMJumpAlways;\nimport aar226_akc55_ayc62_ahl88.src.edu.cornell.cs.cs4120.xic.ir.*;\nimport aar226_akc55_ayc62_ahl88.src.polyglot.util.InternalCompilerError;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\n\n/**\n * NOTES:\n * - branches: use cmp then corresponding jump\n * - multireturn: store first argument in rax, push rest on stack\n * - function args: rdi, rsi, rdx, rcx, r8, r9, push rest on stack\n * - callee saved: rbx, rbp, and r12â€“r15\n * - caller saved: everything else\n *\n * THINGS WE NEEEEEEEEEEEDDDDDDDDD\n * - ir compunit ->\n *      add glob mem locations\n *      call visit to all functions\n * - ir func decl ->\n *      create new label at the top for function name\n *      follow abi for args and register alloc\n *      call visit on each statement\n *      flatten arraylist we get back\n *      follow abi for correct func exit\n * - jump -> jr <label name>\n * - cjump ->\n *      two args: cmp <t1> <t2>; j<flag> <label name>\n *      if instance of IRConst and is boolliteral: true -> jr / false -> nothing\n * - move ->\n *      mooooooooooooove\n *      contains expr: used for dynamic tiling\n *      tiling\n * - mem\n * - binop\n * - call stmt ->\n *      init function call follow abi for function call (store func args correctly)\n *      jump to function\n *      clean accroding to ABI spec (be careful about multireturns and stack dead space)\n *      pop from function\n * - IR Label -> ASM label\n *\n *\n * Generic ASM Class will be called ASMNode\n */\n\npublic class ASMVisitor {\n    private int tempCnt;\n\n    private HashMap<String,HashSet<String>> functionToTemps;\n\n    private String curFunction;\n\n\n    private String nxtTemp() {\n        return String.format(\"_ASMReg_t%d\", (tempCnt++));\n    }\n    private ASMDirectives getType(String name) {\n        String type = name.split(\"_\")[0];\n        if (type.equals(\"i\") || type.equals(\"b\")) {\n            return ASMDirectives.QUAD;\n        }\n        return ASMDirectives.ZERO;\n    }\n    // converts an IR TEMP to an ASM TEMP\n    private ASMTempExpr tempToASM(IRTemp t) {\n        return new ASMTempExpr(t.name());\n    }\n    // change te parameters if needed\n    private ArrayList<ASMInstruction> cJumpBinop(IRBinOp binop){\n        ArrayList<ASMInstruction> instructions = new ArrayList<ASMInstruction>();\n//        switch (binop.opType()) {\n//            case EQ:\n//            case NEQ:\n//            case LT:\n//            case ULT:\n//            case GT:\n//            case LEQ:\n//            case GEQ:\n////                ASMArg2 instr1 = new ASMCmp(binop.left(), binop.right());\n//\n//        }\n        return instructions;\n    }\n\n    public ArrayList<ASMInstruction> visit(IRData node){\n        ArrayList<ASMInstruction> instructions = new ArrayList<ASMInstruction>();\n\n        return instructions;\n    }\n    public ArrayList<ASMInstruction> visit(IRCJump node) {\n        ArrayList<ASMInstruction> instructions = new ArrayList<ASMInstruction>();\n\n        IRExpr condition = node.cond();\n\n        if (condition instanceof IRBinOp c) {\n            // create function for IRBINOP\n            // DO A CMP instead\n            return cJumpBinop(c);\n        } else if (condition instanceof IRConst c) {\n            if (c.value() != 0L){ // jump\n                instructions.add(new ASMJumpAlways(new ASMNameExpr(node.trueLabel())));\n            }\n        } else if (condition instanceof IRTemp c) {\n            functionToTemps.get(curFunction).add(c.name());\n            ASMTempExpr tempName = tempToASM(c);\n            instructions.add(new ASMTest(tempName,tempName));\n            instructions.add(new ASMJumpNotEqual(new ASMNameExpr(node.trueLabel())));\n            //test t, t\n            //jnz l\n        } else if (condition instanceof IRMem c) {\n            ASMTempExpr tempForMem = new ASMTempExpr(nxtTemp());\n            // accept mem for this temp\n            // add move instruction\n            // do temp test and ASM Jump no Equal\n            return null;\n        }else{\n            throw new InternalCompilerError(\"CJUMP guard has another type\");\n        }\n        return instructions;\n    }\n    public ArrayList<ASMInstruction> visit(IRCompUnit node) {\n        ArrayList<ASMInstruction> instructions = new ArrayList<ASMInstruction>();\n\n        for (IRData data : node.dataMap().values()) {\n            ASMLabel data_label = new ASMLabel(data.name());\n//            ASMData data_instr = new ASMData(getType(data.name()), new ASMConstExpr(data.data()));\n        }\n\n        for (IRFuncDecl func : node.functions().values()) {\n            curFunction = func.name();\n            functionToTemps.put(func.name(),new HashSet<>());\n            instructions.addAll(visit(func));\n        }\n\n        return instructions;\n    }\n    public ArrayList<ASMInstruction> visit (IRConst x) {\n        ArrayList<ASMInstruction> instructions = new ArrayList<ASMInstruction>();\n        boolean isInt = x.value() <= Integer.MAX_VALUE && x.value() >= Integer.MIN_VALUE;\n        ASMArg2 instruction = (isInt) ? new ASMMov(new ASMTempExpr(nxtTemp()),new ASMConstExpr(x.value()))\n                : new ASMMovabs(new ASMTempExpr(nxtTemp()),new ASMConstExpr(x.value()));\n        instructions.add(instruction);\n        return instructions;\n    }\n    public ArrayList<ASMInstruction> visit(IRFuncDecl node) {\n        ArrayList<ASMInstruction> result = new ArrayList<>();\n\n        // create new Starting label for this Function\n        result.add(new ASMLabel(node.name()));\n\n//        enter at Botoom\n//        push rbp\n//        mov rbp rsp\n//        sub rsp, 8*l\n//        result.add(new ASMPush(new ASMRegisterExpr(\"rbp\")));\n//        result.add(new ASMMov(new ASMRegisterExpr(\"rbp\"),new ASMRegisterExpr(\"rsp\")));\n\n        // need to calculate number of temporaries used\n\n\n        // foo(1,2,3,4,5,6,7....) -> rdi, rsi, rdx, rcx, r8, r9, stack\n        int numParams = node.functionSig.inputTypes.size();\n        int numReturns = node.functionSig.outputTypes.size();\n        ArrayList<ASMInstruction> bodyInstructions = new ArrayList<>();\n\n        if (numReturns > 2){\n            functionToTemps.get(curFunction).add(\"_ARG0\");\n            bodyInstructions.add(new ASMMov(\n                    new ASMTempExpr(\"_ARG0\"),\n                    new ASMRegisterExpr(\"rdi\")\n            ));\n        }\n\n        int start = numReturns > 2 ? 2: 1;\n        int end   = numParams > 2 ? numParams +1: numParams;\n        for (int i = start; i<=end;i++){\n\n            // Move arg into argI. argI <- RDI\n            ASMExpr ARGI = switch (i) {\n                case 1 -> new ASMRegisterExpr(\"rdi\");\n                case 2 -> new ASMRegisterExpr(\"rsi\");\n                case 3 -> new ASMRegisterExpr(\"rdx\");\n                case 4 -> new ASMRegisterExpr(\"rcx\");\n                case 5 -> new ASMRegisterExpr(\"r8\");\n                case 6 -> new ASMRegisterExpr(\"r9\");\n                default ->\n                        new ASMMemExpr(\n                                new ASMBinOpAddExpr(\n                                        new ASMRegisterExpr(\"rbp\"),\n                                        new ASMConstExpr(8L * (i - 7 + 2))));\n            };\n            String tempName = \"_ARG\" + i;\n            functionToTemps.get(curFunction).add(tempName);\n            // can't do [stack location] <- [stack location2]\n            // need intermediate rax <- [stack location2]\n            // then [stack location] <- temp rax\n            if (i>=7){\n                bodyInstructions.add(new ASMMov(new ASMRegisterExpr(\"rax\"),ARGI));\n                bodyInstructions.add(new ASMMov(new ASMTempExpr(tempName),new ASMRegisterExpr(\"rax\")));\n            }\n            // just do MOV [stack location] <- register\n            else{\n                bodyInstructions.add(new ASMMov(new ASMTempExpr(tempName),ARGI));\n            }\n        }\n        if (node.body() instanceof  IRSeq seq){\n            for (IRStmt stmt: seq.stmts()){\n                bodyInstructions.addAll(stmt.accept(this));\n            }\n        }else{\n            throw new InternalCompilerError(\"body isn't a seq\");\n        }\n        // add enter at begin.\n        // enter 8*L, 0\n        ASMEnter begin = new ASMEnter(new ASMConstExpr(8L*functionToTemps.get(curFunction).size()),new ASMConstExpr(0));\n        bodyInstructions.add(0,begin);\n        return bodyInstructions;\n    }\n    public ArrayList<ASMInstruction> visit(IRJump jump) {\n        ArrayList<ASMInstruction> instructions = new ArrayList<>();\n        if (jump.target() instanceof IRName) {\n            instructions.add(new ASMJumpAlways(new ASMNameExpr(jump.label())));\n        }\n        return instructions;\n    }\n    public ArrayList<ASMInstruction> visit(IRLabel node) {\n        ArrayList<ASMInstruction> instructions = new ArrayList<ASMInstruction>();\n        instructions.add(new ASMLabel(node.name()));\n        return instructions;\n    }\n    // Always use these three rax, rcx, and rdx\n    public ArrayList<ASMInstruction> visit(IRMove node){\n        IRExpr dest = node.target();\n        IRExpr source = node.source();\n        ArrayList<ASMInstruction> instructions = new ArrayList<>();\n        if (dest instanceof IRTemp t1 && source instanceof IRTemp t2){ // random case for testing atm\n//            instructions.add(new ASMMov())\n        }\n\n        return null;\n    }\n\n    public ArrayList<ASMInstruction> visit(IRSeq node){\n        ArrayList<ASMInstruction> instructions = new ArrayList<ASMInstruction>();\n        for (IRStmt stmt : node.stmts()) {\n            ArrayList<ASMInstruction> stmtInstrs = stmt.accept(this);\n            instructions.addAll(stmtInstrs);\n        }\n        return instructions;\n    }\n    public ArrayList<ASMInstruction> visit(IRReturn node) {\n        //\n        ArrayList<ASMInstruction> returnInstructions = new ArrayList<>();\n        int returnSize = node.rets().size();\n\n        ArrayList<String> tempNames = new ArrayList<>();\n        //in case returns stop being temporaries in the future.\n        for (IRExpr e: node.rets()){\n             if (e instanceof IRTemp t){\n                tempNames.add(t.name());\n             }else{\n                 System.out.println(\"return is not a temp? \" + e);\n                 String nxtName = nxtTemp();\n                 tempNames.add(nxtName);\n                 ASMTempExpr tmp = new ASMTempExpr(nxtName);\n                 throw new InternalCompilerError(\"return has an element that isn't a temp\");\n             }\n        }\n\n        functionToTemps.get(curFunction).addAll(tempNames);\n        // looping in reverse so rax can be used temporarily until the end\n        for (int i = 1; i <= returnSize; i++) {\n            // move expression to Return Location\n            // Move ret into reti. reti <- RDI\n            ASMExpr retI = switch (i) {\n                case 1 -> new ASMRegisterExpr(\"rax\");\n                case 2 -> new ASMRegisterExpr(\"rdx\");\n                default -> new ASMMemExpr(\n                        new ASMBinOpAddExpr(\n                                new ASMRegisterExpr(\"_ARG0\"),\n                                new ASMConstExpr(8L*(i-3))));\n            };\n\n            if (i >2){\n                // just in case we just put everything on the stack lol need intermediate\n                // rcx <- [origin]\n                returnInstructions.add(new ASMMov(new ASMRegisterExpr(\"rcx\"),new ASMTempExpr(tempNames.get(i))));\n                // [dest] <- rcx\n                returnInstructions.add(new ASMMov(retI,new ASMRegisterExpr(\"rcx\")));\n            }else{\n                returnInstructions.add(new ASMMov(retI,new ASMTempExpr(tempNames.get(i))));\n            }\n        }\n\n        // leave\n        // ret\n        returnInstructions.add(new ASMLeave());\n        returnInstructions.add(new ASMRet());\n        return returnInstructions;\n    }\n    public ArrayList<ASMInstruction> visit(IRCallStmt node) {\n        return null;\n    }\n\n    public ArrayList<ASMInstruction> visit(IRExp irExp) {\n        System.out.println(\"don't have irExp\");\n        return new ArrayList<>();\n    }\n\n\n    // TODO: 4/1/2023\n    // move\n    // TODO: 4/1/2023\n    // temp\n    // TODO: 4/1/2023\n    // mem\n    // TODO: 4/1/2023\n    // call_stmt\n    // TODO: 4/1/2023\n    // name\n    // TODO: 4/1/2023\n    // RETURN\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/aar226_akc55_ayc62_ahl88/src/edu/cornell/cs/cs4120/xic/ir/visit/ASMVisitor.java b/src/main/java/aar226_akc55_ayc62_ahl88/src/edu/cornell/cs/cs4120/xic/ir/visit/ASMVisitor.java
--- a/src/main/java/aar226_akc55_ayc62_ahl88/src/edu/cornell/cs/cs4120/xic/ir/visit/ASMVisitor.java	(revision 879e6f54eb2f79e8076fda6062075a14032cb39c)
+++ b/src/main/java/aar226_akc55_ayc62_ahl88/src/edu/cornell/cs/cs4120/xic/ir/visit/ASMVisitor.java	(date 1680443480105)
@@ -251,10 +251,16 @@
         IRExpr source = node.source();
         ArrayList<ASMInstruction> instructions = new ArrayList<>();
         if (dest instanceof IRTemp t1 && source instanceof IRTemp t2){ // random case for testing atm
-//            instructions.add(new ASMMov())
+            // super redudant :((
+            // move rax <- t2.name
+            instructions.add(new ASMMov(new ASMRegisterExpr("rax"),new ASMTempExpr(t2.name())));
+            //move t1.name <- rax
+            instructions.add(new ASMMov(new ASMTempExpr(t1.name()),new ASMRegisterExpr("rax")));
+        }else{
+            throw new InternalCompilerError("TODO Other moves");
         }
 
-        return null;
+        return instructions;
     }
 
     public ArrayList<ASMInstruction> visit(IRSeq node){
Index: src/main/java/aar226_akc55_ayc62_ahl88/asm/Instructions/ASMArg3.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package aar226_akc55_ayc62_ahl88.asm.Instructions;\n\nimport aar226_akc55_ayc62_ahl88.asm.Expressions.ASMExpr;\nimport aar226_akc55_ayc62_ahl88.asm.ASMOpCodes;\n\npublic abstract class ASMArg3 extends ASMInstruction {\n    ASMExpr a1;\n    ASMExpr a2;\n    ASMExpr a3;\n    public ASMArg3(ASMOpCodes op, ASMExpr arg1, ASMExpr arg2, ASMExpr arg3){\n        super(op);\n        a1 = arg1;\n        a2 = arg2;\n        a3 = arg3;\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/aar226_akc55_ayc62_ahl88/asm/Instructions/ASMArg3.java b/src/main/java/aar226_akc55_ayc62_ahl88/asm/Instructions/ASMArg3.java
--- a/src/main/java/aar226_akc55_ayc62_ahl88/asm/Instructions/ASMArg3.java	(revision 879e6f54eb2f79e8076fda6062075a14032cb39c)
+++ b/src/main/java/aar226_akc55_ayc62_ahl88/asm/Instructions/ASMArg3.java	(date 1680443652273)
@@ -4,13 +4,25 @@
 import aar226_akc55_ayc62_ahl88.asm.ASMOpCodes;
 
 public abstract class ASMArg3 extends ASMInstruction {
-    ASMExpr a1;
-    ASMExpr a2;
-    ASMExpr a3;
+    private ASMExpr a1;
+    private ASMExpr a2;
+    private ASMExpr a3;
     public ASMArg3(ASMOpCodes op, ASMExpr arg1, ASMExpr arg2, ASMExpr arg3){
         super(op);
         a1 = arg1;
         a2 = arg2;
         a3 = arg3;
     }
+
+    public ASMExpr getA1() {
+        return a1;
+    }
+
+    public ASMExpr getA2() {
+        return a2;
+    }
+
+    public ASMExpr getA3() {
+        return a3;
+    }
 }
