Index: tests/external/call3.irsol.nml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/tests/external/call3.irsol.nml b/tests/external/call3.irsol.nml
new file mode 100644
--- /dev/null	(date 1679017602123)
+++ b/tests/external/call3.irsol.nml	(date 1679017602123)
@@ -0,0 +1,2 @@
+ok 1
+-1
Index: src/main/java/aar226_akc55_ayc62_ahl88/src/edu/cornell/cs/cs4120/xic/ir/visit/IRLoweringVisitor.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package aar226_akc55_ayc62_ahl88.src.edu.cornell.cs.cs4120.xic.ir.visit;\n\n\nimport aar226_akc55_ayc62_ahl88.newast.stmt.Block;\nimport aar226_akc55_ayc62_ahl88.src.edu.cornell.cs.cs4120.xic.ir.*;\nimport aar226_akc55_ayc62_ahl88.src.polyglot.util.InternalCompilerError;\n\nimport java.util.*;\n\n// Need to think about what to add\nclass BasicBlock {\n    public boolean marked;\n    public int ind;\n    public int indegree;\n    public ArrayList<Integer> predecessors;\n    public ArrayList<Integer> successors;\n    public ArrayList<IRStmt> statements;\n    public ArrayList<String> destLabels;\n\n    public ArrayList<String> originLabels;\n\n\n\n    public BasicBlock(int i) {\n        ind = i;\n        indegree = 0;\n        marked = false;\n        predecessors = new ArrayList<>();\n        successors = new ArrayList<>();\n        statements = new ArrayList<>();\n        destLabels = new ArrayList<>();\n        originLabels = new ArrayList<>();\n    }\n}\n\npublic class IRLoweringVisitor extends IRVisitor {\n    private int labelCnt;\n    private int tempCnt;\n\n\n    private String nxtLabel() {\n        return String.format(\"lb%d\", (labelCnt++));\n    }\n\n    private String nxtTemp() {\n        return String.format(\"tl%d\", (tempCnt++));\n    }\n    public IRLoweringVisitor (IRNodeFactory inf) {\n        super(inf);\n        labelCnt = 0;\n        tempCnt = 0;\n        labelToNumber= new HashMap<>();\n    }\n    private HashMap<String,Long> labelToNumber;\n\n    @Override\n    protected IRNode leave(IRNode parent, IRNode n, IRNode n_, IRVisitor v_) {\n        if (n_ instanceof IRBinOp irbin) return canon(irbin);\n        if (n_ instanceof IRCall irc) return canon(irc);\n        if (n_ instanceof IRCallStmt ircstmt) return canon(ircstmt);\n        if (n_ instanceof IRCJump ircj) return canon(ircj);\n        if (n_ instanceof IRCompUnit icu) return canon(icu);\n        if (n_ instanceof IRConst ic) return canon(ic);\n        if (n_ instanceof IRESeq ireseq) return canon(ireseq);\n        if (n_ instanceof IRExp irexp) return  canon(irexp);\n        if (n_ instanceof IRFuncDecl irfunc) return canon(irfunc);\n        if (n_ instanceof IRJump irj) return canon(irj);\n        if (n_ instanceof IRLabel irl) return canon(irl);\n        if (n_ instanceof IRMem irmem) return canon(irmem);\n        if (n_ instanceof IRMove irmove) return canon(irmove);\n        if (n_ instanceof IRName irname) return canon(irname);\n        if (n_ instanceof IRReturn irret) return canon(irret);\n        if (n_ instanceof IRSeq irseq) return canon(irseq);\n        if (n_ instanceof IRTemp irtem) return canon(irtem);\n\n        throw new Error(\"Why is node not found\");\n    }\n\n    private boolean hasNoUnmarkedPredecessors(BasicBlock block,ArrayList<BasicBlock> blocks) {\n\n        boolean noUnmarkedPredecessor = true;\n        for (int i : block.predecessors) {\n            if (!blocks.get(i).marked){\n                noUnmarkedPredecessor = false;\n            }\n        }\n\n\n        return noUnmarkedPredecessor;\n    }\n    private void dfs(BasicBlock b, ArrayList<BasicBlock> res, ArrayList<BasicBlock> unorderedBlocks){\n        b.marked = true;\n//        System.out.println(\"START\");\n        boolean[] visit = new boolean[unorderedBlocks.size()];\n        Stack<Integer> stack = new Stack<>();\n        stack.add(b.ind);\n        while (!stack.isEmpty()){\n            int curNode = stack.pop();\n            BasicBlock curBlock = unorderedBlocks.get(curNode);\n            curBlock.marked = true;\n            res.add(curBlock);\n            boolean foundAnother = false;\n            for (int succ : curBlock.successors){\n                if (!visit[succ] && !unorderedBlocks.get(succ).marked){\n                    visit[succ] = true;\n                    stack.add(succ);\n                    foundAnother = true;\n                    break;\n                }\n            }\n            if (!foundAnother){\n                break;\n            }\n        }\n    }\n    private boolean allMarked(ArrayList<BasicBlock> blocks){\n        for (BasicBlock b: blocks){\n            if (!b.marked){\n                return false;\n            }\n        }\n        return true;\n    }\n    private BasicBlock chooseBlock(ArrayList<BasicBlock> blocks){\n        boolean allMarked = true;\n        BasicBlock curBlock = null;\n        for (BasicBlock b: blocks){\n            if (!b.marked && hasNoUnmarkedPredecessors(b,blocks)){\n                return b;\n            }\n            if (!b.marked){\n                allMarked = false;\n                if (curBlock == null){\n                    curBlock = b;\n                }\n            }\n        }\n        if (!allMarked){\n            return curBlock;\n        }\n        throw new InternalCompilerError(\"Should only choose block when not all marked\");\n    }\n    private ArrayList<BasicBlock> goodReordering(ArrayList<BasicBlock> unorderedBlocks){\n        ArrayList<BasicBlock> result = new ArrayList<>();\n        while (!allMarked(unorderedBlocks)) {\n            BasicBlock block = chooseBlock(unorderedBlocks);\n            dfs(block,result,unorderedBlocks);\n        }\n        return result;\n    }\n\n    private boolean stop(IRStmt stmt){\n        return (stmt instanceof IRJump || stmt instanceof IRCJump || stmt instanceof IRReturn || stmt instanceof IRLabel);\n    }\n\n    private void compareBlocks(BasicBlock block1, BasicBlock block2){\n        for (String originLabel : block1.originLabels) {\n            for (String destLabel : block2.destLabels) {\n                if (originLabel.equals(destLabel)) {\n                    block1.successors.add(block2.ind);\n                    block2.predecessors.add(block1.ind);\n                }\n            }\n        }\n    }\n\n    private ArrayList<BasicBlock> createBasicBlocksAndGraph(IRSeq body){\n        int ind = 0;\n        ArrayList<BasicBlock> blocks = new ArrayList<>();\n        BasicBlock dummy = new BasicBlock(ind);\n        ind++;\n        String lb = nxtLabel();\n        dummy.statements.add(new IRJump(new IRName(\"dummy_head\" + lb)));\n        labelToNumber.put(\"dummy_head\" + lb,1L);\n        dummy.successors.add(1);\n        blocks.add(dummy);\n        BasicBlock curBlock = new BasicBlock(ind);\n        curBlock.predecessors.add(0);\n        curBlock.statements.add(new IRLabel(\"dummy_head\" + lb));\n        for (IRStmt stmt: body.stmts()){\n            if (stop(stmt)) {\n                if (stmt instanceof IRJump jmp) {\n                    String destName = ((IRName) jmp.target()).name();\n                    if (labelToNumber.containsKey(destName)) {\n                        labelToNumber.put(destName, labelToNumber.get(destName) + 1);\n                    }else{\n                        labelToNumber.put(destName,1L);\n                    }\n                    curBlock.originLabels.add(destName);\n                    curBlock.statements.add(stmt);\n                }\n                else if (stmt instanceof IRCJump cjmp) {\n                    curBlock.originLabels.add(cjmp.trueLabel());\n                    if (labelToNumber.containsKey(cjmp.trueLabel())) {\n                        labelToNumber.put(cjmp.trueLabel(), labelToNumber.get(cjmp.trueLabel()) + 1);\n                    }else{\n                        labelToNumber.put(cjmp.trueLabel(),1L);\n                    }\n                    curBlock.originLabels.add(cjmp.falseLabel());\n                    if (labelToNumber.containsKey(cjmp.falseLabel())) {\n                        labelToNumber.put(cjmp.falseLabel(), labelToNumber.get(cjmp.falseLabel()) + 1);\n                    }else{\n                        labelToNumber.put(cjmp.falseLabel(),1L);\n                    }\n                    curBlock.statements.add(stmt);\n                }else if (stmt instanceof IRReturn irr){\n                    curBlock.statements.add(irr);\n                }\n                if (curBlock.statements.size() != 0) {\n                    BasicBlock preBlock = curBlock;\n                    blocks.add(curBlock);\n                    ind++;\n                    curBlock = new BasicBlock(ind);\n                    if (stmt instanceof IRLabel il){ // in case of fall through Label add a jump on purpose\n                        preBlock.successors.add(ind); // to maintain correctness\n                        curBlock.predecessors.add(preBlock.ind);\n                        curBlock.destLabels.add(il.name());\n                        curBlock.statements.add(il);\n                        preBlock.statements.add(new IRJump(new IRName(il.name())));\n                        if (labelToNumber.containsKey(il.name())) {\n                            labelToNumber.put(il.name(), labelToNumber.get(il.name()) + 1);\n                        }else{\n                            labelToNumber.put(il.name(),1L);\n                        }\n                    }\n                }else if (stmt instanceof IRLabel il){ // prev block was empty so we just continue this block\n                    curBlock.statements.add(il);\n                    curBlock.destLabels.add(il.name());\n                }else{\n                    throw new InternalCompilerError(\"BRUH\"); // pls try to get\n                }\n            }else{\n                curBlock.statements.add(stmt);\n            }\n        }\n        if (curBlock.statements.size() != 0) {\n            blocks.add(curBlock);\n        }\n\n        for (int i = 0; i < blocks.size(); i++) {\n            for (int j = i; j < blocks.size(); j++) {\n                BasicBlock bi = blocks.get(i), bj = blocks.get(j);\n                compareBlocks(bi, bj);\n                compareBlocks(bj, bi);\n            }\n        }\n        return blocks;\n\n    }\n    // Lower each statment then flatten all sequences\n    private IRNode canon(IRSeq node) {\n//        System.out.println(node);\n        ArrayList<IRStmt> flatten = new ArrayList<>();\n        for (IRStmt stmt: node.stmts()){\n            if (stmt instanceof IRSeq seq){\n                flatten.addAll(seq.stmts());\n            }else{\n                flatten.add(stmt);\n            }\n        }\n        return new IRSeq(flatten);\n    }\n\n    // Lower each return expressions then add Return\n    private IRNode canon(IRReturn node) {\n        ArrayList<IRStmt> stmts = new ArrayList<>();\n        ArrayList<String> temps_strs = new ArrayList<>();\n\n        for (IRExpr expr : node.rets()) {\n            String ti = nxtTemp();\n            temps_strs.add(ti);\n            if (expr instanceof IRESeq eseq) {\n                if (eseq.stmt() instanceof IRSeq seq){\n                    stmts.addAll(seq.stmts());\n                }else{\n                    stmts.add(eseq.stmt());\n                }\n                stmts.add(new IRMove(new IRTemp(ti),eseq.expr()));\n            }else{\n                stmts.add(new IRMove(new IRTemp(ti),expr));\n            }\n        }\n        List<IRExpr> temps = new ArrayList<>();\n        for (String tmp : temps_strs) {\n            temps.add(new IRTemp(tmp));\n        }\n\n        stmts.add(new IRReturn(temps));\n        return new IRSeq(stmts);\n    }\n\n    // Lower Move be very careful look at slides\n    private IRNode canon(IRMove node) {\n        IRExpr target = node.target();\n        IRExpr source = node.source();\n//\n        if (target instanceof IRMem mem){\n            return moveCommute(node) ? moveNaive(mem,source) : moveGeneral(mem,source);\n        }\n        return easyMove(node);\n    }\n\n    private IRNode easyMove(IRMove node){\n        ArrayList<IRStmt> stmts = new ArrayList<>();\n        IRExpr targ = node.target();\n        IRExpr source = node.source();\n        if (node.target() instanceof IRESeq ires1){\n            if (ires1.stmt() instanceof IRSeq seq){\n                stmts.addAll(seq.stmts());\n            }else{\n                stmts.add(ires1.stmt());\n            }\n            targ = ires1.expr();\n        }\n        if (node.source() instanceof IRESeq ires){\n            if (ires.stmt() instanceof IRSeq seq2){\n                stmts.addAll(seq2.stmts());\n            }else{\n                stmts.add(ires.stmt());\n            }\n            source = ires.expr();\n        }\n        if (stmts.size() != 0){\n            stmts.add(new IRMove(targ,source));\n            return new IRSeq(stmts);\n        }\n        return node;\n    }\n    // to do\n    private boolean moveCommute(IRMove node){\n        return false;\n    }\n    private IRStmt moveNaive(IRMem targ, IRExpr src){\n        ArrayList<IRStmt> stmts = new ArrayList<>();\n        IRExpr e1 = targ.expr();\n        IRExpr e2 = src;\n        if (targ.expr() instanceof IRESeq ires){\n            if (ires.stmt() instanceof IRSeq seq){\n                stmts.addAll(seq.stmts());\n            }else{\n                stmts.add(ires.stmt());\n            }\n            e1 = ires.expr();\n        }\n        if (src instanceof  IRESeq ires2){\n            if (ires2.stmt() instanceof IRSeq seq1){\n                stmts.addAll(seq1.stmts());\n            }else{\n                stmts.add(ires2.stmt());\n            }\n            e2 = ires2.expr();\n        }\n        if (stmts.size() != 0){\n            stmts.add(new IRMove(new IRMem(e1),e2));\n            return new IRSeq(stmts);\n        }\n        return new IRMove(targ,src);\n    }\n\n    private IRStmt moveGeneral(IRMem targ, IRExpr src){\n        ArrayList<IRStmt> stmts = new ArrayList<>();\n        IRExpr e1 = targ.expr();\n        IRExpr e2 = src;\n        if (targ.expr() instanceof IRESeq ires){\n            if (ires.stmt() instanceof IRSeq seq){\n                stmts.addAll(seq.stmts());\n            }else{\n                stmts.add(ires.stmt());\n            }\n            e1 = ires.expr();\n        }\n        String t = nxtTemp();\n        stmts.add(new IRMove(new IRTemp(t),e1));\n        if (src instanceof  IRESeq ires2){\n            if (ires2.stmt() instanceof IRSeq seq1){\n                stmts.addAll(seq1.stmts());\n            }else{\n                stmts.add(ires2.stmt());\n            }\n            e2 = ires2.expr();\n        }\n        stmts.add(new IRMove(new IRMem(new IRTemp(t)),e2));\n        return new IRSeq(stmts);\n    }\n\n    // Create Basic Blocks And reorder all the body\n    private IRNode canon(IRFuncDecl node) {\n        if (node.body() instanceof IRSeq irs){\n            ArrayList<IRStmt> orderedStatements = new ArrayList<>();\n            ArrayList<BasicBlock> unorderedBlocks = createBasicBlocksAndGraph(irs);\n            ArrayList<BasicBlock> orderedBlocks = goodReordering(unorderedBlocks);\n            assert unorderedBlocks.size() == orderedBlocks.size() : \"after ordering is different size tf\";\n            for (int i = 0; i< orderedBlocks.size()-1;i++){\n                BasicBlock curblk = orderedBlocks.get(i);\n                BasicBlock nxtblk = orderedBlocks.get(i+1);\n                assert curblk.statements.size() >= 1: \"block is empty\";\n                assert nxtblk.statements.size() >= 1: \"dest block is empty\";\n//                System.out.println(i);\n//                System.out.println(i+1);\n//                System.out.println(curblk.statements);\n//                System.out.println(nxtblk.statements);\n                IRStmt lastStmt = curblk.statements.get(curblk.statements.size()-1);\n                IRStmt firstStmtInNext = nxtblk.statements.get(0);\n                if (lastStmt instanceof IRJump jmp && firstStmtInNext instanceof IRLabel il){\n                    String name = ((IRName) jmp.target()).name();\n                    if (name.equals(il.name())){ // remove jump\n                        labelToNumber.put(name, labelToNumber.get(name)-1);\n                        curblk.statements.remove(curblk.statements.size()-1);\n                    }\n                }else if (lastStmt instanceof IRCJump cjmp && firstStmtInNext instanceof IRLabel il){\n                    String tlabel = cjmp.trueLabel();\n                    String flabel = cjmp.falseLabel();\n                    if (tlabel.equals(il.name())){\n                        IRBinOp newCond = new IRBinOp(IRBinOp.OpType.XOR,new IRConst(1),cjmp.cond());\n                        IRCJump newCJump = new IRCJump(newCond, flabel,null);\n                        labelToNumber.put(tlabel, labelToNumber.get(tlabel)-1);\n                        curblk.statements.set(curblk.statements.size()-1,newCJump);\n                    }else if (flabel.equals(il.name())){\n                        IRCJump newCJump = new IRCJump(cjmp.cond(), tlabel,null);\n                        labelToNumber.put(flabel, labelToNumber.get(flabel)-1);\n                        curblk.statements.set(curblk.statements.size()-1,newCJump);\n                    }else{\n//                        System.out.println(\"yikes somehow need double jump again idk?\");\n                        IRCJump newCJump = new IRCJump(cjmp.cond(), tlabel,null);\n                        curblk.statements.set(curblk.statements.size()-1,newCJump);\n                        curblk.statements.add(new IRJump(new IRName(flabel)));\n                    }\n                }\n            }\n            BasicBlock lastBlock = orderedBlocks.get(orderedBlocks.size()-1);\n            IRStmt lastStmt = lastBlock.statements.get(lastBlock.statements.size()-1);\n            if (lastStmt instanceof IRCJump cjmp){\n                IRCJump newCJump = new IRCJump(cjmp.cond(), cjmp.trueLabel(),null);\n                lastBlock.statements.set(lastBlock.statements.size()-1,newCJump);\n                lastBlock.statements.add(new IRJump(new IRName(cjmp.falseLabel())));\n            }\n            for (HashMap.Entry<String, Long> entry : labelToNumber.entrySet()) {\n                Long value = entry.getValue();\n                assert value >= 0L: \"Labels can't become negative\";\n                // ...\n            }\n            int del = 0;\n            for (BasicBlock b: orderedBlocks){\n                ArrayList<IRStmt> nxtBlockStmt = new ArrayList<>();\n                for (IRStmt s: b.statements){\n                    if (s instanceof IRLabel ir){\n                        if (labelToNumber.get(ir.name()) > 0){\n                            orderedStatements.add(s);\n                            nxtBlockStmt.add(s);\n                        }else{\n                            del++;\n                        }\n                    }else {\n                        orderedStatements.add(s);\n                        nxtBlockStmt.add(s);\n                    }\n                }\n                b.statements = nxtBlockStmt;\n            }\n//            System.out.println(del);\n            ArrayList<BasicBlock> cleanBlocks = new ArrayList<>();\n            for (BasicBlock b: orderedBlocks){\n                if (b.statements.size() > 0){\n                    cleanBlocks.add(b);\n                }\n            }\n            orderedBlocks = cleanBlocks;\n//            for (BasicBlock b: orderedBlocks){\n//                System.out.println(b.statements);\n//            }\n//            for (BasicBlock b: orderedBlocks){\n//                for (IRStmt s: b.statements){\n//                        orderedStatements.add(s);\n//                }\n//            }\n            IRFuncDecl func = new IRFuncDecl(node.name(),new IRSeq(orderedStatements));\n            func.functionSig = node.functionSig;\n            return func;\n        }else{\n            throw new InternalCompilerError(\"METHOD BODY NOT SEQ\");\n        }\n    }\n\n\n    // Lift Statement that is it\n    private IRNode canon(IRExp node) {\n        if (node.expr() instanceof IRESeq ire) {\n            if (ire.stmt() instanceof IRSeq seq){\n                return new IRSeq(seq.stmts());\n            }else{\n                return ire.stmt();\n            }\n        }\n        return new IRSeq();\n    }\n\n    // do nothing\n    private IRNode canon(IRCompUnit node) {\n        return node;\n    }\n\n    // Lower each Expr\n    private IRNode canon(IRCallStmt node) {\n        ArrayList<IRStmt> stmts = new ArrayList<>();\n        ArrayList<String> temps_strs = new ArrayList<>();\n\n        for (IRExpr expr : node.args()) {\n            String ti = nxtTemp();\n            temps_strs.add(ti);\n            if (expr instanceof IRESeq eseq) {\n                if (eseq.stmt() instanceof IRSeq seq){\n                    stmts.addAll(seq.stmts());\n                }else{\n                    stmts.add(eseq.stmt());\n                }\n                stmts.add(new IRMove(new IRTemp(ti),eseq.expr()));\n            }else{\n                stmts.add(new IRMove(new IRTemp(ti),expr));\n            }\n        }\n\n        List<IRExpr> temps = new ArrayList<>();\n        for (String tmp : temps_strs) {\n            temps.add(new IRTemp(tmp));\n        }\n\n        stmts.add(new IRCallStmt(node.target(), node.n_returns(), temps));\n\n        return new IRSeq(stmts);\n    }\n    // Lower each Expr we never call this lol?\n    private IRNode canon(IRCall node) {\n        return node;\n    }\n\n    // if commute do that otherwise do normal\n    private IRNode canon(IRBinOp node) {\n        return doesBinopCommunte(node) ? commuteBinop(node) : defaultBinop(node);\n    }\n\n    // to do\n    private boolean doesBinopCommunte(IRBinOp node){\n        return false;\n    }\n\n    private IRNode commuteBinop(IRBinOp node){\n        ArrayList<IRStmt> hoisted = new ArrayList<>();\n        IRExpr e1 = node.left();\n        IRExpr e2 = node.right();\n        if (node.left() instanceof IRESeq ires1){\n            if (ires1.stmt() instanceof IRSeq seq){\n                hoisted.addAll(seq.stmts());\n            }else{\n                hoisted.add(ires1.stmt());\n            }\n            e1 = ires1.expr();\n        }\n        if (node.right() instanceof  IRESeq ires2){\n            if (ires2.stmt() instanceof IRSeq seq2){\n                hoisted.addAll(seq2.stmts());\n            }else{\n                hoisted.add(ires2.stmt());\n            }\n            e2 = ires2.expr();\n        }\n        if (hoisted.size() != 0){\n            return new IRESeq(new IRSeq(hoisted),new IRBinOp(node.opType(),e1,e2));\n        }\n        return node;\n    }\n    private IRNode defaultBinop(IRBinOp node){\n        ArrayList<IRStmt> stmts = new ArrayList<>();\n        String t1 = nxtTemp();\n        IRExpr e2 = node.right();\n        if (node.left() instanceof IRESeq ires1){\n            if (ires1.stmt() instanceof IRSeq seq){\n                stmts.addAll(seq.stmts());\n            }else{\n                stmts.add(ires1.stmt());\n            }\n            stmts.add(new IRMove(new IRTemp(t1), ires1.expr()));\n        }else{\n            stmts.add(new IRMove(new IRTemp(t1), node.left()));\n        }\n\n        if (node.right() instanceof IRESeq ires2){\n            if (ires2.stmt() instanceof IRSeq seq2){\n                stmts.addAll(seq2.stmts());\n            }else{\n                stmts.add(ires2.stmt());\n            }\n            e2 = ires2.expr();\n        }\n//        System.out.println(new IRSeq(stmts));\n        return new IRESeq(new IRSeq(stmts),\n                new IRBinOp(node.opType(),new IRTemp(t1),e2));\n    }\n\n    // canonical\n    private IRNode canon(IRConst node){\n        return node;\n    }\n    // canonical\n    private IRNode canon(IRLabel node){\n        return node;\n    }\n    // canonical\n    private IRNode canon(IRName node){\n        return node;\n    }\n    // canonical\n    private IRNode canon(IRTemp node) {\n        return node;\n    }\n    // MEM\n    private IRNode canon(IRMem node){\n        if (node.expr() instanceof IRESeq ireseq) { // lift expression\n            IRStmt svec = ireseq.stmt();\n            IRExpr ire = ireseq.expr();\n            return new IRESeq(svec, new IRMem(ire));\n        }\n        return node;\n    }\n    // Conditional Jump\n    private IRNode canon(IRCJump node){\n        if (node.cond() instanceof IRESeq ireseq) {\n            ArrayList<IRStmt> stmts = new ArrayList<>();\n            if (ireseq.stmt() instanceof IRSeq seq){\n                stmts.addAll(seq.stmts());\n            }else{\n                stmts.add(ireseq.stmt());\n            }\n            IRExpr ire = ireseq.expr();\n            stmts.add(new IRCJump(ire, node.trueLabel(), node.falseLabel()));\n            return new IRSeq(stmts);\n        }\n        return node;\n    }\n    // Jump\n    private IRNode canon(IRJump node){\n        if (node.target() instanceof IRESeq ireseq) {\n            ArrayList<IRStmt> stmts = new ArrayList<>();\n            if (ireseq.stmt() instanceof IRSeq seq){\n                stmts.addAll(seq.stmts());\n            }else{\n                stmts.add(ireseq.stmt());\n            }\n            IRExpr ire = ireseq.expr();\n            stmts.add(new IRJump(ire));\n            return new IRSeq(stmts);\n        }\n        return node;\n    }\n    // ESEQ\n    private IRNode canon(IRESeq node){\n        if (node.expr() instanceof IRESeq ireseq) {\n            IRExpr ire = ireseq.expr();\n            ArrayList<IRStmt> stmts = new ArrayList<>();\n            if (node.stmt() instanceof  IRSeq seqNode){\n                stmts.addAll(seqNode.stmts());\n            }else{\n                stmts.add(node.stmt());\n            }\n            if (ireseq.stmt() instanceof IRSeq seq){\n                stmts.addAll(seq.stmts());\n            }else{\n                stmts.add(ireseq.stmt());\n            }\n            return new IRESeq(new IRSeq(stmts), ire);\n        }\n        return node;\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/aar226_akc55_ayc62_ahl88/src/edu/cornell/cs/cs4120/xic/ir/visit/IRLoweringVisitor.java b/src/main/java/aar226_akc55_ayc62_ahl88/src/edu/cornell/cs/cs4120/xic/ir/visit/IRLoweringVisitor.java
--- a/src/main/java/aar226_akc55_ayc62_ahl88/src/edu/cornell/cs/cs4120/xic/ir/visit/IRLoweringVisitor.java	(revision 137b8dcdeb1aca20b3213df9b3e6a81ac1fee394)
+++ b/src/main/java/aar226_akc55_ayc62_ahl88/src/edu/cornell/cs/cs4120/xic/ir/visit/IRLoweringVisitor.java	(date 1679017398650)
@@ -540,7 +540,8 @@
 
     // to do
     private boolean doesBinopCommunte(IRBinOp node){
-        return false;
+        IRExpr right = node.right();
+        return !(right instanceof IRESeq); // can commute if right side not eseq
     }
 
     private IRNode commuteBinop(IRBinOp node){
