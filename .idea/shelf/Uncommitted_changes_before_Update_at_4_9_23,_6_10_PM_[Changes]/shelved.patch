Index: src/main/java/aar226_akc55_ayc62_ahl88/asm/ASMCompUnit.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package aar226_akc55_ayc62_ahl88.asm;\n\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.ASMInstruction;\nimport aar226_akc55_ayc62_ahl88.src.polyglot.util.Pair;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\n\npublic class ASMCompUnit {\n\n    HashMap<String, long[]> globals;\n    HashMap<String, ArrayList<ASMInstruction>> functionToInstructionList;\n    HashMap<String, HashSet<String>> functionToTempsMapping;\n\n    HashMap<String, Pair<Integer,Integer>> allFunctionsSigs;\n\n    public ASMCompUnit(HashMap<String, long[]> globals, HashMap<String, ArrayList<ASMInstruction>> functions,\n    HashMap<String, HashSet<String>> functionToTemps, HashMap<String, Pair<Integer,Integer>> funcs){\n        this.globals = globals;\n        functionToInstructionList = functions;\n        functionToTempsMapping = functionToTemps;\n        allFunctionsSigs = funcs;\n    }\n\n    public HashMap<String, ArrayList<ASMInstruction>> getFunctionToInstructionList() {\n        return functionToInstructionList;\n    }\n\n    public HashMap<String, long[]> getGlobals() {\n        return globals;\n    }\n\n    public HashMap<String, HashSet<String>> getFunctionToTempsMapping() {\n        return functionToTempsMapping;\n    }\n\n    public HashMap<String, Pair<Integer, Integer>> getAllFunctionsSigs() {\n        return allFunctionsSigs;\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder out = new StringBuilder(\"ASMCompUnit{\" + \"globals=\");\n        for (Map.Entry<String, long[]> kv: globals.entrySet()){\n            out.append(kv.toString());\n        }\n        out.append(\"\\n functionToInstructionList=\");\n        for (Map.Entry<String, ArrayList<ASMInstruction>> kv: functionToInstructionList.entrySet()){\n            out.append(kv.getKey()).append(\":\");\n            for (ASMInstruction instr: kv.getValue()){\n                out.append(instr).append(\"\\n\");\n            }\n        }\n        out.append(\"\\n functionToTempsMapping=\");\n        for (Map.Entry<String, HashSet<String>> kv: functionToTempsMapping.entrySet()){\n            out.append(kv.toString()).append(\"\\n\");\n        }\n        out.append('}');\n\n        out.append(\"\\n allFunctions =\");\n        for (Map.Entry<String, Pair<Integer,Integer>> kv: allFunctionsSigs.entrySet()){\n            out.append(kv.toString()).append(\"\\n\");\n        }\n        out.append('}');\n        return out.toString();\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/aar226_akc55_ayc62_ahl88/asm/ASMCompUnit.java b/src/main/java/aar226_akc55_ayc62_ahl88/asm/ASMCompUnit.java
--- a/src/main/java/aar226_akc55_ayc62_ahl88/asm/ASMCompUnit.java	(revision ec07600bf2d84dd9fa3d423ad0e7c551ac9bfa1a)
+++ b/src/main/java/aar226_akc55_ayc62_ahl88/asm/ASMCompUnit.java	(date 1681078096703)
@@ -10,13 +10,13 @@
 
 public class ASMCompUnit {
 
-    HashMap<String, long[]> globals;
+    HashSet<ASMData> globals;
     HashMap<String, ArrayList<ASMInstruction>> functionToInstructionList;
     HashMap<String, HashSet<String>> functionToTempsMapping;
 
     HashMap<String, Pair<Integer,Integer>> allFunctionsSigs;
 
-    public ASMCompUnit(HashMap<String, long[]> globals, HashMap<String, ArrayList<ASMInstruction>> functions,
+    public ASMCompUnit(HashSet<ASMData> globals, HashMap<String, ArrayList<ASMInstruction>> functions,
     HashMap<String, HashSet<String>> functionToTemps, HashMap<String, Pair<Integer,Integer>> funcs){
         this.globals = globals;
         functionToInstructionList = functions;
@@ -28,7 +28,7 @@
         return functionToInstructionList;
     }
 
-    public HashMap<String, long[]> getGlobals() {
+    public HashSet<ASMData> getGlobals() {
         return globals;
     }
 
@@ -43,8 +43,8 @@
     @Override
     public String toString() {
         StringBuilder out = new StringBuilder("ASMCompUnit{" + "globals=");
-        for (Map.Entry<String, long[]> kv: globals.entrySet()){
-            out.append(kv.toString());
+        for (ASMData data: globals){
+            out.append(data);
         }
         out.append("\n functionToInstructionList=");
         for (Map.Entry<String, ArrayList<ASMInstruction>> kv: functionToInstructionList.entrySet()){
Index: src/main/java/aar226_akc55_ayc62_ahl88/src/edu/cornell/cs/cs4120/xic/ir/visit/AbstractASMVisitor.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package aar226_akc55_ayc62_ahl88.src.edu.cornell.cs.cs4120.xic.ir.visit;\n\nimport aar226_akc55_ayc62_ahl88.asm.*;\nimport aar226_akc55_ayc62_ahl88.asm.Expressions.*;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.ASMArg2;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.ASMComment;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.ASMInstruction;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.ASMLabel;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.arithmetic.ASMAdd;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.arithmetic.ASMSub;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.jumps.ASMJumpNotEqual;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.mov.ASMMov;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.mov.ASMMovabs;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.stackops.ASMPop;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.stackops.ASMPush;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.subroutine.ASMCall;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.subroutine.ASMEnter;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.subroutine.ASMLeave;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.subroutine.ASMRet;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.tstcmp.ASMTest;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.jumps.ASMJumpAlways;\nimport aar226_akc55_ayc62_ahl88.src.edu.cornell.cs.cs4120.xic.ir.*;\nimport aar226_akc55_ayc62_ahl88.src.polyglot.util.InternalCompilerError;\nimport aar226_akc55_ayc62_ahl88.src.polyglot.util.Pair;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\n\n/**\n * NOTES:\n * - branches: use cmp then corresponding jump\n * - multireturn: store first argument in rax, push rest on stack\n * - function args: rdi, rsi, rdx, rcx, r8, r9, push rest on stack\n * - callee saved: rbx, rbp, and r12â€“r15\n * - caller saved: everything else\n *\n * THINGS WE NEEEEEEEEEEEDDDDDDDDD\n * - ir compunit ->\n *      add glob mem locations\n *      call visit to all functions\n * - ir func decl ->\n *      create new label at the top for function name\n *      follow abi for args and register alloc\n *      call visit on each statement\n *      flatten arraylist we get back\n *      follow abi for correct func exit\n * - jump -> jr <label name>\n * - cjump ->\n *      two args: cmp <t1> <t2>; j<flag> <label name>\n *      if instance of IRConst and is boolliteral: true -> jr / false -> nothing\n * - move ->\n *      mooooooooooooove\n *      contains expr: used for dynamic tiling\n *      tiling\n * - mem\n * - binop\n * - call stmt ->\n *      init function call follow abi for function call (store func args correctly)\n *      jump to function\n *      clean accroding to ABI spec (be careful about multireturns and stack dead space)\n *      pop from function\n * - IR Label -> ASM label\n *\n *\n * Generic ASM Class will be called ASMNode\n */\n\npublic class AbstractASMVisitor {\n    private int tempCnt = 0;\n\n    private HashMap<String,HashSet<String>> functionToTemps = new HashMap<>();\n\n    private HashMap<String, Pair<Integer,Integer>> functionsNameToSig = new HashMap<>();\n    private String curFunction;\n\n    private ASMTempExpr munchIRExpr(IRExpr e, ArrayList<ASMInstruction> instrs) {\n        if (e instanceof IRBinOp) {\n            IRBinOp binop = (IRBinOp) e;\n\n            ASMTempExpr l1 = munchIRExpr(binop.left(), instrs);\n            ASMTempExpr l2 = munchIRExpr(binop.right(), instrs);\n\n            switch (binop.opType()) {\n                case ADD:\n                    instrs.add(new ASMArg2(ASMOpCodes.ADD, l1, l2));\n                case MUL:\n                    instrs.add(new ASMArg2(ASMOpCodes.IMUL, l1, l2));\n                case DIV:\n                    instrs.add(new ASMArg2(ASMOpCodes.IDIV, l1, l2));\n                case SUB:\n                    instrs.add(new ASMArg2(ASMOpCodes.SUB, l1, l2));\n                default:\n            }\n            return l1;\n        }\n        return null;\n    }\n    private String nxtTemp() {\n        return String.format(\"_ASMReg_t%d\", (tempCnt++));\n    }\n    private ASMDirectives getType(String name) {\n        String type = name.split(\"_\")[0];\n        if (type.equals(\"i\") || type.equals(\"b\")) {\n            return ASMDirectives.QUAD;\n        }\n        return ASMDirectives.ZERO;\n    }\n    // converts an IR TEMP to an ASM TEMP\n    private ASMTempExpr tempToASM(IRTemp t) {\n        return new ASMTempExpr(t.name());\n    }\n    // change te parameters if needed\n    private ArrayList<ASMInstruction> cJumpBinop(IRBinOp binop){\n        ArrayList<ASMInstruction> instructions = new ArrayList<ASMInstruction>();\n//        switch (binop.opType()) {\n//            case EQ:\n//            case NEQ:\n//            case LT:\n//            case ULT:\n//            case GT:\n//            case LEQ:\n//            case GEQ:\n////                ASMArg2 instr1 = new ASMCmp(binop.left(), binop.right());\n//\n//        }\n        return instructions;\n    }\n\n    public ArrayList<ASMInstruction> visit(IRData node){\n        ArrayList<ASMInstruction> instructions = new ArrayList<ASMInstruction>();\n\n        return instructions;\n    }\n    public ArrayList<ASMInstruction> visit(IRCJump node) {\n        ArrayList<ASMInstruction> instructions = new ArrayList<ASMInstruction>();\n\n        IRExpr condition = node.cond();\n\n        if (condition instanceof IRBinOp c) {\n            // create function for IRBINOP\n            // DO A CMP instead\n            return cJumpBinop(c);\n        } else if (condition instanceof IRConst c) {\n            if (c.value() != 0L){ // jump\n                instructions.add(new ASMJumpAlways(new ASMNameExpr(node.trueLabel())));\n            }\n        } else if (condition instanceof IRTemp c) {\n            functionToTemps.get(curFunction).add(c.name());\n            ASMTempExpr tempName = tempToASM(c);\n            instructions.add(new ASMTest(tempName,tempName));\n            instructions.add(new ASMJumpNotEqual(new ASMNameExpr(node.trueLabel())));\n            //test t, t\n            //jnz l\n        } else if (condition instanceof IRMem c) {\n            ASMTempExpr tempForMem = new ASMTempExpr(nxtTemp());\n            // accept mem for this temp\n            // add move instruction\n            // do temp test and ASM Jump no Equal\n            return null;\n        }else{\n            throw new InternalCompilerError(\"CJUMP guard has another type\");\n        }\n        return instructions;\n    }\n    public ASMCompUnit visit(IRCompUnit node) {\n        HashMap<String, long[]> globals = new HashMap<>();\n        HashMap<String, ArrayList<ASMInstruction>> functionToInstructionList = new HashMap<>();\n        HashMap<String, HashSet<String>> functionToTempsMapping = new HashMap<>();\n        for (IRData data : node.dataMap().values()) {\n            ASMLabel data_label = new ASMLabel(data.name());\n//            ASMData data_instr = new ASMData(getType(data.name()), new ASMConstExpr(data.data()));\n            // add to ASMCOMP UNIT GLOBAL\n        }\n\n        for (IRFuncDecl func : node.functions().values()) {\n            curFunction = func.name();\n            functionToTemps.put(func.name(),new HashSet<>());\n            ArrayList<ASMInstruction> functionInstructions = visit(func);\n            functionToTempsMapping.put(curFunction,functionToTemps.get(curFunction));\n            functionToInstructionList.put(curFunction,functionInstructions);\n//            replaceTemps(functionInstructions,curFunction);\n//            instructions.addAll(functionInstructions);\n        }\n\n        return new ASMCompUnit(globals,functionToInstructionList,functionToTempsMapping,functionsNameToSig);\n    }\n    public ArrayList<ASMInstruction> visit (IRConst x) {\n        ArrayList<ASMInstruction> instructions = new ArrayList<ASMInstruction>();\n        boolean isInt = x.value() <= Integer.MAX_VALUE && x.value() >= Integer.MIN_VALUE;\n        ASMArg2 instruction = (isInt) ? new ASMMov(new ASMTempExpr(nxtTemp()),new ASMConstExpr(x.value()))\n                : new ASMMovabs(new ASMTempExpr(nxtTemp()),new ASMConstExpr(x.value()));\n        instructions.add(instruction);\n        return instructions;\n    }\n    public ArrayList<ASMInstruction> visit(IRFuncDecl node) {\n        ArrayList<ASMInstruction> result = new ArrayList<>();\n\n        // create new Starting label for this Function\n        result.add(new ASMLabel(node.name()));\n\n//        enter at Botoom\n//        push rbp\n//        mov rbp rsp\n//        sub rsp, 8*l\n//        result.add(new ASMPush(new ASMRegisterExpr(\"rbp\")));\n//        result.add(new ASMMov(new ASMRegisterExpr(\"rbp\"),new ASMRegisterExpr(\"rsp\")));\n\n        // need to calculate number of temporaries used\n\n        ArrayList<String> temps = new ArrayList<>();\n        // foo(1,2,3,4,5,6,7....) -> rdi, rsi, rdx, rcx, r8, r9, stack\n        int numParams = node.functionSig.inputTypes.size();\n        int numReturns = node.functionSig.outputTypes.size();\n        IRSeq body = (IRSeq) node.body();\n        for (int i = 0; i< numParams;i++){\n            IRMove nameAndArg = (IRMove) body.stmts().get(i);\n            IRTemp name = (IRTemp) nameAndArg.target();\n            temps.add(name.name());\n        }\n        ArrayList<ASMInstruction> bodyInstructions = new ArrayList<>();\n\n        if (numReturns > 2){\n            functionToTemps.get(curFunction).add(\"_returnBase\");\n            bodyInstructions.add(new ASMMov(\n                    new ASMTempExpr(\"_returnBase\"),\n                    new ASMRegisterExpr(\"rdi\")\n            ));\n        }\n\n        int start = numReturns > 2 ? 2: 1;\n        int end   = numReturns > 2 ? numParams +1: numParams;\n        for (int i = start; i<=end;i++){\n\n            // Move arg into argI. argI <- RDI\n            ASMExpr ARGI = switch (i) {\n                case 1 -> new ASMRegisterExpr(\"rdi\");\n                case 2 -> new ASMRegisterExpr(\"rsi\");\n                case 3 -> new ASMRegisterExpr(\"rdx\");\n                case 4 -> new ASMRegisterExpr(\"rcx\");\n                case 5 -> new ASMRegisterExpr(\"r8\");\n                case 6 -> new ASMRegisterExpr(\"r9\");\n                default ->\n                        new ASMMemExpr(\n                                new ASMBinOpAddExpr(\n                                        new ASMRegisterExpr(\"rbp\"),\n                                        new ASMConstExpr(8L * (i - 7 + 2))));\n            };\n//            String tempName = \"_ARG\" + i;\n            String tempName = numReturns > 2 ? temps.get(i-2):temps.get(i-1);\n            functionToTemps.get(curFunction).add(tempName);\n            // can't do [stack location] <- [stack location2]\n            // need intermediate rax <- [stack location2]\n            // then [stack location] <- temp rax\n//            if (i>=7){\n//                bodyInstructions.add(new ASMMov(new ASMRegisterExpr(\"rax\"),ARGI));\n//                bodyInstructions.add(new ASMMov(new ASMTempExpr(tempName),new ASMRegisterExpr(\"rax\")));\n//            }\n//            // just do MOV [stack location] <- register\n//            else{\n//                bodyInstructions.add(new ASMMov(new ASMTempExpr(tempName),ARGI));\n//            }\n            bodyInstructions.add(new ASMMov(new ASMTempExpr(tempName),ARGI));\n        }\n        if (node.body() instanceof  IRSeq seq){\n            for (int i = numParams;i< seq.stmts().size();i++){\n                IRStmt stmt = seq.stmts().get(i);\n                bodyInstructions.addAll(stmt.accept(this));\n            }\n        }else{\n            throw new InternalCompilerError(\"body isn't a seq\");\n        }\n        // add enter at begin.\n        // enter 8*L, 0\n        ASMEnter begin = new ASMEnter(new ASMConstExpr(8L*functionToTemps.get(curFunction).size()),new ASMConstExpr(0));\n        result.add(begin);\n        result.addAll(bodyInstructions);\n        return result;\n    }\n    public ArrayList<ASMInstruction> visit(IRJump jump) {\n        ArrayList<ASMInstruction> instructions = new ArrayList<>();\n        if (jump.target() instanceof IRName) {\n            instructions.add(new ASMJumpAlways(new ASMNameExpr(jump.label())));\n        }\n        return instructions;\n    }\n    public ArrayList<ASMInstruction> visit(IRLabel node) {\n        ArrayList<ASMInstruction> instructions = new ArrayList<ASMInstruction>();\n        instructions.add(new ASMLabel(node.name()));\n        return instructions;\n    }\n    // Always use these three rax, rcx, and rdx\n    public ArrayList<ASMInstruction> visit(IRMove node){\n        IRExpr dest = node.target();\n        IRExpr source = node.source();\n        ArrayList<ASMInstruction> instructions = new ArrayList<>();\n//        if (dest instanceof IRTemp t1 && source instanceof IRTemp t2){ // random case for testing atm\n//            functionToTemps.get(curFunction).add(t1.name());\n//            functionToTemps.get(curFunction).add(t2.name());\n//            instructions.add(new ASMMov(new ASMTempExpr(t1.name()),new ASMTempExpr(t2.name())));\n//        }else if (dest instanceof IRTemp t1 && source instanceof IRConst x){\n//            functionToTemps.get(curFunction).add(t1.name());\n//            boolean isInt = x.value() <= Integer.MAX_VALUE && x.value() >= Integer.MIN_VALUE;\n//            ASMArg2 instruction = (isInt) ? new ASMMov(new ASMTempExpr(t1.name()),new ASMConstExpr(x.value()))\n//                    : new ASMMovabs(new ASMTempExpr(t1.name()),new ASMConstExpr(x.value()));\n//            instructions.add(instruction);\n//        }else{\n//            throw new InternalCompilerError(\"TODO Other moves\");\n//        }\n\n        // TEMP TEMP\n        if (dest instanceof IRTemp t1 && source instanceof IRTemp t2) { // random case for testing atm\n            tileTempTemp(t1, t2, instructions);\n        // TEMP CONST\n        } else if (dest instanceof IRTemp t && source instanceof IRConst x) {\n            tileTempConst(t, x, instructions);\n        // TEMP MEM\n        } else if (dest instanceof IRTemp t && source instanceof IRMem m) {\n            tileTempMem(t, m, instructions);\n        // TEMP BINOP\n        } else if (dest instanceof IRTemp t && source instanceof IRBinOp b) {\n            tileTempBinop(t, b, instructions);\n        // MEM TEMP\n        } else if (dest instanceof IRMem m && source instanceof IRTemp t) {\n            tileMemTemp(m, t, instructions);\n        // MEM MEM\n        } else if (dest instanceof IRMem m1 && source instanceof IRMem m2) {\n            tileMemMem(m1, m2, instructions);\n        // MEM CONST\n        } else if (dest instanceof IRMem m && source instanceof IRConst x) {\n            tileMemConst(m, x, instructions);\n        // MEM BINOP\n        } else if (dest instanceof IRMem m && source instanceof IRBinOp b) {\n            tileMemBinop(m, b, instructions);\n        } else {\n            throw new InternalCompilerError(\"TODO Other moves\");\n        }\n        return instructions;\n    }\n\n    public long tileTempTemp(IRTemp t1, IRTemp t2, ArrayList<ASMInstruction> instrs) {\n        instrs.add(new ASMMov(new ASMTempExpr(t1.name()), new ASMTempExpr(t2.name())));\n        return 1;\n    }\n\n    public long tileTempConst(IRTemp t, IRConst c, ArrayList<ASMInstruction> instrs) {\n        instrs.add(new ASMMov(new ASMTempExpr(t.name()), new ASMConstExpr(c.value())));\n        return 1;\n    }\n\n    public long tileTempMem(IRTemp t, IRMem m, ArrayList<ASMInstruction> instrs) {\n        ASMTempExpr temp = munchIRExpr(m, instrs);\n        instrs.add(new ASMMov(new ASMTempExpr(t.name()), temp));\n        return 1 + m.bestCost;\n    }\n    public long tileTempBinop(IRTemp t, IRBinOp b, ArrayList<ASMInstruction> instrs) {\n        ASMTempExpr temp = munchIRExpr(b, instrs);\n        instrs.add(new ASMMov(new ASMTempExpr(t.name()), temp));\n        return 1 + b.bestCost;\n    }\n    public long tileMemTemp(IRMem m, IRTemp t, ArrayList<ASMInstruction> instrs) {\n        ASMTempExpr temp = munchIRExpr(m, instrs);\n        instrs.add(new ASMMov(temp, new ASMTempExpr(t.name())));\n        return 1 + m.bestCost;\n    }\n    public long tileMemMem(IRMem m1, IRMem m2, ArrayList<ASMInstruction> instrs) {\n        ASMTempExpr temp1 = munchIRExpr(m1, instrs);\n        ASMTempExpr temp2 = munchIRExpr(m2, instrs);\n        instrs.add(new ASMMov(temp1, temp2));\n        return m1.bestCost + m2.bestCost;\n    }\n    public long tileMemConst(IRMem m, IRConst c, ArrayList<ASMInstruction> instrs) {\n        ASMTempExpr temp = munchIRExpr(m, instrs);\n        instrs.add(new ASMMov(temp, new ASMConstExpr(c.value())));\n        return 1 + m.bestCost;\n    }\n    public long tileMemBinop(IRMem m, IRBinOp b, ArrayList<ASMInstruction> instrs) {\n        ASMTempExpr temp1 = munchIRExpr(m, instrs);\n        ASMTempExpr temp2 = munchIRExpr(b, instrs);\n        instrs.add(new ASMMov(temp1, temp2));\n        return m.bestCost + b.bestCost;\n    }\n\n    public ArrayList<ASMInstruction> visit(IRSeq node){\n        ArrayList<ASMInstruction> instructions = new ArrayList<ASMInstruction>();\n        for (IRStmt stmt : node.stmts()) {\n            ArrayList<ASMInstruction> stmtInstrs = stmt.accept(this);\n            instructions.addAll(stmtInstrs);\n        }\n        return instructions;\n    }\n    public ArrayList<ASMInstruction> visit(IRReturn node) {\n        //\n        ArrayList<ASMInstruction> returnInstructions = new ArrayList<>();\n        int returnSize = node.rets().size();\n\n        ArrayList<String> tempNames = new ArrayList<>();\n        //in case returns stop being temporaries in the future.\n        for (IRExpr e: node.rets()){\n             if (e instanceof IRTemp t){\n                tempNames.add(t.name());\n             }else{\n                 System.out.println(\"return is not a temp? \" + e);\n                 String nxtName = nxtTemp();\n                 tempNames.add(nxtName);\n                 ASMTempExpr tmp = new ASMTempExpr(nxtName);\n                 // need to translate\n                 throw new InternalCompilerError(\"return has an element that isn't a temp\");\n             }\n        }\n        functionToTemps.get(curFunction).addAll(tempNames);\n        // looping in reverse so rax can be used temporarily until the end\n        for (int i = 1; i <= returnSize; i++) {\n            // move expression to Return Location\n            // Move ret into reti. reti <- RDI\n            ASMExpr retI = switch (i) {\n                case 1 -> new ASMRegisterExpr(\"rax\");\n                case 2 -> new ASMRegisterExpr(\"rdx\");\n                default -> new ASMMemExpr(\n                        new ASMBinOpAddExpr(\n                                new ASMTempExpr(\"_returnBase\"),\n                                new ASMConstExpr(8L*(i-3))));\n            };\n//\n//            if (i >2){\n//                if (i == 3){\n//                    returnInstructions.add(new ASMMov(new ASMRegisterExpr(\"rsi\"),\n//                            new ASMTempExpr(\"_returnBase\")));\n//                }\n//                System.out.println(\"greater than 3\");\n//                // just in case we just put everything on the stack lol need intermediate\n//                // rcx <- [origin]\n//                returnInstructions.add(new ASMMov(new ASMRegisterExpr(\"rcx\"),new ASMTempExpr(tempNames.get(i-1)))); // check this\n//                // [dest] <- rcx\n//                returnInstructions.add(new ASMMov(retI,new ASMRegisterExpr(\"rcx\")));\n//            }else{\n//                returnInstructions.add(new ASMMov(retI,new ASMTempExpr(tempNames.get(i-1))));\n//            }\n            returnInstructions.add(new ASMMov(retI,new ASMTempExpr(tempNames.get(i-1))));\n        }\n\n        // leave\n        // ret\n        returnInstructions.add(new ASMLeave());\n        returnInstructions.add(new ASMRet());\n        return returnInstructions;\n    }\n    public ArrayList<ASMInstruction> visit(IRCallStmt node) {\n        ArrayList<ASMInstruction> instructions = new ArrayList<>();\n        IRName functionName = (IRName) node.target();\n        int argSiz = node.args().size();\n        ArrayList<String> tempNames = new ArrayList<>();\n        //in case returns stop being temporaries in the future.\n        // Will have to revisit translation too if we change iRCALLSTMT\n        // Move the Push translations to later\n        for (IRExpr e: node.args()){\n            if (e instanceof IRTemp t){\n                tempNames.add(t.name());\n            }else{\n                System.out.println(\"call is not a temp? \" + e);\n                String nxtName = nxtTemp();\n                tempNames.add(nxtName);\n                ASMTempExpr tmp = new ASMTempExpr(nxtName);\n                // need to translate\n                throw new InternalCompilerError(\"return has an element that isn't a temp\");\n            }\n        }\n        functionToTemps.get(curFunction).addAll(tempNames);\n        instructions.add(new ASMComment(\"Add Padding\",functionName.name()));\n        // add extra stack space for returns\n        if (node.n_returns() >2){\n            instructions.add(new ASMSub(\n                    new ASMRegisterExpr(\"rsp\"),\n                    new ASMConstExpr(8* (node.n_returns()-2))));\n            instructions.add(new ASMMov(\n                    new ASMRegisterExpr(\"rdi\"),\n                    new ASMRegisterExpr(\"rsp\")));\n        }\n        // pushes for Arguments\n        if (argSiz >= 6){\n            int end = node.n_returns() > 2 ? 6 : 7;\n            int ind = tempNames.size();\n            while (ind >= end){\n                instructions.add(new ASMPush(new ASMTempExpr(tempNames.get(ind-1))));\n                ind--;\n            }\n        }\n        int start = node.n_returns() > 2 ? Math.min(argSiz+1,6): Math.min(argSiz,6);\n        int end = node.n_returns() > 2 ? 2 : 1;\n        for (int i = start; i >= end; i--) {\n            // move expression from temp to required register\n            // Move ret into reti. reti <- RDI\n            ASMExpr argI = switch (i) {\n                case 1 -> new ASMRegisterExpr(\"rdi\");\n                case 2 -> new ASMRegisterExpr(\"rsi\");\n                case 3 -> new ASMRegisterExpr(\"rdx\");\n                case 4 -> new ASMRegisterExpr(\"rcx\");\n                case 5 -> new ASMRegisterExpr(\"r8\");\n                case 6 -> new ASMRegisterExpr(\"r9\");\n                default -> throw new InternalCompilerError(\"should not be in default for Function Call\");\n            };\n            int loc = node.n_returns() > 2? i-2: i-1;\n            String tempName = tempNames.get(loc);\n            instructions.add(new ASMMov(argI,new ASMTempExpr(tempName)));\n        }\n        // Align by 16 bytes I have no idea how\n        functionsNameToSig.put(functionName.name(),new Pair<>(argSiz,node.n_returns().intValue()));\n        instructions.add(new ASMCall(new ASMNameExpr(functionName.name())));\n\n        if (argSiz > 6 && node.n_returns() <= 2){\n            instructions.add(new ASMAdd(new ASMRegisterExpr(\"rsp\"),\n                    new ASMConstExpr(8L*(argSiz-6))));\n        }else if (argSiz > 5 && node.n_returns() > 2){\n//            System.out.println(\"im here\");\n            instructions.add(new ASMAdd(new ASMRegisterExpr(\"rsp\"),\n                    new ASMConstExpr(8L*(argSiz-5))));\n        }\n        String ret = \"_RV\";\n        for (int i = 1; i<= node.n_returns();i++){\n            ASMTempExpr temp = new ASMTempExpr(ret+i);\n            if (i == 1){\n                instructions.add(new ASMMov(temp,new ASMRegisterExpr(\"rax\")));\n            }else if (i == 2){\n                instructions.add(new ASMMov(temp,new ASMRegisterExpr(\"rdx\")));\n            }else{\n                instructions.add(new ASMPop(temp));\n            }\n        }\n        instructions.add(new ASMComment(\"Undo Padding\",functionName.name()));\n        return instructions;\n    }\n\n    public ArrayList<ASMInstruction> visit(IRExp irExp) {\n        System.out.println(\"don't have irExp\");\n        return new ArrayList<>();\n    }\n\n    public ArrayList<ASMInstruction> visit(IRTemp irTemp) {\n        return null;\n    }\n\n    public ArrayList<ASMInstruction> visit(IRName irName) {\n        return null;\n    }\n\n    public ArrayList<ASMInstruction> visit(IRMem irMem) {\n        return null;\n    }\n\n    public ArrayList<ASMInstruction> visit(IRBinOp irBinOp) {\n        return null;\n    }\n\n    public ArrayList<ASMInstruction> visit(IRESeq ireSeq) {\n        System.out.println(\"don't have ireSeq\");\n        return new ArrayList<>();\n    }\n\n    public ArrayList<ASMInstruction> visit(IRCall irCall) {\n        System.out.println(\"don't have irCall\");\n        return new ArrayList<>();\n    }\n\n    private ArrayList<ASMInstruction> visitExpression(IRExpr expr) {\n        if (expr instanceof IRBinOp bop)\n            return visit(bop);\n        else if (expr instanceof IRCallStmt call)\n            return visit(call);\n        else if (expr instanceof IRConst cnst)\n            return visit(cnst);\n        else if (expr instanceof IRMem mem)\n            return visit(mem);\n        else if (expr instanceof IRName name)\n            return visit(name);\n        else if (expr instanceof IRTemp tmp)\n            return visit(tmp);\n        else throw new InternalCompilerError(\"Invalid expression for visitExpression\");\n    }\n\n    private void replaceTemps(ArrayList<ASMInstruction> instructions, String functionName){\n        functionToTemps.get(functionName);\n        int index = 1;\n        HashMap<String, Integer> tempToStack = new HashMap<>();\n        for (String temp: functionToTemps.get(functionName)){\n            tempToStack.put(temp,index*8);\n            index++;\n        }\n        for (ASMInstruction instr: instructions){\n            instr.createPrint(tempToStack);\n            System.out.println(instr);\n        }\n    }\n\n    // TODO: 4/1/2023\n    // move\n    // TODO: 4/1/2023\n    // temp\n    // TODO: 4/1/2023\n    // mem\n    // TODO: 4/1/2023\n    // call_stmt\n    // TODO: 4/1/2023\n    // name\n    // TODO: 4/1/2023\n    // RETURN\n}\n\n//    int index = numParams;\n//            while (index < seq.stmts().size()){\n//        IRStmt stmt = seq.stmts().get(index);\n//        bodyInstructions.addAll(stmt.accept(this));\n//        if (stmt instanceof IRCallStmt call){\n//        int rvMoves = Math.toIntExact(call.n_returns());\n//        for (int i = 1; i <= rvMoves;i++){\n//        int getInd = (rvMoves + i-1);\n//        IRMove nameAndArg = (IRMove) body.stmts().get(getInd);\n//        IRTemp name = (IRTemp) nameAndArg.target();\n//        ASMTempExpr retName = new ASMTempExpr(name.name());\n//        if (i == 1){\n//        bodyInstructions.add(new ASMMov(retName,new ASMRegisterExpr(\"rax\")));\n//        }else if (i == 2){\n//        bodyInstructions.add(new ASMMov(retName,new ASMRegisterExpr(\"rdx\")));\n//        }else{\n//        bodyInstructions.add(new ASMPop(retName));\n//        }\n//        }\n//        index += rvMoves+1;\n//        }else{\n//        index++;\n//        }\n//        }
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/aar226_akc55_ayc62_ahl88/src/edu/cornell/cs/cs4120/xic/ir/visit/AbstractASMVisitor.java b/src/main/java/aar226_akc55_ayc62_ahl88/src/edu/cornell/cs/cs4120/xic/ir/visit/AbstractASMVisitor.java
--- a/src/main/java/aar226_akc55_ayc62_ahl88/src/edu/cornell/cs/cs4120/xic/ir/visit/AbstractASMVisitor.java	(revision ec07600bf2d84dd9fa3d423ad0e7c551ac9bfa1a)
+++ b/src/main/java/aar226_akc55_ayc62_ahl88/src/edu/cornell/cs/cs4120/xic/ir/visit/AbstractASMVisitor.java	(date 1681078232713)
@@ -164,12 +164,13 @@
         return instructions;
     }
     public ASMCompUnit visit(IRCompUnit node) {
-        HashMap<String, long[]> globals = new HashMap<>();
+        HashSet<ASMData> globals = new HashSet<>();
         HashMap<String, ArrayList<ASMInstruction>> functionToInstructionList = new HashMap<>();
         HashMap<String, HashSet<String>> functionToTempsMapping = new HashMap<>();
         for (IRData data : node.dataMap().values()) {
             ASMLabel data_label = new ASMLabel(data.name());
-//            ASMData data_instr = new ASMData(getType(data.name()), new ASMConstExpr(data.data()));
+            ASMData data_instr = new ASMData(data_label, data.data());
+            globals.add(data_instr);
             // add to ASMCOMP UNIT GLOBAL
         }
 
Index: src/main/java/aar226_akc55_ayc62_ahl88/asm/ASMData.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package aar226_akc55_ayc62_ahl88.asm;\n\nimport aar226_akc55_ayc62_ahl88.asm.Expressions.ASMExpr;\n\npublic class ASMData {\n    public ASMData(ASMDirectives op, ASMExpr expr) {\n\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/aar226_akc55_ayc62_ahl88/asm/ASMData.java b/src/main/java/aar226_akc55_ayc62_ahl88/asm/ASMData.java
--- a/src/main/java/aar226_akc55_ayc62_ahl88/asm/ASMData.java	(revision ec07600bf2d84dd9fa3d423ad0e7c551ac9bfa1a)
+++ b/src/main/java/aar226_akc55_ayc62_ahl88/asm/ASMData.java	(date 1681078110813)
@@ -1,9 +1,15 @@
 package aar226_akc55_ayc62_ahl88.asm;
 
-import aar226_akc55_ayc62_ahl88.asm.Expressions.ASMExpr;
+import aar226_akc55_ayc62_ahl88.asm.Instructions.ASMLabel;
 
 public class ASMData {
-    public ASMData(ASMDirectives op, ASMExpr expr) {
 
+    private long[] data;
+    public ASMData(ASMLabel label, long[] data) {
+        this.data = data;
+    }
+
+    public long[] getData() {
+        return data;
     }
 }
Index: src/main/java/aar226_akc55_ayc62_ahl88/asm/visit/RegisterAllocationTrivialVisitor.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package aar226_akc55_ayc62_ahl88.asm.visit;\n\nimport aar226_akc55_ayc62_ahl88.asm.ASMCompUnit;\nimport aar226_akc55_ayc62_ahl88.asm.ASMOpCodes;\nimport aar226_akc55_ayc62_ahl88.asm.Expressions.*;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.*;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.bitwise.ASMAnd;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.mov.ASMMov;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.mov.ASMMovabs;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.stackops.ASMPop;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.stackops.ASMPush;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.subroutine.ASMCall;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.subroutine.ASMEnter;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.subroutine.ASMLeave;\nimport aar226_akc55_ayc62_ahl88.src.polyglot.util.InternalCompilerError;\nimport aar226_akc55_ayc62_ahl88.src.polyglot.util.Pair;\n\nimport java.util.*;\n\npublic class RegisterAllocationTrivialVisitor implements ASMVisitor<ArrayList<ASMInstruction>>{\n\n\n    // push these 3 whenever we enter this function ez\n\n    HashMap<String, HashSet<String>> functionToTemps = new HashMap<>();\n    HashMap<String,HashMap<String,Long>> functionToTempsToStackOffset = new HashMap<>();\n\n    HashMap<String, Pair<Integer,Integer>> functionSignatures;\n    String currentFunction;\n\n    public ArrayList<ASMInstruction> visit(ASMCompUnit compUnit){\n        functionSignatures = compUnit.getAllFunctionsSigs();\n        ArrayList<ASMInstruction> total = new ArrayList<>();\n        for (Map.Entry<String, long[]> global: compUnit.getGlobals().entrySet()){\n            System.out.println(\"doing Global\");\n        }\n        for (Map.Entry<String, ArrayList<ASMInstruction>> function: compUnit.getFunctionToInstructionList().entrySet()){\n            currentFunction = function.getKey();\n            functionToTempsToStackOffset.put(currentFunction,new HashMap<>());\n            functionToTemps.put(currentFunction,new HashSet<>());\n            ArrayList<ASMInstruction> updatedInstructions = fixAllStackAlignments(function);\n            ASMEnter newEnter = createEnterAndBuildMapping(function.getValue());\n            ArrayList<ASMInstruction> functionResult = new ArrayList<>();\n            for (ASMInstruction instr: updatedInstructions){\n                if (!(instr instanceof ASMEnter oldEnter)) {\n                    functionResult.addAll(instr.accept(this));\n                }else{\n                    System.out.println(\"oldEnter: \"+ oldEnter + \" newEnter: \" + newEnter);\n                    functionResult.add(newEnter);\n                    functionResult.add(new ASMPush(new ASMRegisterExpr(\"r12\")));\n                    functionResult.add(new ASMPush(new ASMRegisterExpr(\"r13\")));\n                    functionResult.add(new ASMPush(new ASMRegisterExpr(\"r14\")));\n                }\n            }\n            total.addAll(functionResult);\n        }\n        return total;\n    }\n    @Override\n    public ArrayList<ASMInstruction> visit(ASMComment node) {\n        ArrayList<ASMInstruction> result = new ArrayList<>();\n        result.add(node);\n        return result;\n    }\n    @Override\n    public ArrayList<ASMInstruction> visit(ASMLabel node) {\n        ArrayList<ASMInstruction> result = new ArrayList<>();\n        result.add(node);\n        return result;\n    }\n    @Override\n    public ArrayList<ASMInstruction> visit(ASMArg0 node) { // leave, ret\n        ArrayList<ASMInstruction> res = new ArrayList<>();\n        if (node instanceof ASMLeave){\n            res.add(new ASMPop(new ASMRegisterExpr(\"r14\")));\n            res.add(new ASMPop(new ASMRegisterExpr(\"r13\")));\n            res.add(new ASMPop(new ASMRegisterExpr(\"r12\")));\n        }\n        res.add(node);\n        return res;\n    }\n\n    // CALL SOLO\n    // JUMPS, INC, DEC, NOT, IDIV, POP, PUSH,\n    @Override\n    public ArrayList<ASMInstruction> visit(ASMArg1 node) {\n//        ArrayList<String> availReg = new ArrayList<>(Arrays.asList(\"rax\", \"rcx\",\"rdx\"));\n        ArrayList<String> availReg = new ArrayList<>(Arrays.asList(\"r12\", \"r13\",\"r14\"));\n        ArrayList<ASMInstruction> res = new ArrayList<>();\n        if (node instanceof ASMCall call){\n            // align stack if needed unalign after too dont know how to undo\n//            res.add(new ASMAnd(new ASMRegisterExpr(\"rsp\"),new ASMConstExpr(-16))); // possible to revert idk?\n//            System.out.println(call.toString());\n//            System.out.println(doWeNeedstackAlignment(call));\n//            res.add(call);\n            if (doWeNeedstackAlignment(call.getLeft().toString())){\n//                res.add(new ASMArg2(ASMOpCodes.SUB, new ASMRegisterExpr(\"rsp\"), new ASMConstExpr(8)));\n                res.add(call);\n//                res.add(new ASMArg2(ASMOpCodes.ADD, new ASMRegisterExpr(\"rsp\"), new ASMConstExpr(8)));\n            }else{\n                res.add(call);\n            }\n\n        }else{\n            ASMExpr argument = node.getLeft();\n            if (argument instanceof ASMTempExpr temp){ // migrate temp to stack?\n                String curReg = availReg.get(availReg.size()-1);\n                availReg.remove(availReg.size()-1);\n                // add the move\n                ASMMemExpr stackLoc = tempToStack(temp);\n                ASMRegisterExpr usedReg = new ASMRegisterExpr(curReg);\n                res.add(new ASMMov(usedReg,stackLoc)); // fake reg on stack now moved to real\n                res.add(new ASMArg1(node.getOpCode(),usedReg)); // original instruction with real reg\n                res.add(new ASMMov(stackLoc,usedReg)); // move the real reg back to the stack location\n            }else if (argument instanceof ASMMemExpr mem){ // see if inside mem is temp\n                ArrayList<ASMExpr> expressions = flattenMem(mem);\n                HashMap<String, String> tempToReg= new HashMap<>();\n                for (ASMExpr expr: expressions){\n                    if (expr instanceof ASMTempExpr temp){\n                        // get stack mapping for reg\n                        String curReg = availReg.get(availReg.size()-1);\n                        availReg.remove(availReg.size()-1);\n                        // add the move\n                        ASMMemExpr stackLoc = tempToStack(temp);\n                        ASMRegisterExpr usedReg = new ASMRegisterExpr(curReg);\n                        res.add(new ASMMov(usedReg,stackLoc));\n                        tempToReg.put(temp.getName(),curReg);\n                    }\n                }\n                ASMExpr tempMem = tempsToRegs(mem,tempToReg);\n                res.add(new ASMArg1(node.getOpCode(),tempMem));\n            }else if (argument instanceof ASMConstExpr cons){\n                throw new InternalCompilerError(\"TODO CONST 1 ARG\");\n            }\n\n            else{ // no change instruction Jumps\n                res.add(node);\n            }\n        }\n        return res;\n    }\n\n//    ENTER,MOV,MOVABS,\n//    r64, r/m64 ADD,SUB,AND,OR,XOR,SHL,SHR,SAR,TEST,CMP,\n    @Override\n    public ArrayList<ASMInstruction> visit(ASMArg2 node) {\n//        ArrayList<String> availReg = new ArrayList<>(Arrays.asList(\"rax\", \"rcx\",\"rdx\"));\n        ArrayList<String> availReg = new ArrayList<>(Arrays.asList(\"r12\", \"r13\",\"r14\"));\n        ASMExpr left = node.getLeft();\n        ASMExpr right = node.getRight();\n\n        ArrayList<ASMInstruction> res = new ArrayList<>();\n        ArrayList<ASMInstruction> postInstruction = new ArrayList<>();\n        ASMOpCodes opCodes = node.getOpCode();\n        ASMExpr curDest = null; // replace Left with curDest\n        ASMExpr curSrc = null;  // replace Right with curSrc\n        if (node instanceof ASMEnter enter){\n            throw new InternalCompilerError(\"enter TODO replace this enter with function One\");\n        }\n\n        if (left instanceof ASMRegisterExpr reg){// known register Return\n            curDest = left;\n            availReg.remove(reg.getRegisterName());\n        }else if (left instanceof ASMTempExpr temp){ // Move left into Reg1 cause left is a stack location\n            // get the stack location through mapping\n            String curReg = availReg.get(availReg.size()-1);\n            availReg.remove(availReg.size()-1);\n            // add the move\n            ASMMemExpr stackLoc = tempToStack(temp);\n            ASMRegisterExpr usedReg = new ASMRegisterExpr(curReg);\n            res.add(new ASMMov(usedReg,stackLoc));\n            postInstruction.add(new ASMMov(stackLoc,usedReg));\n            curDest = usedReg;\n        }else if (left instanceof ASMMemExpr mem){ // Mem\n            // find the memory locations of the temps inside of mem pass in current avail Regs\n            ArrayList<ASMExpr> expressions = flattenMem(mem);\n            HashMap<String, String> tempToReg= new HashMap<>();\n            for (ASMExpr expr: expressions){\n                if (expr instanceof ASMTempExpr temp){\n                    // get stack mapping for reg\n                    String curReg = availReg.get(availReg.size()-1);\n                    availReg.remove(availReg.size()-1);\n                    // add the move\n                    ASMMemExpr stackLoc = tempToStack(temp);\n                    ASMRegisterExpr usedReg = new ASMRegisterExpr(curReg);\n                    res.add(new ASMMov(usedReg,stackLoc));\n                    tempToReg.put(temp.getName(),curReg);\n                }\n            }\n            curDest = tempsToRegs(mem,tempToReg);\n        }else{\n            throw new InternalCompilerError(\"nothing else should be left on the top level\");\n        }\n\n        // need intermediate steps cause both can't be mem\n        // need extra reg\n        if (!(left instanceof ASMMemExpr)){ // left is mem\n            if (right instanceof ASMTempExpr temp) {\n                // Move temp into reg2 cause temp is a stack location\n                String curReg = availReg.get(availReg.size()-1);\n                availReg.remove(availReg.size()-1);\n                // add the move\n                ASMMemExpr stackLoc = tempToStack(temp);\n                ASMRegisterExpr usedReg = new ASMRegisterExpr(curReg);\n                res.add(new ASMMov(usedReg,stackLoc));\n                curSrc = usedReg;\n                // use reg 2 for right\n            } else if (right instanceof ASMMemExpr mem) {\n                // Move the temp in mem (if exist) into reg2 cause temp is a stack location\n                // Move the tempSecond in mem (if exist) into reg3 cause temp is a stack location\n                ArrayList<ASMExpr> expressions = flattenMem(mem);\n                HashMap<String, String> tempToReg= new HashMap<>();\n                for (ASMExpr expr: expressions){\n                    if (expr instanceof ASMTempExpr temp){\n                        // get stack mapping for reg\n                        String curReg = availReg.get(availReg.size()-1);\n                        availReg.remove(availReg.size()-1);\n                        // add the move\n                        ASMMemExpr stackLoc = tempToStack(temp);\n                        ASMRegisterExpr usedReg = new ASMRegisterExpr(curReg);\n                        res.add(new ASMMov(usedReg,stackLoc));\n                        tempToReg.put(temp.getName(),curReg);\n                    }\n                }\n                ASMExpr tempMem = tempsToRegs(mem,tempToReg);\n                String curReg = availReg.get(availReg.size()-1);\n                availReg.remove(availReg.size()-1);\n                // add the move\n                ASMRegisterExpr usedReg = new ASMRegisterExpr(curReg);\n                res.add(new ASMMov(usedReg,tempMem));\n                curSrc = usedReg;\n            } else if (right instanceof ASMConstExpr num) {\n                // Need an extra move if number is greater or less than max/min int\n                curSrc = isIMMTooBig(num,res,availReg); // adds extra instruction\n                boolean isInt = num.getValue() <= Integer.MAX_VALUE && num.getValue() >= Integer.MIN_VALUE;\n                if (!isInt){\n                    opCodes = ASMOpCodes.MOV;\n                }\n            } else { // ASM Register\n                curSrc = right;\n            }\n        }else{ // left is reg\n            if (right instanceof ASMTempExpr temp) {\n                // get the stack location through mapping\n                String curReg = availReg.get(availReg.size()-1);\n                availReg.remove(availReg.size()-1);\n                // add the move\n                ASMMemExpr stackLoc = tempToStack(temp);\n                ASMRegisterExpr usedReg = new ASMRegisterExpr(curReg);\n                res.add(new ASMMov(usedReg,stackLoc));\n                curSrc = usedReg;\n                // Move temp into reg2 cause temp is a stack location\n                // use reg 2 for right\n            } else if (right instanceof ASMMemExpr mem) { // can leave right side as mem\n                ArrayList<ASMExpr> expressions = flattenMem(mem);\n                HashMap<String, String> tempToReg= new HashMap<>();\n                for (ASMExpr expr: expressions){\n                    if (expr instanceof ASMTempExpr temp){\n                        // get stack mapping for reg\n                        String curReg = availReg.get(availReg.size()-1);\n                        availReg.remove(availReg.size()-1);\n                        // add the move\n                        ASMMemExpr stackLoc = tempToStack(temp);\n                        ASMRegisterExpr usedReg = new ASMRegisterExpr(curReg);\n                        res.add(new ASMMov(usedReg,stackLoc));\n                        tempToReg.put(temp.getName(),curReg);\n                    }\n                }\n                curSrc = tempsToRegs(mem,tempToReg);\n                // Move the temp in mem (if exist) into reg2 cause temp is a stack location\n                // Move the tempSecond in mem (if exist) into reg3 cause temp is a stack location\n            } else if (right instanceof ASMConstExpr num) {\n                // Need an extra move if number is greater or less than max/min int\n                curSrc = isIMMTooBig(num,res,availReg);\n                boolean isInt = num.getValue() <= Integer.MAX_VALUE && num.getValue() >= Integer.MIN_VALUE;\n                if (!isInt){\n                    opCodes = ASMOpCodes.MOV;\n                }\n            } else { // ASM Register\n                curSrc = right;\n            }\n        }\n        ASMArg2 reBuild = new ASMArg2(opCodes, curDest, curSrc);\n        res.add(reBuild);\n        res.addAll(postInstruction);\n//        System.out.println(\"Before\");\n//        System.out.println(node);\n//        System.out.println(\"AFTER\");\n//        for (ASMInstruction instr: res){\n//            System.out.println(instr);\n//        }\n        return res;\n    }\n\n    // imul dest, v1, v2 // dest = v1 * v2;\n    @Override\n    public ArrayList<ASMInstruction> visit(ASMArg3 node) {\n\n        return null;\n    }\n\n    /**\n     * Creates a new Instruction Enter for the number of locations on the stack needed.\n     * @param instructions\n     * @return\n     */\n    private ASMEnter createEnterAndBuildMapping(ArrayList<ASMInstruction> instructions){\n\n        HashSet<String> temps = functionToTemps.get(currentFunction);\n        for (ASMInstruction instr: instructions){\n            if (instr instanceof ASMArg1 arg1){\n                checkExprForTemp(arg1.getLeft(),temps);\n            }else if (instr instanceof  ASMArg2 arg2){\n                checkExprForTemp(arg2.getLeft(),temps);\n                checkExprForTemp(arg2.getRight(),temps);\n            }else if (instr instanceof ASMArg3 arg3){\n                checkExprForTemp(arg3.getA1(),temps);\n                checkExprForTemp(arg3.getA2(),temps);\n                checkExprForTemp(arg3.getA3(),temps);\n            }\n        }\n        long index = 1;\n        HashMap<String,Long> tempsToStack =  functionToTempsToStackOffset.get(currentFunction);\n        for (String temp: temps){\n            tempsToStack.put(temp,-8L*index);\n            index++;\n        }\n        return new ASMEnter(new ASMConstExpr(8L*temps.size()), new ASMConstExpr(0));\n    }\n\n\n    /**\n     * Check if Expression has any Temps\n     * @param expr\n     * @param temps\n     */\n    private void checkExprForTemp(ASMExpr expr, HashSet<String> temps){\n        if (expr == null){\n            return;\n        }\n        if (expr instanceof ASMTempExpr temp){\n            temps.add(temp.getName());\n        }else if (expr instanceof ASMMemExpr mem){\n            ArrayList<ASMExpr> res = flattenMem(mem);\n            for (ASMExpr ex: res){\n                if (ex instanceof ASMTempExpr temp){\n                    temps.add(temp.getName());\n                }\n            }\n        }else if (expr instanceof ASMBinOpExpr binop){\n            ArrayList<ASMExpr> res = flattenBinop(binop);\n            for (ASMExpr ex: res){\n                if (ex instanceof ASMTempExpr temp){\n                    temps.add(temp.getName());\n                }\n            }\n        }\n\n    }\n\n\n    /**\n     * Returns a list of all the ASM expressions inside the memory operand.\n     * @param mem\n     * @return\n     */\n    private ArrayList<ASMExpr> flattenMem(ASMMemExpr mem){\n        ArrayList<ASMExpr> res = new ArrayList<>();\n        if (mem.getMem() instanceof ASMBinOpExpr binop){\n            res.addAll(flattenBinop(binop));\n        }else{\n            res.add(mem);\n        }\n        return res;\n    }\n    /**\n     * Returns a list of all the ASM expressions inside the binop in a list\n     * @param binop\n     * @return\n     */\n    private ArrayList<ASMExpr> flattenBinop(ASMBinOpExpr binop){\n        ArrayList<ASMExpr> res = new ArrayList<>();\n        if (binop.getLeft() instanceof ASMBinOpExpr leftBinop){\n            res.addAll(flattenBinop(leftBinop));\n        }else{\n            res.add(binop.getLeft());\n        }\n        if (binop.getRight() instanceof ASMBinOpExpr rightBinop){\n            res.addAll(flattenBinop(rightBinop));\n        }else{\n            res.add(binop.getRight());\n        }\n        return res;\n    }\n    /**\n     * Maps the Temporary to the corresponding stack location\n     * @param temp\n     * @return the stack location of the temporary\n     */\n    private ASMMemExpr tempToStack(ASMTempExpr temp){\n        long index = functionToTempsToStackOffset.get(currentFunction).get(temp.getName());\n\n        return new ASMMemExpr(new ASMBinOpAddExpr(\n                new ASMRegisterExpr(\"rbp\"),\n                new ASMConstExpr(index)));\n    }\n\n    /**\n     * Checks if the immediate is too big and will insert an extra move and a register to\n     * make sure instruction sequence is valid.\n     * @param cons the constant we are checking\n     * @param instructions the current instructions that are in the arrayList\n     * @param availRegs up to the three registers we can use for this instruction\n     * @return\n     */\n    private ASMExpr isIMMTooBig(ASMConstExpr cons, ArrayList<ASMInstruction> instructions, ArrayList<String> availRegs){\n\n        boolean isInt = cons.getValue() <= Integer.MAX_VALUE && cons.getValue() >= Integer.MIN_VALUE;\n        if (!isInt){\n            String usedReg = availRegs.get(availRegs.size()-1);\n            availRegs.remove(availRegs.size()-1);\n            ASMRegisterExpr reg = new ASMRegisterExpr(usedReg);\n            ASMMovabs extraMove = new ASMMovabs(reg,cons);\n            instructions.add(extraMove);\n            return reg;\n        }else{\n            return cons;\n        }\n        // returns either a reg or the imm\n    }\n\n    /**\n     * Replace the temporaries found in memory with real registers assuming already mapped\n     * @param expr\n     * @param tempMapping\n     * @return\n     */\n    private ASMExpr tempsToRegs(ASMExpr expr, HashMap<String,String> tempMapping){\n        if (expr instanceof ASMTempExpr temp){ // base case\n            return new ASMRegisterExpr(tempMapping.get(temp.getName()));\n        }else if (expr instanceof ASMMemExpr mem){\n            return new ASMMemExpr(tempsToRegs(mem.getMem(),tempMapping));\n        }else if (expr instanceof ASMBinOpMultExpr binopMult){\n            return new ASMBinOpMultExpr(tempsToRegs(binopMult.getLeft(),tempMapping),\n                    tempsToRegs(binopMult.getRight(),tempMapping));\n        }else if (expr instanceof ASMBinOpAddExpr binopAdd){\n            return new ASMBinOpAddExpr(tempsToRegs(binopAdd.getLeft(),tempMapping),\n                    tempsToRegs(binopAdd.getRight(),tempMapping));\n        }else{ // other base case\n            return expr;\n        }\n    }\n\n    /**\n     * Returns whether we need stack alignment or stack. Assumes We found number of temps required already\n     * @param calledFunction\n     * @return true if we need to insert stackalignment.\n     */\n    private boolean doWeNeedstackAlignment(String calledFunction) {\n\n        int tempCount = functionToTemps.get(currentFunction).size();\n\n\n        int paramCount = functionSignatures.get(calledFunction).part1();\n        int returnCount = functionSignatures.get(calledFunction).part2();\n        int returnSpace = Math.max(returnCount - 2, 0);\n        int argSpace = Math.max(paramCount - (returnCount > 2 ? 5 : 6), 0);\n        int stackSize = 1 + 1 + 3 + tempCount + returnSpace + argSpace;\n        // rip, rbp, r12, r13, r14\n//        System.out.println(returnSpace);\n//        System.out.println(argSpace);\n//        System.out.println(tempCount);\n        return (stackSize & 1) != 0;\n    }\n\n\n    /**\n     * Fixes all stack Alignment issues\n     * @param function\n     */\n\n    private ArrayList<ASMInstruction> fixAllStackAlignments(Map.Entry<String,ArrayList<ASMInstruction>> function) {\n        ArrayList<ASMInstruction> alignedFunction = new ArrayList<>(function.getValue());\n        for (int i = 0 ;i< alignedFunction.size();i++){\n            ASMInstruction instr = alignedFunction.get(i);\n            if (instr instanceof ASMComment comment && comment.getComment().equals(\"Add Padding\")){\n                if (doWeNeedstackAlignment(comment.getFunctionName())){\n                    alignedFunction.set(i,new ASMArg2(ASMOpCodes.SUB, new ASMRegisterExpr(\"rsp\"), new ASMConstExpr(8)));\n                    // find end\n                    int undoIndex = undoComment(alignedFunction,i+1);\n                    alignedFunction.set(undoIndex,new ASMArg2(ASMOpCodes.SUB, new ASMRegisterExpr(\"rsp\"), new ASMConstExpr(8)));\n                }\n            }\n        }\n        return alignedFunction;\n\n    }\n    private int undoComment(ArrayList<ASMInstruction> instructionsList, int startIndex){\n        for (int i = startIndex;i < instructionsList.size();i++){\n            ASMInstruction instr = instructionsList.get(i);\n            if (instr instanceof ASMComment comment && comment.getComment().equals(\"Undo Padding\")){\n                return i;\n            }\n        }\n        throw new InternalCompilerError(\"did align properly and replace undo\");\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/aar226_akc55_ayc62_ahl88/asm/visit/RegisterAllocationTrivialVisitor.java b/src/main/java/aar226_akc55_ayc62_ahl88/asm/visit/RegisterAllocationTrivialVisitor.java
--- a/src/main/java/aar226_akc55_ayc62_ahl88/asm/visit/RegisterAllocationTrivialVisitor.java	(revision ec07600bf2d84dd9fa3d423ad0e7c551ac9bfa1a)
+++ b/src/main/java/aar226_akc55_ayc62_ahl88/asm/visit/RegisterAllocationTrivialVisitor.java	(date 1681078137285)
@@ -1,6 +1,7 @@
 package aar226_akc55_ayc62_ahl88.asm.visit;
 
 import aar226_akc55_ayc62_ahl88.asm.ASMCompUnit;
+import aar226_akc55_ayc62_ahl88.asm.ASMData;
 import aar226_akc55_ayc62_ahl88.asm.ASMOpCodes;
 import aar226_akc55_ayc62_ahl88.asm.Expressions.*;
 import aar226_akc55_ayc62_ahl88.asm.Instructions.*;
@@ -31,7 +32,7 @@
     public ArrayList<ASMInstruction> visit(ASMCompUnit compUnit){
         functionSignatures = compUnit.getAllFunctionsSigs();
         ArrayList<ASMInstruction> total = new ArrayList<>();
-        for (Map.Entry<String, long[]> global: compUnit.getGlobals().entrySet()){
+        for (ASMData d: compUnit.getGlobals()){
             System.out.println("doing Global");
         }
         for (Map.Entry<String, ArrayList<ASMInstruction>> function: compUnit.getFunctionToInstructionList().entrySet()){
Index: src/main/java/aar226_akc55_ayc62_ahl88/visitors/IRVisitor.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package aar226_akc55_ayc62_ahl88.visitors;\n\nimport aar226_akc55_ayc62_ahl88.Main;\nimport aar226_akc55_ayc62_ahl88.OptimizationTypes;\nimport aar226_akc55_ayc62_ahl88.asm.Expressions.ASMConstExpr;\nimport aar226_akc55_ayc62_ahl88.asm.Expressions.ASMTempExpr;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.ASMInstruction;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.mov.ASMMov;\nimport aar226_akc55_ayc62_ahl88.newast.Dimension;\nimport aar226_akc55_ayc62_ahl88.newast.Program;\nimport aar226_akc55_ayc62_ahl88.newast.Type;\nimport aar226_akc55_ayc62_ahl88.newast.Use;\nimport aar226_akc55_ayc62_ahl88.newast.declarations.*;\nimport aar226_akc55_ayc62_ahl88.newast.definitions.Globdecl;\nimport aar226_akc55_ayc62_ahl88.newast.definitions.Method;\nimport aar226_akc55_ayc62_ahl88.newast.definitions.MultiGlobalDecl;\nimport aar226_akc55_ayc62_ahl88.newast.expr.*;\nimport aar226_akc55_ayc62_ahl88.newast.expr.arrayaccessexpr.ArrayAccessExpr;\nimport aar226_akc55_ayc62_ahl88.newast.expr.arrayliteral.ArrayValueLiteral;\nimport aar226_akc55_ayc62_ahl88.newast.expr.binop.boolbop.*;\nimport aar226_akc55_ayc62_ahl88.newast.expr.binop.intbop.IntOutBinop;\nimport aar226_akc55_ayc62_ahl88.newast.expr.binop.intbop.PlusBinop;\nimport aar226_akc55_ayc62_ahl88.newast.expr.unop.booluop.NotUnop;\nimport aar226_akc55_ayc62_ahl88.newast.expr.unop.intuop.IntegerNegExpr;\nimport aar226_akc55_ayc62_ahl88.newast.stmt.*;\nimport aar226_akc55_ayc62_ahl88.newast.stmt.declstmt.DeclAssignStmt;\nimport aar226_akc55_ayc62_ahl88.newast.stmt.declstmt.DeclNoAssignStmt;\nimport aar226_akc55_ayc62_ahl88.newast.stmt.declstmt.MultiDeclAssignStmt;\nimport aar226_akc55_ayc62_ahl88.src.edu.cornell.cs.cs4120.xic.ir.*;\nimport aar226_akc55_ayc62_ahl88.src.edu.cornell.cs.cs4120.xic.ir.IRBinOp;\nimport aar226_akc55_ayc62_ahl88.src.edu.cornell.cs.cs4120.xic.ir.IRConst;\nimport aar226_akc55_ayc62_ahl88.src.edu.cornell.cs.cs4120.xic.ir.IRExpr;\nimport aar226_akc55_ayc62_ahl88.src.edu.cornell.cs.cs4120.xic.ir.IRNode;\nimport aar226_akc55_ayc62_ahl88.src.polyglot.util.InternalCompilerError;\nimport org.apache.commons.text.StringEscapeUtils;\n\nimport javax.naming.Name;\nimport java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class IRVisitor implements Visitor<IRNode>{\n    private static final int WORD_BYTES = 8;\n    private static final String OUT_OF_BOUNDS = \"_eta_out_of_bounds\";\n    private int labelCnt;\n    private int tempCnt;\n    private int stringCnt;\n    private final String compUnitName;\n    private ArrayList<String> globalIds;\n    private boolean constantFold;\n    private ArrayList<IRData> string_consts;\n    public IRVisitor(String name) {\n        labelCnt = 0;\n        tempCnt = 0;\n        stringCnt = 1;\n        compUnitName = name;\n        string_consts = new ArrayList<>();\n        constantFold = Main.opts.isSet(OptimizationTypes.CONSTANT_FOLDING);\n    }\n    private String nxtLabel() {\n        return String.format(\"l%d\", (labelCnt++));\n    }\n    private String nxtTemp() {\n        return String.format(\"t%d\", (tempCnt++));\n    }\n    private String nxtString() {\n        return String.format(\"string_const%d\", (stringCnt++));\n    }\n\n    @Override\n    public IRExpr visit(IntOutBinop node) {\n//        DIVIDE, HIGHMULT, MINUS, MODULO, TIMES\n        Expr e1 = node.getLeftExpr();\n        Expr e2 = node.getRightExpr();\n\n        IRExpr ire1 = e1.accept(this);\n        IRExpr ire2 = e2.accept(this);\n        IRBinOp.OpType op = node.getOpType();\n\n        if (constantFold && ire1.isConstant() && ire2.isConstant()) {\n            long e1int = ire1.constant();\n            long e2int = ire2.constant();\n\n            switch (op) {\n                case DIV: if (e2int != 0) {\n                    return new IRConst(e1int / e2int);\n                }\n                    throw new Error(\"DIVIDE BY ZERO\");\n                case HMUL: BigInteger a = BigInteger.valueOf(e1int).multiply(BigInteger.valueOf(e2int));\n                            return new IRConst(a.shiftRight(64).longValue());\n                case SUB: return new IRConst(e1int - e2int);\n                case MOD: if (e2int != 0) {\n                    return new IRConst(e1int % e2int);\n                }\n                    throw new Error(\"DIVIDE BY ZERO\");\n                case MUL: return new IRConst(e1int * e2int);\n                default: throw new Error(\"NOT INTEGER ARITHMETIC BINOP\");\n            }\n        }\n        return new IRBinOp(op, ire1, ire2);\n    }\n\n    private IRExpr plusArrays(IRExpr ire1, IRExpr ire2){\n        String size1 = nxtTemp();\n        String size2 = nxtTemp();\n        String size3 = nxtTemp();\n\n        String savedire1 = nxtTemp();\n        String savedire2 = nxtTemp();\n        IRMove calc1 = new IRMove(new IRTemp(savedire1),ire1);\n        IRMove calc2 = new IRMove(new IRTemp(savedire2),ire2);\n        IRMove get_size1 = new IRMove(new IRTemp(size1), new IRMem( //store size1\n                new IRBinOp(IRBinOp.OpType.SUB, new IRTemp(savedire1), new IRConst(WORD_BYTES))));\n        IRMove get_size2 = new IRMove(new IRTemp(size2), new IRMem( // store size2\n                new IRBinOp(IRBinOp.OpType.SUB,new IRTemp(savedire2), new IRConst(WORD_BYTES))));\n        IRMove get_size3 = new IRMove(new IRTemp(size3), // size3 <= size1 + size2\n                new IRBinOp(IRBinOp.OpType.ADD, new IRTemp(size1), new IRTemp(size2)));\n\n        // 8*n+8\n        IRBinOp malloc_size = new IRBinOp(IRBinOp.OpType.ADD,\n                new IRBinOp(IRBinOp.OpType.MUL,\n                        new IRTemp(size3),\n                        new IRConst(WORD_BYTES)),\n                new IRConst(WORD_BYTES));\n\n        String head_pointer = nxtTemp();\n        IRCallStmt alloc_call = new IRCallStmt(new IRName(\"_eta_alloc\"), 1L, malloc_size);\n//        IRMove malloc_move = new IRMove(new IRTemp(head_pointer),alloc_call);\n        IRSeq malloc_move = new IRSeq(alloc_call,new IRMove(new IRTemp(head_pointer), new IRTemp(\"_RV1\")));\n\n        IRMove move_len = new IRMove(new IRMem(new IRTemp(head_pointer)),new IRTemp(size3));\n        // move len into -1\n\n        // increment pointer to head\n        IRBinOp add_8 = new IRBinOp(IRBinOp.OpType.ADD,new IRTemp(head_pointer), new IRConst(WORD_BYTES));\n        IRMove inc_pointer_to_head = new IRMove(new IRTemp(head_pointer),add_8);\n        // do all the top level shit first\n        IRSeq top_level_Order = new IRSeq(calc1,calc2,get_size1,get_size2,get_size3,malloc_move,move_len,inc_pointer_to_head);\n\n        /* START LOOP 1 */\n        // now time to recrusively alloc\n        String lh = nxtLabel();\n        String l1 = nxtLabel();\n        String le = nxtLabel();\n        String counter = nxtTemp();\n        IRBinOp guard = new IRBinOp(IRBinOp.OpType.LT,new IRTemp(counter), new IRTemp(size1));\n        // set counter = 0;\n        IRMove set0Counter = new IRMove(new IRTemp(counter), new IRConst(0));\n        IRLabel whileHead = new IRLabel(lh);\n        // check if counter < irExp\n        IRCJump loopCheck = new IRCJump(guard,l1,le);\n        IRLabel whileBody = new IRLabel(l1);\n        // create memory location for destination\n        IRMem leftMem = new IRMem(\n                new IRBinOp(IRBinOp.OpType.ADD,\n                        new IRBinOp(IRBinOp.OpType.MUL,new IRConst(WORD_BYTES),new IRTemp(counter)),\n                        new IRTemp(head_pointer))\n        );\n\n        IRMem rightMem = new IRMem(\n                new IRBinOp(IRBinOp.OpType.ADD,\n                        new IRBinOp(IRBinOp.OpType.MUL,new IRConst(WORD_BYTES),new IRTemp(counter)),\n                        new IRTemp(savedire1))\n        );\n\n        IRMove load_element = new IRMove(leftMem, rightMem);\n        IRMove inc_counter = new IRMove(new IRTemp(counter),\n                new IRBinOp(IRBinOp.OpType.ADD, new IRTemp(counter), new IRConst(1)));\n        // jump back to loop head\n        IRJump go_back_to_head = new IRJump(new IRName(lh));\n        IRLabel afterLoop = new IRLabel(le);\n\n        IRSeq loopComponent1 = new IRSeq(set0Counter,whileHead,loopCheck,whileBody,\n                load_element,inc_counter,go_back_to_head,afterLoop);\n        /* END LOOP 1 */\n\n        /* START LOOP 2 */\n        String lh2 = nxtLabel();\n        String l12 = nxtLabel();\n        String le2 = nxtLabel();\n        String counter2 = nxtTemp();\n        IRBinOp guard2 = new IRBinOp(IRBinOp.OpType.LT,new IRTemp(counter2), new IRTemp(size2));\n        // set counter = 0;\n        IRMove set0Counter2 = new IRMove(new IRTemp(counter2), new IRConst(0));\n        IRLabel whileHead2 = new IRLabel(lh2);\n        // check if counter < irExp\n        IRCJump loopCheck2 = new IRCJump(guard2,l12,le2);\n        IRLabel whileBody2 = new IRLabel(l12);\n        // create memory location for destination\n        IRMem leftMem2 = new IRMem(\n                new IRBinOp(IRBinOp.OpType.ADD,\n                        new IRBinOp(IRBinOp.OpType.MUL,new IRConst(WORD_BYTES),\n                                new IRBinOp(IRBinOp.OpType.ADD, new IRTemp(counter2), new IRTemp(size1))),\n                        new IRTemp(head_pointer))\n        );\n\n        IRMem rightMem2 = new IRMem(\n                new IRBinOp(IRBinOp.OpType.ADD,\n                        new IRBinOp(IRBinOp.OpType.MUL,new IRConst(WORD_BYTES),new IRTemp(counter2)),\n                        new IRTemp(savedire2))\n        );\n\n        IRMove load_element2 = new IRMove(leftMem2, rightMem2);\n        IRMove inc_counter2 = new IRMove(new IRTemp(counter2),\n                new IRBinOp(IRBinOp.OpType.ADD, new IRTemp(counter2), new IRConst(1)));\n        // jump back to loop head\n        IRJump go_back_to_head2 = new IRJump(new IRName(lh2));\n        IRLabel afterLoop2 = new IRLabel(le2);\n\n        IRSeq loopComponent2 = new IRSeq(set0Counter2,whileHead2,loopCheck2,whileBody2,\n                load_element2,inc_counter2,go_back_to_head2,afterLoop2);\n        /* END LOOP 2 */\n\n\n        IRSeq final_seq = new IRSeq(top_level_Order,loopComponent1, loopComponent2);\n        return new IRESeq(final_seq, new IRTemp(head_pointer));\n    }\n\n    @Override\n    public IRExpr visit(PlusBinop node) {\n\n        Expr e1 = node.getLeftExpr();\n        Expr e2 = node.getRightExpr();\n        IRExpr ire1 = e1.accept(this);\n        IRExpr ire2 = e2.accept(this);\n\n        // if both arrays, add\n        // if one unknown array and other array, return array\n        if  (e1.getNodeType().isArray() && e2.getNodeType().isArray()) {\n            if (e1.getNodeType().isUnknownArray() && !e2.getNodeType().isUnknownArray()) {\n                return ire2;\n            } else {\n                // ESEQ\n                // SEQ -> ACCEPT E1 -> MOVE E1 to new TEMP -> ACCEPT E2 -> MOVE E2 to new TEMP ->\n                // EXPR is the second ESEQ from plus arrays\n                return plusArrays(ire1,ire2);\n            }\n        }\n\n        // if both ints, return irbinop\n        // if one unknown and other int, return int\n        if (constantFold && ire1.isConstant() && ire2.isConstant()) {\n            return new IRConst(ire1.constant() + ire2.constant());\n        } else {\n                return new IRBinOp(IRBinOp.OpType.ADD, ire1, ire2);\n        }\n    }\n\n    @Override\n    public IRNode visit(IntegerComparisonBinop node) {\n//        < , <= , > , >=\n        Expr e1 = node.getLeftExpr();\n        Expr e2 = node.getRightExpr();\n\n        IRExpr ire1 = e1.accept(this);\n        IRExpr ire2 = e2.accept(this);\n        IRBinOp.OpType op = node.getOpType();\n\n        if (constantFold && ire1.isConstant() && ire2.isConstant()) {\n            long e1int = ire1.constant();\n            long e2int = ire2.constant();\n\n            return switch (op) {\n                case LT -> new IRConst(e1int < e2int ? 1 : 0);\n                case LEQ -> new IRConst(e1int <= e2int ? 1 : 0);\n                case GT -> new IRConst(e1int > e2int ? 1 : 0);\n                case GEQ -> new IRConst(e1int >= e2int ? 1 : 0);\n                default -> throw new Error(\"NOT INTEGER COMPARISON BINOP\");\n            };\n        }\n        return new IRBinOp(op, ire1, ire2);\n    }\n\n    @Override\n    public IRExpr visit(EquivalenceBinop node) {\n        Expr e1 = node.getLeftExpr();\n        Expr e2 = node.getRightExpr();\n\n        IRExpr ire1 = e1.accept(this);\n        IRExpr ire2 = e2.accept(this);\n        IRBinOp.OpType op = node.getOpType();\n\n        if (constantFold && ire1.isConstant() && ire2.isConstant()) {\n            long e1int = ire1.constant();\n            long e2int = ire2.constant();\n            return switch (op) {\n                case EQ -> new IRConst(e1int == e2int ? 1 : 0);\n                case NEQ -> new IRConst(e1int != e2int ? 1 : 0);\n                default -> throw new Error(\"NOT EQUIVALENCE COMPARISON BINOP\");\n            };\n        }\n        return new IRBinOp(op, ire1, ire2);\n    }\n\n    @Override\n    public IRExpr visit(LogicalBinop node) {\n        String l1 = nxtLabel();\n        String l2 = nxtLabel();\n        String lend = nxtLabel();\n        String x = nxtTemp();\n        Expr e1 = node.getLeftExpr();\n        Expr e2 = node.getRightExpr();\n        IRExpr ire1 = e1.accept(this);\n        IRExpr ire2 = e2.accept(this);\n\n        if (constantFold && ire1.isConstant() && ire2.isConstant()) {\n            return switch (node.getBinopType()) {\n                case AND -> new IRConst((ire1.constant() == 1)  && (ire2.constant() == 1)  ? 1 : 0);\n                case OR -> new IRConst((ire1.constant() == 1)  || (ire2.constant() == 1)  ? 1 : 0);\n                default -> throw new Error(\"NOT LOGICAL BINOP\");\n            };\n        }\n\n        return switch (node.getBinopType()) {\n            case AND -> new IRESeq(new IRSeq(new IRMove(new IRTemp(x), new IRConst(0)),\n                    new IRCJump(ire1, l1, lend),\n                    new IRLabel(l1), new IRCJump(ire2, l2, lend),\n                    new IRLabel(l2), new IRMove(new IRTemp(x), new IRConst(1)),\n                    new IRLabel(lend)),\n                    new IRTemp(x));\n            case OR -> new IRESeq(new IRSeq(new IRMove(new IRTemp(x), new IRConst(1)),\n                    new IRCJump(ire1, lend, l1),\n                    new IRLabel(l1), new IRCJump(ire2, lend, l2),\n                    new IRLabel(l2), new IRMove(new IRTemp(x), new IRConst(0)),\n                    new IRLabel(lend)),\n                    new IRTemp(x));\n            default -> throw new Error(\"NOT LOGICAL BINOP\");\n        };\n    }\n\n    @Override\n    public IRExpr visit(NotUnop node) {\n        IRExpr ire = node.getE().accept(this);\n\n        if (constantFold && ire.isConstant()) {\n            return new IRConst(1-ire.constant());\n        }\n        return new IRBinOp(IRBinOp.OpType.XOR, new IRConst(1), ire);\n    }\n\n    @Override\n    public IRExpr visit(IntegerNegExpr node) {\n        IRExpr ire = node.getE().accept(this);\n        if (constantFold && ire.isConstant()) {\n            return new IRConst(-1 * ire.constant());\n        }\n        return new IRBinOp(IRBinOp.OpType.SUB, new IRConst(0), ire);\n    }\n\n    @Override\n    public IRExpr visit(BoolLiteral node) {\n        return new IRConst(node.boolVal ? 1 : 0);\n    }\n\n    @Override\n    public IRExpr visit(IntLiteral node) {\n        return new IRConst(node.number);\n    }\n\n    @Override\n    public IRExpr visit(Length node) {\n        String x = nxtTemp();\n        IRMem mem = new IRMem(new IRBinOp(IRBinOp.OpType.SUB, node.getArg().accept(this), new IRConst(WORD_BYTES)));\n        IRMove move = new IRMove(new IRTemp(x), mem);\n        return new IRESeq(move, new IRTemp(x));\n    }\n\n    @Override\n    public IRExpr visit(FunctionCallExpr node) {\n        IRName func = new IRName(genABIFunc(node.getFunctionSig(),node.getId()));\n        ArrayList<IRExpr> paramListIR = new ArrayList<>();\n        for (Expr param: node.getArgs()){\n            paramListIR.add(param.accept(this));\n        }\n        long num = node.getFunctionSig().outputTypes.size();\n        return new IRESeq(new IRCallStmt(func,num,paramListIR),new IRTemp(\"_RV1\"));\n//        return new IRESeq(new IRExp(new IRCall(func,paramListIR)),new IRTemp(\"_RV1\"));\n    }\n\n    @Override\n    public IRExpr visit(Id node) { // x = andy; this is only a\n        if (globalIds.contains(node.toString())){\n            return new IRMem(new IRName( \"_\" + node.toString()));\n        }\n        return new IRTemp(node.toString());\n    }\n\n    @Override\n    public IRExpr visit(ArrayValueLiteral node) { // Going to have to be DATA if String\n\n        if (node.getRaw() != null){ // it is a string\n            String stringName = nxtString();\n            long[] res  = new long[node.getValues().size()+1];\n            String escapeString  = StringEscapeUtils.unescapeJava(node.getRaw());\n            res[0] = escapeString.length();\n            for (int i = 0; i< escapeString.length();i++){\n                char c = escapeString.charAt(i);\n                res[i+1] = (int) c;\n            }\n            IRData str =  new IRData(stringName,res); // we never use lmao\n            string_consts.add(str);\n        }\n        String t = nxtTemp();   // temp label for malloc\n        ArrayList<Expr> values = node.getValues();\n        long n = values.size();\n        String l = nxtTemp();\n\n        // reg[l] <- length\n        IRMove length_to_l = new IRMove(new IRTemp(l), new IRConst(n));\n\n        // 8*n+8\n        IRBinOp size = new IRBinOp(IRBinOp.OpType.ADD,\n                new IRBinOp(IRBinOp.OpType.MUL,\n                        new IRTemp(l),\n                        new IRConst(WORD_BYTES)),\n                new IRConst(WORD_BYTES));\n\n        // CALL(NAME(malloc), size)\n        IRCallStmt alloc_call = new IRCallStmt(new IRName(\"_eta_alloc\"),1L, size);\n\n        // reg[t] <- call malloc\n        IRMove malloc_move = new IRMove(new IRTemp(t), new IRTemp(\"_RV1\"));\n\n        IRMove size_move = new IRMove(new IRMem(new IRTemp(t)), new IRTemp(l));\n\n        List<IRStmt> seq_list = new ArrayList<>(List.of(length_to_l, alloc_call, malloc_move, size_move));\n\n        for(int i = 0; i < n; i++) {\n            IRExpr ire = values.get(i).accept(this);\n            IRMove move_elmnt = new IRMove(new IRMem(new IRBinOp(\n                    IRBinOp.OpType.ADD,\n                    new IRTemp(t),\n                    new IRConst(8L*(i+1)))),\n                    ire );\n            seq_list.add(move_elmnt);\n        }\n\n        IRSeq ir_seq = new IRSeq(seq_list);\n\n        return new IRESeq(ir_seq,\n                new IRBinOp(IRBinOp.OpType.ADD,\n                        new IRTemp(t),\n                        new IRConst(WORD_BYTES)));\n\n    }\n    @Override\n    public IRExpr visit(ArrayAccessExpr node) {\n        IRExpr arrIR = node.getOrgArray().accept(this);\n        assert(node.getIndicies().size() >= 1);\n        return accessRecur(0,node.getIndicies(),arrIR);\n    }\n//\n\n    @Override\n    public IRStmt visit(Block node) {\n        ArrayList<Stmt> statements = node.getStatementList();\n        ArrayList<IRStmt> IRstmtList = new ArrayList<>();\n        for (Stmt stmt: statements) {\n            IRstmtList.add(stmt.accept(this));\n        }\n        return new IRSeq(IRstmtList);\n    }\n\n    @Override\n    public IRStmt visit(IfElse node) {\n        IRStmt iFStatement = node.getIfState().accept(this);\n        IRStmt elseStatement = node.getElseState().accept(this);\n        String lt = nxtLabel();\n        String lf = nxtLabel();\n        String lafter = nxtLabel();\n        IRStmt condStmt = booleanAsControlFlow(node.getGuard(),lt,lf);\n        IRJump endJmp = new IRJump(new IRName(lafter));\n        return new IRSeq(condStmt,\n                new IRLabel(lt),\n                iFStatement,\n                endJmp,\n                new IRLabel(lf),\n                elseStatement,\n                new IRLabel(lafter)\n        );\n    }\n\n    @Override\n    public IRStmt visit(IfOnly node) {\n        String l1 = nxtLabel();\n        String l2 = nxtLabel();\n        IRStmt condStmt = booleanAsControlFlow(node.guard,l1,l2);\n        IRStmt statement = node.ifState.accept(this);\n        return new IRSeq(condStmt,new IRLabel(l1),statement, new IRLabel(l2));\n    }\n\n    @Override\n    public IRStmt visit(ProcedureCall node) {\n        IRName func = new IRName(genABIFunc(node.getFunctionSig(),node.getIdentifier()));\n        ArrayList<IRExpr> paramListIR = new ArrayList<>();\n        for (Expr param: node.getParamList()){\n            paramListIR.add(param.accept(this));\n        }\n        return new IRCallStmt(func,1L,paramListIR);\n    }\n\n    @Override\n    public IRStmt visit(Return node) {\n        ArrayList<Expr> retList = node.getReturnArgList();\n        ArrayList<IRExpr> IRRet = new ArrayList<>();\n        for (Expr ret: retList){\n            IRRet.add(ret.accept(this));\n        }\n        return new IRReturn(IRRet);\n    }\n    @Override\n    public IRStmt visit(While node) {\n        String lh = nxtLabel();\n        String l1 = nxtLabel();\n        String le = nxtLabel();\n        IRStmt condStmt = booleanAsControlFlow(node.getGuard(),l1,le);\n        IRStmt bodyStmt = node.getStmt().accept(this);\n        return new IRSeq(\n                new IRLabel(lh),\n                condStmt,\n                new IRLabel(l1),\n                bodyStmt,\n                new IRJump(new IRName(lh)),\n                new IRLabel(le));\n    }\n    @Override\n    public IRStmt visit(DeclAssignStmt node) {\n        // might need to do call stmt\n        IRExpr right = node.getExpression().accept(this);\n//        IRExpr exec = node.getExpression() instanceof FunctionCallExpr ?\n//                new IRESeq(new IRExp(right),new IRTemp(\"_RV1\")): right;\n        String temp = nxtTemp();\n        IRMove extraMove = new IRMove(new IRTemp(temp),right);\n        IRExpr exec = node.getExpression() instanceof FunctionCallExpr ?\n                new IRESeq(new IRExp(right),new IRTemp(\"_RV1\")): new IRTemp(temp);\n\n        if (node.getDecl() instanceof AnnotatedTypeDecl atd){\n            if (atd.type.isArray()){\n                if (atd.type.dimensions.allEmpty){ // random init is fine\n                    return new IRSeq(extraMove, new IRMove(new IRTemp(atd.identifier.toString()),exec));\n                }else{\n                    IRExpr iden = atd.getIdentifier().accept(this); // x:int[e1][e2][e3]\n                    ArrayList<String> dimTemps = new ArrayList<>();\n                    ArrayList<IRStmt> dimValues = new ArrayList<>();\n                    for (Expr curExpr: atd.type.dimensions.indices){\n                        if (curExpr != null) {\n                            String tempVal = nxtTemp();\n                            IRExpr irExp = curExpr.accept(this);\n                            IRMove saveExpr = new IRMove(new IRTemp(tempVal), irExp);\n                            dimValues.add(saveExpr);\n                            dimTemps.add(tempVal);\n                        }else{\n                            dimTemps.add(null);\n                        }\n                    }\n                    ArrayList<IRStmt> initSequence = new ArrayList<>();\n                    initSequence.addAll(dimValues); // add a[foo(2,b)] add the side effects from the foos\n                    initSequence.add(initArrayDecl(0,dimTemps, iden)); // actually allocate\n                    return new IRSeq(initSequence); // passed in temp x\n//                    throw new InternalCompilerError(\"Gotta create init array malloc thing\");\n                }\n            }else if (atd.type.isBasic()){\n                return new IRSeq(extraMove,new IRMove(new IRTemp(atd.identifier.toString()),exec));\n            }\n            throw new InternalCompilerError(\"Annotated can only be array or basic\");\n        }else if (node.getDecl() instanceof ArrAccessDecl aad){\n            assert(aad.getIndices().size() >= 1);\n            if (aad.getFuncParams() ==  null){ // a[e1][e2]\n                IRExpr arrIdIR = aad.getIdentifier().accept(this);\n                IRExpr memComponent = accessRecur(0,aad.getIndices(), arrIdIR);\n                return new IRSeq(extraMove,new IRMove(memComponent,exec));\n            }else{ // g1(e1,e2)[4][5]\n                String funcName = genABIFunc(aad.getFunctionSig(),aad.getIdentifier());\n                ArrayList<IRExpr> argsList = new ArrayList<>();\n                for (Expr param: aad.getFuncParams()){\n                    argsList.add(param.accept(this));\n                }\n                IRCallStmt funcCall = new IRCallStmt(new IRName(funcName),1L,argsList);\n                IRESeq sideEffects = new IRESeq(funcCall, new IRTemp(\"_RV1\"));\n                IRExpr memComponent = accessRecur(0,aad.getIndices(), sideEffects);\n                return new IRSeq(extraMove,new IRMove(memComponent,exec));\n            }// find a[e1][e2]\n        }else if (node.getDecl() instanceof NoTypeDecl){\n            return new IRSeq(extraMove,new IRMove(node.getDecl().identifier.accept(this),exec));\n        }else if (node.getDecl() instanceof UnderScore){\n            return new IRSeq(extraMove,new IRExp(exec));\n        }\n        throw new InternalCompilerError(\"NOT A DECL?\");\n    }\n\n    @Override\n    public IRStmt visit(DeclNoAssignStmt node) {\n        if (!(node.getDecl() instanceof AnnotatedTypeDecl atd)){\n            throw new InternalCompilerError(\"no assign can only be annotated\");\n        }\n        return atd.accept(this);\n        //Annotated Type Decl\n\n        // ArrAccessDecl Can't\n\n        // No Type Decl  Can't\n\n        // UnderScore Can't\n    }\n\n    @Override\n    public IRStmt visit(MultiDeclAssignStmt node) {\n        List<IRExpr> right = node.getExpressions().stream().map(expr -> expr.accept(this)).toList();\n        ArrayList<Expr> exprs = node.getExpressions();\n        ArrayList<IRStmt> order =new ArrayList<>();\n        ArrayList<String> tempNames = new ArrayList<>();\n        if (exprs.get(0) instanceof FunctionCallExpr && exprs.size() == 1) {\n            order.add(new IRExp(right.get(0)));\n            for (int i = 0; i < node.getDecls().size(); i++) {\n                String tempName = nxtTemp();\n                IRMove curMove = new IRMove(new IRTemp(tempName), new IRTemp(\"_RV\" + (i + 1)));\n                order.add(curMove);\n                tempNames.add(tempName);\n            }\n        }else{\n            for (int i = 0; i< node.getDecls().size();i++){\n                IRExpr e = right.get(i);\n                String tempName = nxtTemp();\n                IRMove curMove = new IRMove(new IRTemp(tempName),e);\n                order.add(curMove);\n                tempNames.add(tempName);\n            }\n        }\n        for (int i = 0 ;i< node.getDecls().size();i++){ // need to check if global VAR\n            String curTemp = tempNames.get(i);\n            Decl d = node.getDecls().get(i);\n            if (d instanceof AnnotatedTypeDecl atd){\n                if (atd.type.isArray()){\n                    if (atd.type.dimensions.allEmpty){ // random init is fine\n                        order.add(new IRMove(new IRTemp(atd.identifier.toString()), new IRTemp(curTemp)));\n                    }else{\n                        IRExpr iden = atd.getIdentifier().accept(this); // x:int[e1][e2][e3]\n                        ArrayList<String> dimTemps = new ArrayList<>();\n                        ArrayList<IRStmt> dimValues = new ArrayList<>();\n                        for (Expr curExpr: atd.type.dimensions.indices){\n                            if (curExpr != null) {\n                                String tempVal = nxtTemp();\n                                IRExpr irExp = curExpr.accept(this);\n                                IRMove saveExpr = new IRMove(new IRTemp(tempVal), irExp);\n                                dimValues.add(saveExpr);\n                                dimTemps.add(tempVal);\n                            }else{\n                                dimTemps.add(null);\n                            }\n                        }\n                        ArrayList<IRStmt> initSequence = new ArrayList<>();\n                        initSequence.addAll(dimValues); // add a[foo(2,b)] add the side effects from the foos\n                        initSequence.add(initArrayDecl(0,dimTemps, iden)); // actually allocate\n                        order.add(new IRSeq(initSequence)); // passed in temp x\n//                            throw new InternalCompilerError(\"Gotta create init array malloc thing\");\n                    }\n                }else if (atd.type.isBasic()){\n                    order.add(new IRMove(new IRTemp(atd.identifier.toString()),new IRTemp(curTemp)));\n                }else {\n                    throw new InternalCompilerError(\"Annotated can only be array or basic\");\n                }\n            }else if (d instanceof ArrAccessDecl aad){\n                assert(aad.getIndices().size() >= 1);\n                if (aad.getFuncParams() ==  null){ // a[e1][e2]\n                    IRExpr arrIdIR = aad.getIdentifier().accept(this);\n                    IRExpr memComponent = accessRecur(0,aad.getIndices(), arrIdIR);\n                    order.add (new IRMove(memComponent,new IRTemp(curTemp)));\n                }else{ // g1(e1,e2)[4][5]\n                    String funcName = genABIFunc(aad.getFunctionSig(),aad.getIdentifier());\n                    ArrayList<IRExpr> argsList = new ArrayList<>();\n                    for (Expr param: aad.getFuncParams()){\n                        argsList.add(param.accept(this));\n                    }\n                    IRCallStmt funcCall = new IRCallStmt(new IRName(funcName),1L,argsList);\n                    IRESeq sideEffects = new IRESeq(funcCall, new IRTemp(\"_RV1\"));\n                    IRExpr memComponent = accessRecur(0,aad.getIndices(), sideEffects);\n                    order.add(new IRMove(memComponent,new IRTemp(curTemp)));\n                }// find a[e1][e2]\n            }else if (d instanceof NoTypeDecl){\n                order.add(new IRMove(d.identifier.accept(this),new IRTemp(curTemp))); // might need to check for Globals\n            }else if (d instanceof UnderScore){\n                order.add(new IRExp(new IRTemp(curTemp)));\n            }else {\n                throw new InternalCompilerError(\"NOT A DECL?\");\n            }\n        }\n        return new IRSeq(order);\n    }\n\n    @Override\n    public IRStmt visit(Globdecl node) { // going have to be IRDATA\n        // Don't visit create function that adds to Global MAP\n        return null;\n    }\n\n    @Override\n    public IRFuncDecl visit(Method node) {\n        ArrayList<IRStmt> stmtList = new ArrayList<>();\n        // MOVE ARGS INTO PARAMS\n        for (int i = 0;i < node.getDecls().size();i++){\n            AnnotatedTypeDecl atd = node.getDecls().get(i);\n            stmtList.add(new IRMove(new IRTemp(atd.identifier.toString()),new IRTemp(\"_ARG\" + (i+1))));\n        }\n\n        // EXECUTE BLOCK\n        stmtList.add(node.getBlock().accept(this)); // might need to move return inside\n        // ADD RET IF NEEDED\n        if (node.getBlock().getNodeType().getType() == Type.TypeCheckingType.UNIT){\n            stmtList.add(new IRReturn());\n        }\n\n        String abiName = genABIFunc(node.getFunctionSig(), node.getId());\n        // CREATE NODE\n        IRFuncDecl ret =  new IRFuncDecl(abiName, new IRSeq(stmtList));\n        ret.functionSig = node.getFunctionSig();\n        return ret;\n    }\n\n    @Override\n    public IRStmt visit(MultiGlobalDecl node) {\n    // Don't visit create function that adds to Global MAP\n        return null;\n    }\n\n    @Override // Visit only on No Assign\n    public IRStmt visit(AnnotatedTypeDecl node) { // could be IREXPR\n        if (node.type.isArray()){\n            if (node.type.dimensions.allEmpty){ // random init is fine\n                return new IRMove(new IRTemp(node.identifier.toString()),new IRConst(0));\n            }else{\n                IRExpr iden = node.getIdentifier().accept(this); // x:int[e1][e2][e3]\n                ArrayList<String> dimTemps = new ArrayList<>();\n                ArrayList<IRStmt> dimValues = new ArrayList<>();\n                for (Expr curExpr: node.type.dimensions.indices){\n                    if (curExpr != null) {\n                        String tempVal = nxtTemp();\n                        IRExpr irExp = curExpr.accept(this);\n                        IRMove saveExpr = new IRMove(new IRTemp(tempVal), irExp);\n                        dimValues.add(saveExpr);\n                        dimTemps.add(tempVal);\n                    }else{\n                        dimTemps.add(null);\n                    }\n                }\n                ArrayList<IRStmt> initSequence = new ArrayList<>();\n                initSequence.addAll(dimValues); // add a[foo(2,b)] add the side effects from the foos\n                initSequence.add(initArrayDecl(0,dimTemps, iden)); // actually allocate\n                return new IRSeq(initSequence); // passed in temp x\n            }\n        }else if (node.type.isBasic()){\n            return new IRMove(new IRTemp(node.identifier.toString()),new IRConst(0));\n        }\n        throw new InternalCompilerError(\"Annotated can only be array or basic\");\n    }\n\n    @Override\n    public IRExpr visit(ArrAccessDecl node) {// no need to visit\n        return null;\n    }\n\n    @Override\n    public IRExpr visit(NoTypeDecl node) {// no need to visit\n        return new IRTemp(node.getIdentifier().toString());\n    }\n\n    @Override\n    public IRExpr visit(UnderScore node) {// no need to visit\n        return new IRTemp(\"_\");\n    }\n\n    @Override\n    public IRStmt visit(Use node) { // no need to visit\n        return null;\n    }\n\n    @Override\n    public IRCompUnit visit(Program node) {\n\n        // Arun TODO\n        // Create  Comp Unit\n        IRCompUnit compUnit = new IRCompUnit(compUnitName);\n        globalIds = node.getGlobalsID();\n        node.getDefinitions().forEach(definition -> {\n            // Add Single Global Decls to the DATA MAP USE FUNC BELOW\n            if (definition instanceof Globdecl) {\n                compUnit.appendData(initSingleGlobal((Globdecl) definition));\n\n            }\n            // Add multi global decls to the DATA map use the Func Below\n            else if (definition instanceof MultiGlobalDecl) {\n                initMultiGlobal((MultiGlobalDecl) definition).forEach(compUnit::appendData);\n            }\n            // Add Function Decls and Name\n            else if (definition instanceof Method) {\n                compUnit.appendFunc(((Method) definition).accept(this));\n            }\n        });\n\n        for (IRData ird: string_consts){\n            compUnit.appendData(ird);\n        }\n\n        // Return Comp Unit\n\n        return compUnit;\n    }\n\n    private IRStmt booleanAsControlFlow(Expr e, String lt, String lf) {\n        if (e instanceof BoolLiteral) { // C[true/false, t, f]  = JUMP(NAME(t/f))\n            boolean val = ((BoolLiteral) e).boolVal;\n            return new IRJump(new IRName(val ? lt : lf));\n        } else if (e instanceof AndBinop){ // C[e1 & e2, t, f]  = SEQ(C[e1,l1,f],l1,C[e2,t,f])\n            Expr e1 = ((AndBinop) e).getLeftExpr();\n            Expr e2 = ((AndBinop) e).getRightExpr();\n            String l1 = nxtLabel();\n            IRStmt first = booleanAsControlFlow(e1,l1,lf);\n            IRStmt second = booleanAsControlFlow(e2,lt,lf);\n            return new IRSeq(first,new IRLabel(l1),second);\n        }else if (e instanceof OrBinop){ // C[e1 | e2, t, f]  = SEQ(C[e1,t,l1],l1,C[e2,t,f])\n            Expr e1 = ((OrBinop) e).getLeftExpr();\n            Expr e2 = ((OrBinop) e).getRightExpr();\n            String l1 = nxtLabel();\n            IRStmt first = booleanAsControlFlow(e1,lt,l1);\n            IRStmt second = booleanAsControlFlow(e2,lt,lf);\n            return new IRSeq(first,new IRLabel(l1),second);\n        }else if (e instanceof NotUnop nt){ // C[!e, t, f]  = C[e, f, t]\n            return booleanAsControlFlow(nt.getE(),lf,lt);\n        }\n        IRExpr cond = e.accept(this);         // C[e, t, f]  = CJUMP(E[e], t, f)\n        return new IRCJump(cond, lt, lf);\n    }\n\n    private String genABIFunc(Type funcType, Id funcName){\n        if (funcType.getType() != Type.TypeCheckingType.FUNC){\n            throw new Error(\"HOW ARE WE HERE\");\n        }\n        String replaceName = funcName.toString().replaceAll(\"_\",\"__\");\n        String inputABIName = genABIArr(funcType.inputTypes,true);\n        String outputABIName = genABIArr(funcType.outputTypes,false);\n        return \"_I\" + replaceName +\"_\"+ outputABIName + inputABIName;\n    }\n    private String genABIArr(ArrayList<Type> arrTypes, boolean isInput){\n        if (arrTypes.size() == 0){\n            return isInput ? \"\": \"p\";\n        }\n        else if (arrTypes.size() == 1){\n            return genABIType(arrTypes.get(0));\n        }else{\n            StringBuilder temp = new StringBuilder(isInput ? \"\" : \"t\" + arrTypes.size());\n            for (Type t: arrTypes){\n                temp.append(genABIType(t));\n            }\n            return temp.toString();\n        }\n    }\n    private String genABIType(Type t){\n        if (t.isBasic()){\n            return (t.getType() == Type.TypeCheckingType.INT) ? \"i\": \"b\";\n        }else if (t.isArray()){\n            StringBuilder build = new StringBuilder();\n            for (int i = 0 ; i< t.dimensions.getDim();i++){\n                build.append(\"a\");\n            }\n            build.append((t.getType() == Type.TypeCheckingType.INTARRAY) ? \"i\":\"b\");\n            return build.toString();\n        }else{\n            throw new Error(\"WE SHOULD NOT BE IN GENTYPE\");\n        }\n    }\n    private IRStmt initArrayDecl(int ind, ArrayList<String> temps, IRExpr curHead){ // this is for a:int[4][3][] etc\n        // a:int[e1][e2][][]\n        if (ind == temps.size() || temps.get(ind) == null){\n//            System.out.println(ind);\n//            System.out.println(d.getDim());\n//            System.out.println(ind == d.getDim());\n//            System.out.println(\"here\");\n            return new IRMove(curHead,new IRConst(0)); // base case x: int[] x <- random val\n        }\n\n//        Expr curExp = d.getIndices().get(ind);\n//        IRExpr irExp = curExp.accept(this);\n\n\n        String tn = nxtTemp();\n        String tm = nxtTemp();\n\n        String noDup = nxtTemp();\n        IRMove tempNoDup = new IRMove(new IRTemp(noDup),new IRTemp(temps.get(ind)));\n        // reg[l] <- length\n        IRMove length_to_l1 = new IRMove(new IRTemp(tn), new IRTemp(noDup));\n\n        // 8*n+8\n        IRBinOp size1 = new IRBinOp(IRBinOp.OpType.ADD,\n                new IRBinOp(IRBinOp.OpType.MUL,\n                        new IRTemp(tn),\n                        new IRConst(WORD_BYTES)),\n                new IRConst(WORD_BYTES));\n\n        // call alloc and move RV1 into val\n        IRCallStmt alloc_call1 = new IRCallStmt(new IRName(\"_eta_alloc\"),1L, size1);\n        IRSeq malloc_move1 = new IRSeq(alloc_call1,new IRMove(new IRTemp(tm), new IRTemp(\"_RV1\")));\n\n        // move len into -1\n        IRMove move_len = new IRMove(new IRMem(new IRTemp(tm)),new IRTemp(tn));\n\n        // increment pointer to head\n        IRBinOp add_8 = new IRBinOp(IRBinOp.OpType.ADD,new IRTemp(tm), new IRConst(WORD_BYTES));\n        IRMove inc_pointer_to_head = new IRMove(curHead,add_8);\n        // do all the top level shit first\n        IRSeq top_level_Order = new IRSeq(tempNoDup,length_to_l1,malloc_move1,move_len,inc_pointer_to_head);\n\n\n        // now time to recrusively alloc\n        String lh = nxtLabel();\n        String l1 = nxtLabel();\n        String le = nxtLabel();\n        String counter = nxtTemp();\n        IRBinOp guard = new IRBinOp(IRBinOp.OpType.LT,new IRTemp(counter), new IRTemp(noDup));\n        // set counter = 0;\n        IRMove set0Coutner = new IRMove(new IRTemp(counter), new IRConst(0));\n        IRLabel whileHead = new IRLabel(lh);\n        // check if counter < irExp\n        IRCJump loopCheck = new IRCJump(guard,l1,le);\n        IRLabel whileBody = new IRLabel(l1);\n        // create memory location for head of new array\n        IRMem memHead = new IRMem(new IRBinOp(IRBinOp.OpType.ADD,\n                curHead,\n                new IRBinOp(IRBinOp.OpType.MUL,\n                    new IRTemp(counter),\n                    new IRConst(WORD_BYTES))));\n        // if we were at int[4][5] we now are in the \"5\" after recur executes after 5 it will be in \"nothing\" which means base case\n        IRStmt recur = initArrayDecl(ind+1, temps, memHead);\n        // increment counter\n        IRMove inc = new IRMove(new IRTemp(counter),new IRBinOp(IRBinOp.OpType.ADD,new IRTemp(counter), new IRConst(1)));\n        // jump back to loop head\n        IRJump go_back_to_head = new IRJump(new IRName(lh));\n        IRLabel afterLoop = new IRLabel(le);\n\n        IRSeq loopComponent = new IRSeq(set0Coutner,whileHead,loopCheck,whileBody,recur,inc,go_back_to_head,afterLoop);\n\n        return new IRSeq(top_level_Order,loopComponent);\n    }\n\n    private IRData initSingleGlobal(Globdecl node){\n        Expr e = node.getValue();\n        AnnotatedTypeDecl d = node.getDecl();\n        IRData irdata;\n        long[] data;\n        String name = \"_\" + d.getIdentifier();\n\n        if (e == null) {\n            irdata = new IRData(name,  new long[]{0});\n            return irdata;\n        }\n\n        if (e.getNodeType().getType() == Type.TypeCheckingType.INT) {\n            data = new long[]{((IntLiteral) e).getLong()};\n            irdata = new IRData(name, data);\n        } else if (e.getNodeType().getType() == Type.TypeCheckingType.BOOL) {\n            boolean b = ((BoolLiteral) e).getBoolVal();\n            if (b) {\n                data = new long[]{1};\n            } else {\n                data = new long[]{0};\n            }\n            irdata = new IRData(name, data);\n        } else {\n            throw new InternalCompilerError(\"Unable to global assign this type.\");\n        }\n        return irdata;\n    }\n\n    private ArrayList<IRData> initMultiGlobal(MultiGlobalDecl node){\n\n        ArrayList<AnnotatedTypeDecl> decls = node.getDecls();\n        ArrayList<Expr> exprs = node.getExpressions();\n\n        ArrayList<IRData> irDataList = new ArrayList<>(decls.size());\n        for (int i = 0; i < decls.size(); i++) {\n            Globdecl glob = new Globdecl(decls.get(i), exprs.get(i), -1 ,-1);\n            irDataList.set(i, initSingleGlobal(glob));\n        }\n\n        return irDataList;\n    }\n    private IRExpr accessRecur(int ind, ArrayList<Expr> indexes, IRExpr expr) {\n        if (ind == indexes.size()) {\n            return expr;\n        }\n        IRExpr curInd = indexes.get(ind).accept(this);\n        String ta = nxtTemp();\n        String ti = nxtTemp();\n        String lok = nxtLabel();\n        String ler = nxtLabel();\n        IRESeq sol = new IRESeq( // 1d array need loop for further\n                new IRSeq(\n                        new IRMove(new IRTemp(ta), expr),\n                        new IRMove(new IRTemp(ti), curInd),\n                        new IRCJump(\n                                new IRBinOp(IRBinOp.OpType.ULT,\n                                        new IRTemp(ti),\n                                        new IRMem(\n                                                new IRBinOp(IRBinOp.OpType.SUB,\n                                                        new IRTemp(ta),\n                                                        new IRConst(8)))),\n                                lok,ler),\n                        new IRLabel(ler),\n                        new IRCallStmt(new IRName(OUT_OF_BOUNDS), 0L,new ArrayList<>()),\n                        new IRLabel(lok)\n                ),\n                new IRMem(\n                        new IRBinOp(IRBinOp.OpType.ADD,\n                                new IRTemp(ta),\n                                new IRBinOp(IRBinOp.OpType.MUL,new IRTemp(ti),new IRConst(8))\n                        )));\n        return accessRecur(ind + 1, indexes, sol);\n    }\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/aar226_akc55_ayc62_ahl88/visitors/IRVisitor.java b/src/main/java/aar226_akc55_ayc62_ahl88/visitors/IRVisitor.java
--- a/src/main/java/aar226_akc55_ayc62_ahl88/visitors/IRVisitor.java	(revision ec07600bf2d84dd9fa3d423ad0e7c551ac9bfa1a)
+++ b/src/main/java/aar226_akc55_ayc62_ahl88/visitors/IRVisitor.java	(date 1681077073872)
@@ -2,11 +2,6 @@
 
 import aar226_akc55_ayc62_ahl88.Main;
 import aar226_akc55_ayc62_ahl88.OptimizationTypes;
-import aar226_akc55_ayc62_ahl88.asm.Expressions.ASMConstExpr;
-import aar226_akc55_ayc62_ahl88.asm.Expressions.ASMTempExpr;
-import aar226_akc55_ayc62_ahl88.asm.Instructions.ASMInstruction;
-import aar226_akc55_ayc62_ahl88.asm.Instructions.mov.ASMMov;
-import aar226_akc55_ayc62_ahl88.newast.Dimension;
 import aar226_akc55_ayc62_ahl88.newast.Program;
 import aar226_akc55_ayc62_ahl88.newast.Type;
 import aar226_akc55_ayc62_ahl88.newast.Use;
@@ -34,7 +29,6 @@
 import aar226_akc55_ayc62_ahl88.src.polyglot.util.InternalCompilerError;
 import org.apache.commons.text.StringEscapeUtils;
 
-import javax.naming.Name;
 import java.math.BigInteger;
 import java.util.ArrayList;
 import java.util.List;
@@ -784,7 +778,6 @@
             // Add Single Global Decls to the DATA MAP USE FUNC BELOW
             if (definition instanceof Globdecl) {
                 compUnit.appendData(initSingleGlobal((Globdecl) definition));
-
             }
             // Add multi global decls to the DATA map use the Func Below
             else if (definition instanceof MultiGlobalDecl) {
