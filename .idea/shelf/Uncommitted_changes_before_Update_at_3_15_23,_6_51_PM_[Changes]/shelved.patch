Index: tests/pa4Tests/validpalindrome.eta
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>isPalindrome(s: int[]): bool {\n    l : int =  0\n    r : int = length(s) - 1\n\n    while (l < r) {\n        if (s[l] != s[r]) {\n            return false;\n        }\n\n        l = l + 1\n        r = r - 1;\n    }\n    return true\n}\n\nmain(args: int[][]){\n    a : int[] = \"abababababababa\"; // true\n    b: int[]= \"amanaplanacanalpanama\"; // true\n    c : int[] = \" \" //true\n    d : int[] = \"raceacar\" // false\n\n    e : bool = isPalindrome(a);\n    f : bool = isPalindrome(b);\n    g : bool = isPalindrome(c);\n    h : bool = isPalindrome(d);\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/tests/pa4Tests/validpalindrome.eta b/tests/pa4Tests/validpalindrome.eta
--- a/tests/pa4Tests/validpalindrome.eta	(revision 6354dbb1be98946385980e251280eddbfebeeadd)
+++ b/tests/pa4Tests/validpalindrome.eta	(date 1678917324102)
@@ -1,3 +1,5 @@
+use io
+use conv
 isPalindrome(s: int[]): bool {
     l : int =  0
     r : int = length(s) - 1
@@ -14,13 +16,13 @@
 }
 
 main(args: int[][]){
-    a : int[] = "abababababababa"; // true
-    b: int[]= "amanaplanacanalpanama"; // true
-    c : int[] = " " //true
     d : int[] = "raceacar" // false
-
-    e : bool = isPalindrome(a);
-    f : bool = isPalindrome(b);
-    g : bool = isPalindrome(c);
     h : bool = isPalindrome(d);
+    if (h){
+        println("YES")
+        println(d)
+    }else{
+        println("NO")
+        println(d)
+    }
 }
\ No newline at end of file
Index: src/main/java/aar226_akc55_ayc62_ahl88/src/edu/cornell/cs/cs4120/xic/ir/visit/IRLoweringVisitor.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package aar226_akc55_ayc62_ahl88.src.edu.cornell.cs.cs4120.xic.ir.visit;\n\n\nimport aar226_akc55_ayc62_ahl88.src.edu.cornell.cs.cs4120.xic.ir.*;\nimport aar226_akc55_ayc62_ahl88.src.polyglot.util.InternalCompilerError;\n\nimport java.util.*;\n\n// Need to think about what to add\nclass BasicBlock {\n    public boolean marked;\n    public int ind;\n    public ArrayList<Integer> predecessors;\n    public ArrayList<Integer> successors;\n    public ArrayList<IRStmt> statements;\n    public ArrayList<String> destLabels;\n\n    public ArrayList<String> originLabels;\n\n\n    public BasicBlock(int i) {\n        ind = i;\n        marked = false;\n        predecessors = new ArrayList<>();\n        successors = new ArrayList<>();\n        statements = new ArrayList<>();\n        destLabels = new ArrayList<>();\n        originLabels = new ArrayList<>();\n    }\n}\n\npublic class IRLoweringVisitor extends IRVisitor {\n    private int labelCnt;\n    private int tempCnt;\n\n\n    private String nxtLabel() {\n        return String.format(\"lb%d\", (labelCnt++));\n    }\n\n    private String nxtTemp() {\n        return String.format(\"tl%d\", (tempCnt++));\n    }\n    public IRLoweringVisitor (IRNodeFactory inf) {\n        super(inf);\n        labelCnt = 0;\n        tempCnt = 0;\n    }\n\n    @Override\n    protected IRNode leave(IRNode parent, IRNode n, IRNode n_, IRVisitor v_) {\n        if (n_ instanceof IRBinOp irbin) return canon(irbin);\n        if (n_ instanceof IRCall irc) return canon(irc);\n        if (n_ instanceof IRCallStmt ircstmt) return canon(ircstmt);\n        if (n_ instanceof IRCJump ircj) return canon(ircj);\n        if (n_ instanceof IRCompUnit icu) return canon(icu);\n        if (n_ instanceof IRConst ic) return canon(ic);\n        if (n_ instanceof IRESeq ireseq) return canon(ireseq);\n        if (n_ instanceof IRExp irexp) return  canon(irexp);\n        if (n_ instanceof IRFuncDecl irfunc) return canon(irfunc);\n        if (n_ instanceof IRJump irj) return canon(irj);\n        if (n_ instanceof IRLabel irl) return canon(irl);\n        if (n_ instanceof IRMem irmem) return canon(irmem);\n        if (n_ instanceof IRMove irmove) return canon(irmove);\n        if (n_ instanceof IRName irname) return canon(irname);\n        if (n_ instanceof IRReturn irret) return canon(irret);\n        if (n_ instanceof IRSeq irseq) return canon(irseq);\n        if (n_ instanceof IRTemp irtem) return canon(irtem);\n\n        throw new Error(\"Why is node not found\");\n    }\n\n    private boolean hasNoUnmarkedPredecessors(BasicBlock block,ArrayList<BasicBlock> blocks) {\n\n        boolean noUnmarkedPredecessor = true;\n        for (int i : block.predecessors) {\n            if (!blocks.get(i).marked){\n                noUnmarkedPredecessor = false;\n            }\n        }\n\n\n        return noUnmarkedPredecessor;\n    }\n    private void dfs(BasicBlock b, ArrayList<BasicBlock> res, ArrayList<BasicBlock> unorderedBlocks){\n        b.marked = true;\n//        System.out.println(\"START\");\n        boolean[] visit = new boolean[unorderedBlocks.size()];\n        Stack<Integer> stack = new Stack<>();\n        stack.add(b.ind);\n        while (!stack.isEmpty()){\n            int curNode = stack.pop();\n            BasicBlock curBlock = unorderedBlocks.get(curNode);\n            curBlock.marked = true;\n            res.add(curBlock);\n            boolean foundAnother = false;\n            for (int succ : curBlock.successors){\n                if (!visit[succ] && !unorderedBlocks.get(succ).marked){\n                    visit[succ] = true;\n                    stack.add(succ);\n                    foundAnother = true;\n                    break;\n                }\n            }\n            if (!foundAnother){\n                break;\n            }\n        }\n    }\n    private boolean allMarked(ArrayList<BasicBlock> blocks){\n        for (BasicBlock b: blocks){\n            if (!b.marked){\n                return false;\n            }\n        }\n        return true;\n    }\n    private BasicBlock chooseBlock(ArrayList<BasicBlock> blocks){\n        boolean allMarked = true;\n        BasicBlock curBlock = null;\n        for (BasicBlock b: blocks){\n            if (!b.marked && hasNoUnmarkedPredecessors(b,blocks)){\n                return b;\n            }\n            if (!b.marked){\n                allMarked = false;\n                if (curBlock == null){\n                    curBlock = b;\n                }\n            }\n        }\n        if (!allMarked){\n            return curBlock;\n        }\n        throw new InternalCompilerError(\"Should only choose block when not all marked\");\n    }\n    private ArrayList<BasicBlock> goodReordering(ArrayList<BasicBlock> unorderedBlocks){\n        ArrayList<BasicBlock> result = new ArrayList<>();\n        while (!allMarked(unorderedBlocks)) {\n            BasicBlock block = chooseBlock(unorderedBlocks);\n            dfs(block,result,unorderedBlocks);\n        }\n        return result;\n    }\n\n    private boolean stop(IRStmt stmt){\n        return (stmt instanceof IRJump || stmt instanceof IRCJump || stmt instanceof IRReturn);\n    }\n\n    private void compareBlocks(BasicBlock block1, BasicBlock block2){\n        for (String originLabel : block1.originLabels) {\n            for (String destLabel : block2.destLabels) {\n                if (originLabel.equals(destLabel)) {\n                    block1.successors.add(block2.ind);\n                    block2.predecessors.add(block1.ind);\n                }\n            }\n        }\n    }\n\n    private ArrayList<BasicBlock> createBasicBlocksAndGraph(IRSeq body){\n        int ind = 0;\n        ArrayList<BasicBlock> blocks = new ArrayList<>();\n        BasicBlock dummy = new BasicBlock(ind);\n        ind++;\n        String lb = nxtLabel();\n        dummy.statements.add(new IRJump(new IRName(\"dummy_head\" + lb)));\n        dummy.successors.add(1);\n        blocks.add(dummy);\n        BasicBlock curBlock = new BasicBlock(ind);\n        curBlock.predecessors.add(0);\n        curBlock.statements.add(new IRLabel(\"dummy_head\" + lb));\n        for (IRStmt stmt: body.stmts()){\n            curBlock.statements.add(stmt);\n            if (stop(stmt)) {\n                if (stmt instanceof IRJump jmp) {\n                    String destName = ((IRName) jmp.target()).name();\n                    curBlock.originLabels.add(destName);\n                }\n                else if (stmt instanceof IRCJump cjmp) {\n                    curBlock.originLabels.add(cjmp.trueLabel());\n                    curBlock.originLabels.add(cjmp.falseLabel());\n                }\n                blocks.add(curBlock);\n                ind++;\n                curBlock = new BasicBlock(ind);\n            }\n            if (stmt instanceof IRLabel label) {\n                curBlock.destLabels.add(label.name());\n            }\n        }\n        if (curBlock.statements.size() != 0) {\n            blocks.add(curBlock);\n        }\n\n        for (int i = 0; i < blocks.size(); i++) {\n            for (int j = i; j < blocks.size(); j++) {\n                BasicBlock bi = blocks.get(i), bj = blocks.get(j);\n                compareBlocks(bi, bj);\n                compareBlocks(bj, bi);\n            }\n        }\n        return blocks;\n    }\n    // Lower each statment then flatten all sequences\n    private IRNode canon(IRSeq node) {\n//        System.out.println(node);\n        ArrayList<IRStmt> flatten = new ArrayList<>();\n        for (IRStmt stmt: node.stmts()){\n            if (stmt instanceof IRSeq seq){\n                flatten.addAll(seq.stmts());\n            }else{\n                flatten.add(stmt);\n            }\n        }\n        return new IRSeq(flatten);\n    }\n\n    // Lower each return expressions then add Return\n    private IRNode canon(IRReturn node) {\n        ArrayList<IRStmt> stmts = new ArrayList<>();\n        ArrayList<String> temps_strs = new ArrayList<>();\n\n        for (IRExpr expr : node.rets()) {\n            String ti = nxtTemp();\n            temps_strs.add(ti);\n            if (expr instanceof IRESeq eseq) {\n                if (eseq.stmt() instanceof IRSeq seq){\n                    stmts.addAll(seq.stmts());\n                }else{\n                    stmts.add(eseq.stmt());\n                }\n                stmts.add(new IRMove(new IRTemp(ti),eseq.expr()));\n            }else{\n                stmts.add(new IRMove(new IRTemp(ti),expr));\n            }\n        }\n        List<IRExpr> temps = new ArrayList<>();\n        for (String tmp : temps_strs) {\n            temps.add(new IRTemp(tmp));\n        }\n\n        stmts.add(new IRReturn(temps));\n        return new IRSeq(stmts);\n    }\n\n    // Lower Move be very careful look at slides\n    private IRNode canon(IRMove node) {\n        IRExpr target = node.target();\n        IRExpr source = node.source();\n//\n        if (target instanceof IRMem mem){\n            return moveCommute(node) ? moveNaive(mem,source) : moveGeneral(mem,source);\n        }\n        return easyMove(node);\n    }\n\n    private IRNode easyMove(IRMove node){\n        ArrayList<IRStmt> stmts = new ArrayList<>();\n        IRExpr targ = node.target();\n        IRExpr source = node.source();\n        if (node.target() instanceof IRESeq ires1){\n            if (ires1.stmt() instanceof IRSeq seq){\n                stmts.addAll(seq.stmts());\n            }else{\n                stmts.add(ires1.stmt());\n            }\n            targ = ires1.expr();\n        }\n        if (node.source() instanceof IRESeq ires){\n            if (ires.stmt() instanceof IRSeq seq2){\n                stmts.addAll(seq2.stmts());\n            }else{\n                stmts.add(ires.stmt());\n            }\n            source = ires.expr();\n        }\n        if (stmts.size() != 0){\n            stmts.add(new IRMove(targ,source));\n            return new IRSeq(stmts);\n        }\n        return node;\n    }\n    // to do\n    private boolean moveCommute(IRMove node){\n        return false;\n    }\n    private IRStmt moveNaive(IRMem targ, IRExpr src){\n        ArrayList<IRStmt> stmts = new ArrayList<>();\n        IRExpr e1 = targ.expr();\n        IRExpr e2 = src;\n        if (targ.expr() instanceof IRESeq ires){\n            if (ires.stmt() instanceof IRSeq seq){\n                stmts.addAll(seq.stmts());\n            }else{\n                stmts.add(ires.stmt());\n            }\n            e1 = ires.expr();\n        }\n        if (src instanceof  IRESeq ires2){\n            if (ires2.stmt() instanceof IRSeq seq1){\n                stmts.addAll(seq1.stmts());\n            }else{\n                stmts.add(ires2.stmt());\n            }\n            e2 = ires2.expr();\n        }\n        if (stmts.size() != 0){\n            stmts.add(new IRMove(new IRMem(e1),e2));\n            return new IRSeq(stmts);\n        }\n        return new IRMove(targ,src);\n    }\n\n    private IRStmt moveGeneral(IRMem targ, IRExpr src){\n        ArrayList<IRStmt> stmts = new ArrayList<>();\n        IRExpr e1 = targ.expr();\n        IRExpr e2 = src;\n        if (targ.expr() instanceof IRESeq ires){\n            if (ires.stmt() instanceof IRSeq seq){\n                stmts.addAll(seq.stmts());\n            }else{\n                stmts.add(ires.stmt());\n            }\n            e1 = ires.expr();\n        }\n        String t = nxtTemp();\n        stmts.add(new IRMove(new IRTemp(t),e1));\n        if (src instanceof  IRESeq ires2){\n            if (ires2.stmt() instanceof IRSeq seq1){\n                stmts.addAll(seq1.stmts());\n            }else{\n                stmts.add(ires2.stmt());\n            }\n            e2 = ires2.expr();\n        }\n        stmts.add(new IRMove(new IRMem(new IRTemp(t)),e2));\n        return new IRSeq(stmts);\n    }\n\n    // Create Basic Blocks And reorder all the body\n    private IRNode canon(IRFuncDecl node) {\n        if (node.body() instanceof IRSeq irs){\n            ArrayList<IRStmt> orderedStatements = new ArrayList<>();\n            ArrayList<BasicBlock> unorderedBlocks = createBasicBlocksAndGraph(irs);\n            ArrayList<BasicBlock> orderedBlocks = goodReordering(unorderedBlocks);\n            assert unorderedBlocks.size() == orderedBlocks.size() : \"after ordering is different size tf\";\n            for (int i = 0; i< orderedBlocks.size()-1;i++){\n                BasicBlock curblk = orderedBlocks.get(i);\n                BasicBlock nxtblk = orderedBlocks.get(i+1);\n                assert curblk.statements.size() >= 1: \"block is empty\";\n                assert nxtblk.statements.size() >= 1: \"dest block is empty\";\n                IRStmt lastStmt = curblk.statements.get(curblk.statements.size()-1);\n                IRStmt firstStmtInNext = nxtblk.statements.get(0);\n                if (lastStmt instanceof IRJump jmp && firstStmtInNext instanceof IRLabel il){\n                    String name = ((IRName) jmp.target()).name();\n                    if (name.equals(il.name())){ // remove jump\n                        curblk.statements.remove(curblk.statements.size()-1);\n                    }\n                }else if (lastStmt instanceof IRCJump cjmp && firstStmtInNext instanceof IRLabel il){\n                    String tlabel = cjmp.trueLabel();\n                    String flabel = cjmp.falseLabel();\n                    if (tlabel.equals(il.name())){\n                        IRBinOp newCond = new IRBinOp(IRBinOp.OpType.XOR,new IRConst(1),cjmp.cond());\n                        IRCJump newCJump = new IRCJump(newCond, flabel,null);\n                        curblk.statements.set(curblk.statements.size()-1,newCJump);\n                    }else if (flabel.equals(il.name())){\n                        IRCJump newCJump = new IRCJump(cjmp.cond(), tlabel,null);\n                        curblk.statements.set(curblk.statements.size()-1,newCJump);\n                    }else{\n                        System.out.println(\"yikes somehow need double jump again idk?\");\n                        IRCJump newCJump = new IRCJump(cjmp.cond(), tlabel,null);\n                        curblk.statements.set(curblk.statements.size()-1,newCJump);\n                        curblk.statements.add(new IRJump(new IRName(flabel)));\n                    }\n                }\n            }\n            BasicBlock lastBlock = orderedBlocks.get(orderedBlocks.size()-1);\n            IRStmt lastStmt = lastBlock.statements.get(lastBlock.statements.size()-1);\n            if (lastStmt instanceof IRCJump cjmp){\n                IRCJump newCJump = new IRCJump(cjmp.cond(), cjmp.trueLabel(),null);\n                lastBlock.statements.set(lastBlock.statements.size()-1,newCJump);\n                lastBlock.statements.add(new IRJump(new IRName(cjmp.falseLabel())));\n            }\n            for (BasicBlock b: orderedBlocks){\n                for (IRStmt s: b.statements){\n                    orderedStatements.add(s);\n                }\n            }\n            IRFuncDecl func = new IRFuncDecl(node.name(),new IRSeq(orderedStatements));\n            func.functionSig = node.functionSig;\n            return func;\n        }else{\n            throw new InternalCompilerError(\"METHOD BODY NOT SEQ\");\n        }\n    }\n\n\n    // Lift Statement that is it\n    private IRNode canon(IRExp node) {\n        if (node.expr() instanceof IRESeq ire) {\n            if (ire.stmt() instanceof IRSeq seq){\n                return new IRSeq(seq.stmts());\n            }else{\n                return ire.stmt();\n            }\n        }\n        return new IRSeq();\n    }\n\n    // do nothing\n    private IRNode canon(IRCompUnit node) {\n        return node;\n    }\n\n    // Lower each Expr\n    private IRNode canon(IRCallStmt node) {\n        ArrayList<IRStmt> stmts = new ArrayList<>();\n        ArrayList<String> temps_strs = new ArrayList<>();\n\n        for (IRExpr expr : node.args()) {\n            String ti = nxtTemp();\n            temps_strs.add(ti);\n            if (expr instanceof IRESeq eseq) {\n                if (eseq.stmt() instanceof IRSeq seq){\n                    stmts.addAll(seq.stmts());\n                }else{\n                    stmts.add(eseq.stmt());\n                }\n                stmts.add(new IRMove(new IRTemp(ti),eseq.expr()));\n            }else{\n                stmts.add(new IRMove(new IRTemp(ti),expr));\n            }\n        }\n\n        List<IRExpr> temps = new ArrayList<>();\n        for (String tmp : temps_strs) {\n            temps.add(new IRTemp(tmp));\n        }\n\n        stmts.add(new IRCallStmt(node.target(), node.n_returns(), temps));\n\n        return new IRSeq(stmts);\n    }\n    // Lower each Expr we never call this lol?\n    private IRNode canon(IRCall node) {\n        return node;\n    }\n\n    // if commute do that otherwise do normal\n    private IRNode canon(IRBinOp node) {\n        return doesBinopCommunte(node) ? commuteBinop(node) : defaultBinop(node);\n    }\n\n    // to do\n    private boolean doesBinopCommunte(IRBinOp node){\n        return false;\n    }\n\n    private IRNode commuteBinop(IRBinOp node){\n        ArrayList<IRStmt> hoisted = new ArrayList<>();\n        IRExpr e1 = node.left();\n        IRExpr e2 = node.right();\n        if (node.left() instanceof IRESeq ires1){\n            if (ires1.stmt() instanceof IRSeq seq){\n                hoisted.addAll(seq.stmts());\n            }else{\n                hoisted.add(ires1.stmt());\n            }\n            e1 = ires1.expr();\n        }\n        if (node.right() instanceof  IRESeq ires2){\n            if (ires2.stmt() instanceof IRSeq seq2){\n                hoisted.addAll(seq2.stmts());\n            }else{\n                hoisted.add(ires2.stmt());\n            }\n            e2 = ires2.expr();\n        }\n        if (hoisted.size() != 0){\n            return new IRESeq(new IRSeq(hoisted),new IRBinOp(node.opType(),e1,e2));\n        }\n        return node;\n    }\n    private IRNode defaultBinop(IRBinOp node){\n        ArrayList<IRStmt> stmts = new ArrayList<>();\n        String t1 = nxtTemp();\n        IRExpr e2 = node.right();\n        if (node.left() instanceof IRESeq ires1){\n            if (ires1.stmt() instanceof IRSeq seq){\n                stmts.addAll(seq.stmts());\n            }else{\n                stmts.add(ires1.stmt());\n            }\n            stmts.add(new IRMove(new IRTemp(t1), ires1.expr()));\n        }else{\n            stmts.add(new IRMove(new IRTemp(t1), node.left()));\n        }\n\n        if (node.right() instanceof IRESeq ires2){\n            if (ires2.stmt() instanceof IRSeq seq2){\n                stmts.addAll(seq2.stmts());\n            }else{\n                stmts.add(ires2.stmt());\n            }\n            e2 = ires2.expr();\n        }\n//        System.out.println(new IRSeq(stmts));\n        return new IRESeq(new IRSeq(stmts),\n                new IRBinOp(node.opType(),new IRTemp(t1),e2));\n    }\n\n    // canonical\n    private IRNode canon(IRConst node){\n        return node;\n    }\n    // canonical\n    private IRNode canon(IRLabel node){\n        return node;\n    }\n    // canonical\n    private IRNode canon(IRName node){\n        return node;\n    }\n    // canonical\n    private IRNode canon(IRTemp node) {\n        return node;\n    }\n    // MEM\n    private IRNode canon(IRMem node){\n        if (node.expr() instanceof IRESeq ireseq) { // lift expression\n            IRStmt svec = ireseq.stmt();\n            IRExpr ire = ireseq.expr();\n            return new IRESeq(svec, new IRMem(ire));\n        }\n        return node;\n    }\n    // Conditional Jump\n    private IRNode canon(IRCJump node){\n        if (node.cond() instanceof IRESeq ireseq) {\n            ArrayList<IRStmt> stmts = new ArrayList<>();\n            if (ireseq.stmt() instanceof IRSeq seq){\n                stmts.addAll(seq.stmts());\n            }else{\n                stmts.add(ireseq.stmt());\n            }\n            IRExpr ire = ireseq.expr();\n            stmts.add(new IRCJump(ire, node.trueLabel(), node.falseLabel()));\n            return new IRSeq(stmts);\n        }\n        return node;\n    }\n    // Jump\n    private IRNode canon(IRJump node){\n        if (node.target() instanceof IRESeq ireseq) {\n            ArrayList<IRStmt> stmts = new ArrayList<>();\n            if (ireseq.stmt() instanceof IRSeq seq){\n                stmts.addAll(seq.stmts());\n            }else{\n                stmts.add(ireseq.stmt());\n            }\n            IRExpr ire = ireseq.expr();\n            stmts.add(new IRJump(ire));\n            return new IRSeq(stmts);\n        }\n        return node;\n    }\n    // ESEQ\n    private IRNode canon(IRESeq node){\n        if (node.expr() instanceof IRESeq ireseq) {\n            IRExpr ire = ireseq.expr();\n            ArrayList<IRStmt> stmts = new ArrayList<>();\n            if (node.stmt() instanceof  IRSeq seqNode){\n                stmts.addAll(seqNode.stmts());\n            }else{\n                stmts.add(node.stmt());\n            }\n            if (ireseq.stmt() instanceof IRSeq seq){\n                stmts.addAll(seq.stmts());\n            }else{\n                stmts.add(ireseq.stmt());\n            }\n            return new IRESeq(new IRSeq(stmts), ire);\n        }\n        return node;\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/aar226_akc55_ayc62_ahl88/src/edu/cornell/cs/cs4120/xic/ir/visit/IRLoweringVisitor.java b/src/main/java/aar226_akc55_ayc62_ahl88/src/edu/cornell/cs/cs4120/xic/ir/visit/IRLoweringVisitor.java
--- a/src/main/java/aar226_akc55_ayc62_ahl88/src/edu/cornell/cs/cs4120/xic/ir/visit/IRLoweringVisitor.java	(revision 6354dbb1be98946385980e251280eddbfebeeadd)
+++ b/src/main/java/aar226_akc55_ayc62_ahl88/src/edu/cornell/cs/cs4120/xic/ir/visit/IRLoweringVisitor.java	(date 1678917935979)
@@ -10,6 +10,7 @@
 class BasicBlock {
     public boolean marked;
     public int ind;
+    public int indegree;
     public ArrayList<Integer> predecessors;
     public ArrayList<Integer> successors;
     public ArrayList<IRStmt> statements;
@@ -20,6 +21,7 @@
 
     public BasicBlock(int i) {
         ind = i;
+        indegree = 0;
         marked = false;
         predecessors = new ArrayList<>();
         successors = new ArrayList<>();
@@ -45,7 +47,9 @@
         super(inf);
         labelCnt = 0;
         tempCnt = 0;
+        labelToBlock = new HashMap<>();
     }
+    private HashMap<String,BasicBlock> labelToBlock;
 
     @Override
     protected IRNode leave(IRNode parent, IRNode n, IRNode n_, IRVisitor v_) {
@@ -144,7 +148,7 @@
     }
 
     private boolean stop(IRStmt stmt){
-        return (stmt instanceof IRJump || stmt instanceof IRCJump || stmt instanceof IRReturn);
+        return (stmt instanceof IRJump || stmt instanceof IRCJump || stmt instanceof IRReturn || stmt instanceof IRLabel);
     }
 
     private void compareBlocks(BasicBlock block1, BasicBlock block2){
@@ -171,22 +175,39 @@
         curBlock.predecessors.add(0);
         curBlock.statements.add(new IRLabel("dummy_head" + lb));
         for (IRStmt stmt: body.stmts()){
-            curBlock.statements.add(stmt);
             if (stop(stmt)) {
                 if (stmt instanceof IRJump jmp) {
                     String destName = ((IRName) jmp.target()).name();
                     curBlock.originLabels.add(destName);
+                    curBlock.statements.add(stmt);
                 }
                 else if (stmt instanceof IRCJump cjmp) {
                     curBlock.originLabels.add(cjmp.trueLabel());
                     curBlock.originLabels.add(cjmp.falseLabel());
+                    curBlock.statements.add(stmt);
+                }else if (stmt instanceof IRReturn irr){
+                    curBlock.statements.add(irr);
                 }
-                blocks.add(curBlock);
-                ind++;
-                curBlock = new BasicBlock(ind);
-            }
-            if (stmt instanceof IRLabel label) {
-                curBlock.destLabels.add(label.name());
+                if (curBlock.statements.size() != 0) {
+                    BasicBlock preBlock = curBlock;
+                    blocks.add(curBlock);
+                    ind++;
+                    curBlock = new BasicBlock(ind);
+                    if (stmt instanceof IRLabel il){
+                        preBlock.successors.add(ind);
+                        curBlock.predecessors.add(preBlock.ind);
+                        curBlock.destLabels.add(il.name());
+                        curBlock.statements.add(il);
+                        preBlock.statements.add(new IRJump(new IRName(il.name())));
+                    }
+                }else if (stmt instanceof IRLabel il){
+                    curBlock.statements.add(il);
+                    curBlock.destLabels.add(il.name());
+                }else{
+                    throw new InternalCompilerError("BRUH");
+                }
+            }else{
+                curBlock.statements.add(stmt);
             }
         }
         if (curBlock.statements.size() != 0) {
@@ -201,7 +222,52 @@
             }
         }
         return blocks;
+
     }
+//    private ArrayList<BasicBlock> createBasicBlocksAndGraph(IRSeq body){
+//        int ind = 0;
+//        ArrayList<BasicBlock> blocks = new ArrayList<>();
+//        BasicBlock dummy = new BasicBlock(ind);
+//        ind++;
+//        String lb = nxtLabel();
+//        dummy.statements.add(new IRJump(new IRName("dummy_head" + lb)));
+//        dummy.successors.add(1);
+//        blocks.add(dummy);
+//        BasicBlock curBlock = new BasicBlock(ind);
+//        curBlock.predecessors.add(0);
+//        curBlock.statements.add(new IRLabel("dummy_head" + lb));
+//        for (IRStmt stmt: body.stmts()){
+//            curBlock.statements.add(stmt);
+//            if (stop(stmt)) {
+//                if (stmt instanceof IRJump jmp) {
+//                    String destName = ((IRName) jmp.target()).name();
+//                    curBlock.originLabels.add(destName);
+//                }
+//                else if (stmt instanceof IRCJump cjmp) {
+//                    curBlock.originLabels.add(cjmp.trueLabel());
+//                    curBlock.originLabels.add(cjmp.falseLabel());
+//                }
+//                blocks.add(curBlock);
+//                ind++;
+//                curBlock = new BasicBlock(ind);
+//            }
+//            if (stmt instanceof IRLabel label) {
+//                curBlock.destLabels.add(label.name());
+//            }
+//        }
+//        if (curBlock.statements.size() != 0) {
+//            blocks.add(curBlock);
+//        }
+//
+//        for (int i = 0; i < blocks.size(); i++) {
+//            for (int j = i; j < blocks.size(); j++) {
+//                BasicBlock bi = blocks.get(i), bj = blocks.get(j);
+//                compareBlocks(bi, bj);
+//                compareBlocks(bj, bi);
+//            }
+//        }
+//        return blocks;
+//    }
     // Lower each statment then flatten all sequences
     private IRNode canon(IRSeq node) {
 //        System.out.println(node);
@@ -350,6 +416,10 @@
                 BasicBlock nxtblk = orderedBlocks.get(i+1);
                 assert curblk.statements.size() >= 1: "block is empty";
                 assert nxtblk.statements.size() >= 1: "dest block is empty";
+//                System.out.println(i);
+//                System.out.println(i+1);
+//                System.out.println(curblk.statements);
+//                System.out.println(nxtblk.statements);
                 IRStmt lastStmt = curblk.statements.get(curblk.statements.size()-1);
                 IRStmt firstStmtInNext = nxtblk.statements.get(0);
                 if (lastStmt instanceof IRJump jmp && firstStmtInNext instanceof IRLabel il){
@@ -368,7 +438,7 @@
                         IRCJump newCJump = new IRCJump(cjmp.cond(), tlabel,null);
                         curblk.statements.set(curblk.statements.size()-1,newCJump);
                     }else{
-                        System.out.println("yikes somehow need double jump again idk?");
+//                        System.out.println("yikes somehow need double jump again idk?");
                         IRCJump newCJump = new IRCJump(cjmp.cond(), tlabel,null);
                         curblk.statements.set(curblk.statements.size()-1,newCJump);
                         curblk.statements.add(new IRJump(new IRName(flabel)));
Index: tests/pa4Tests/recursion1.eta
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>deleteFirst(list : int[]) : int[] {\n    counter : int = 1\n    temp : int[] = {};\n    while (counter < length(list)) {\n        temp = temp + {list[counter]};\n    }\n    return temp\n}\n\nmergeTwoLists(list1 : int[], list2 : int[]) : int[] {\n    if(length(list1) == 0){\n        return list2;\n    }\n\n    if(length(list2) == 0) {\n        return list1;\n    }\n\n    if (list1[0] < list2[0]) {\n        return {list1[0]} + mergeTwoLists(deleteFirst(list1),list2);\n    }\n    else{\n        return {list2[0]} + mergeTwoLists(deleteFirst(list2),list1);\n    }\n}\n\nmain(args : int[][]) {\n    //merges two sorted lists\n    a : int[] = {1,2,4}\n    b : int[] = {1,2,3}\n\n    c : int[] = {2,3,8}\n    d : int[] = {4,6,9}\n\n    c : int[] = {1,3,5,7,9,11}\n    d : int[] = {2,4,6,8,10}\n\n    x : int[] = mergeTwoLists(a,b); //1,1,2,2,3,4\n    y : int[] = mergeTwoLists(c,d); //2,3,4,6,8,9\n    z : int[] = mergeTwoLists(e,f); //1,2,3,4,5,6,7,8,9,10,11\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/tests/pa4Tests/recursion1.eta b/tests/pa4Tests/recursion1.eta
--- a/tests/pa4Tests/recursion1.eta	(revision 6354dbb1be98946385980e251280eddbfebeeadd)
+++ b/tests/pa4Tests/recursion1.eta	(date 1678918089710)
@@ -32,8 +32,8 @@
     c : int[] = {2,3,8}
     d : int[] = {4,6,9}
 
-    c : int[] = {1,3,5,7,9,11}
-    d : int[] = {2,4,6,8,10}
+    e : int[] = {1,3,5,7,9,11}
+    f : int[] = {2,4,6,8,10}
 
     x : int[] = mergeTwoLists(a,b); //1,1,2,2,3,4
     y : int[] = mergeTwoLists(c,d); //2,3,4,6,8,9
Index: tests/pa4Tests/trappingrainwater.eta
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>trap(height:int[]): int {\n    leftToRight:int[length(height)]\n    rightToLeft:int[length(height)]\n\n    currMax : int = 0\n    i : int = 0\n    while (i < length(height)) {\n        if (height[i] > currMax) {\n            currMax = height[i]\n        }\n\n        leftToRight[i] = currMax\n        i = i + 1\n    }\n\n    currMax = 0\n    i = length(height) - 1\n    while (i > -1) {\n        if (height[i] > currMax) {\n                currMax = height[i]\n        }\n        rightToLeft[i] = (currMax)\n        i = i - 1\n    }\n\n    minimum : int[length(height)]\n    i = 0\n    while (i < length(height)) {\n        if (leftToRight[i] <= rightToLeft[i]) {\n            minimum[i] = leftToRight[i]\n        } else {\n            minimum[i] = rightToLeft[i]\n        }\n        i = i + 1\n    }\n\n    water : int[length(height)]\n    i = 0\n    while (i < length(height)) {\n        water[i] = (minimum[i] - height[i])\n        i = i + 1\n    }\n\n    sum : int = 0\n    i = 0\n    while (i < length(height)) {\n        sum = sum + water[i]\n        i = i + 1\n    }\n    return sum\n}\n\nmain(args:int[][]){\n    a : int[] = {0,1,0,2,1,0,1,3,2,1,2,1}\n    b : int[] = {4,2,0,3,2,5}\n\n    c : int = trap(a)\n    d : int = trap(b)\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/tests/pa4Tests/trappingrainwater.eta b/tests/pa4Tests/trappingrainwater.eta
--- a/tests/pa4Tests/trappingrainwater.eta	(revision 6354dbb1be98946385980e251280eddbfebeeadd)
+++ b/tests/pa4Tests/trappingrainwater.eta	(date 1678909337012)
@@ -1,3 +1,5 @@
+use io
+use conv
 trap(height:int[]): int {
     leftToRight:int[length(height)]
     rightToLeft:int[length(height)]
@@ -55,5 +57,7 @@
     b : int[] = {4,2,0,3,2,5}
 
     c : int = trap(a)
+    println(unparseInt(c));
     d : int = trap(b)
+    println(unparseInt(d));
 }
\ No newline at end of file
