Index: src/main/java/aar226_akc55_ayc62_ahl88/src/edu/cornell/cs/cs4120/xic/ir/visit/AbstractASMVisitor.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package aar226_akc55_ayc62_ahl88.src.edu.cornell.cs.cs4120.xic.ir.visit;\n\nimport aar226_akc55_ayc62_ahl88.asm.*;\nimport aar226_akc55_ayc62_ahl88.asm.Expressions.*;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.ASMArg2;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.ASMComment;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.ASMInstruction;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.ASMLabel;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.arithmetic.ASMAdd;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.arithmetic.ASMIDiv;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.arithmetic.ASMIMul;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.arithmetic.ASMSub;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.bitwise.*;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.jumps.*;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.mov.ASMMov;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.mov.ASMMovabs;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.stackops.ASMPop;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.stackops.ASMPush;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.subroutine.ASMCall;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.subroutine.ASMEnter;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.subroutine.ASMLeave;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.subroutine.ASMRet;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.tstcmp.*;\nimport aar226_akc55_ayc62_ahl88.src.edu.cornell.cs.cs4120.xic.ir.*;\nimport aar226_akc55_ayc62_ahl88.src.polyglot.util.InternalCompilerError;\nimport aar226_akc55_ayc62_ahl88.src.polyglot.util.Pair;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\n\n/**\n * NOTES:\n * - branches: use cmp then corresponding jump\n * - multireturn: store first argument in rax, push rest on stack\n * - function args: rdi, rsi, rdx, rcx, r8, r9, push rest on stack\n * - callee saved: rbx, rbp, and r12â€“r15\n * - caller saved: everything else\n * THINGS WE NEEEEEEEEEEEDDDDDDDDD\n * - ir compunit ->\n *      add glob mem locations\n *      call visit to all functions\n * - ir func decl ->\n *      create new label at the top for function name\n *      follow abi for args and register alloc\n *      call visit on each statement\n *      flatten arraylist we get back\n *      follow abi for correct func exit\n * - jump -> jr <label name>\n * - cjump ->\n *      two args: cmp <t1> <t2>; j<flag> <label name>\n *      if instance of IRConst and is boolliteral: true -> jr / false -> nothing\n * - move ->\n *      mooooooooooooove\n *      contains expr: used for dynamic tiling\n *      tiling\n * - mem\n * - binop\n * - call stmt ->\n *      init function call follow abi for function call (store func args correctly)\n *      jump to function\n *      clean accroding to ABI spec (be careful about multireturns and stack dead space)\n *      pop from function\n * - IR Label -> ASM label\n * Generic ASM Class will be called ASMNode\n */\n\npublic class AbstractASMVisitor {\n    private int tempCnt = 0;\n\n//    private HashMap<String,HashSet<String>> functionToTemps = new HashMap<>();\n\n    private final HashMap<String, Pair<Integer,Integer>> functionsNameToSig = new HashMap<>();\n\n    private String nxtTemp() {\n        return String.format(\"_ASMReg_t%d\", (tempCnt++));\n    }\n    private ASMDirectives getType(String name) {\n        String type = name.split(\"_\")[0];\n        if (type.equals(\"i\") || type.equals(\"b\")) {\n            return ASMDirectives.QUAD;\n        }\n        return ASMDirectives.ZERO;\n    }\n    // converts an IR TEMP to an ASM TEMP\n    private ASMTempExpr tempToASM(IRTemp t) {\n        return new ASMTempExpr(t.name());\n    }\n\n    public ArrayList<ASMInstruction> visit(IRData node){\n        throw new InternalCompilerError(\"not visiting IRDATA\");\n    }\n\n    public ASMInstruction binopCondToOpCode(IRBinOp bin,IRCJump node){\n        ASMNameExpr label = new ASMNameExpr(node.trueLabel());\n        return switch (bin.opType()){\n            case EQ -> new ASMJumpEqual(label);\n            case NEQ -> new ASMJumpNotEqual(label);\n            case LT -> new ASMJumpLT(label);\n            case ULT -> new ASMJumpULT(label);\n            case GT -> new ASMJumpGT(label);\n            case LEQ -> new ASMJumpLE(label);\n            case GEQ -> new ASMJumpGE(label);\n            default -> throw new InternalCompilerError(\"binop Cond is not boolean it is: \" + bin);\n        };\n    }\n    public ArrayList<ASMInstruction> visit(IRCJump node) {\n        ArrayList<ASMInstruction> instructions = new ArrayList<>();\n\n        IRExpr condition = node.cond();\n\n        if (condition instanceof IRBinOp c) { // maybe test is faster\n            // create function for IRBINOP\n            // DO A CMP instead\n            ASMAbstractReg tleft = munchIRExpr(c.left());\n            ASMAbstractReg tright = munchIRExpr(c.right());\n            instructions.addAll(c.left().getBestInstructions()); // instrs to create left temp\n            instructions.addAll(c.right().getBestInstructions()); // instrs to create right temp\n            instructions.add(new ASMCmp(tleft,tright)); // cmp\n            instructions.add(binopCondToOpCode(c,node));\n        } else if (condition instanceof IRConst c) {\n            if (c.value() != 0L){ // jump\n                instructions.add(new ASMJumpAlways(new ASMNameExpr(node.trueLabel())));\n            }\n        } else if (condition instanceof IRTemp c) {\n//            functionToTemps.get(curFunction).add(c.name());\n            ASMTempExpr tempName = tempToASM(c);\n            instructions.add(new ASMTest(tempName,tempName));\n            instructions.add(new ASMJumpNotEqual(new ASMNameExpr(node.trueLabel())));\n            //test t, t\n            //jnz l\n        } else if (condition instanceof IRMem c) {\n            ASMAbstractReg tempMem = munchIRExpr(c);\n            instructions.addAll(c.getBestInstructions());\n            instructions.add(new ASMTest(tempMem,tempMem));\n            instructions.add(new ASMJumpNotEqual(new ASMNameExpr(node.trueLabel())));\n            // do temp test and ASM Jump no Equal\n        }else{\n            throw new InternalCompilerError(\"CJUMP guard has another type\");\n        }\n        return instructions;\n    }\n    public ASMCompUnit visit(IRCompUnit node) {\n        HashSet<ASMData> globals = new HashSet<>();\n        HashMap<String, ArrayList<ASMInstruction>> functionToInstructionList = new HashMap<>();\n        HashMap<String, HashSet<String>> functionToTempsMapping = new HashMap<>();\n        for (IRData data : node.dataMap().values()) {\n            ASMLabel data_label = new ASMLabel(data.name());\n            ASMData data_instr = new ASMData(data_label, data.data());\n            globals.add(data_instr);\n            // add to ASMCOMP UNIT GLOBAL\n        }\n\n        for (IRFuncDecl func : node.functions().values()) {\n            String curFunction = func.name();\n//            functionToTemps.put(func.name(),new HashSet<>());\n            ArrayList<ASMInstruction> functionInstructions = visit(func);\n//            functionToTempsMapping.put(curFunction,functionToTemps.get(curFunction));\n            functionToInstructionList.put(curFunction,functionInstructions);\n//            replaceTemps(functionInstructions,curFunction);\n//            instructions.addAll(functionInstructions);\n        }\n\n        return new ASMCompUnit(globals,functionToInstructionList,functionToTempsMapping,functionsNameToSig);\n    }\n    public ArrayList<ASMInstruction> visit (IRConst x) {\n        ArrayList<ASMInstruction> instructions = new ArrayList<>();\n        boolean isInt = x.value() <= Integer.MAX_VALUE && x.value() >= Integer.MIN_VALUE;\n        ASMArg2 instruction = (isInt) ? new ASMMov(new ASMTempExpr(nxtTemp()),new ASMConstExpr(x.value()))\n                : new ASMMovabs(new ASMTempExpr(nxtTemp()),new ASMConstExpr(x.value()));\n        instructions.add(instruction);\n        return instructions;\n    }\n    public ArrayList<ASMInstruction> visit(IRFuncDecl node) {\n        ArrayList<ASMInstruction> result = new ArrayList<>();\n\n        // create new Starting label for this Function\n        result.add(new ASMLabel(node.name()));\n\n//        enter at Botoom\n//        push rbp\n//        mov rbp rsp\n//        sub rsp, 8*l\n//        result.add(new ASMPush(new ASMRegisterExpr(\"rbp\")));\n//        result.add(new ASMMov(new ASMRegisterExpr(\"rbp\"),new ASMRegisterExpr(\"rsp\")));\n\n        // need to calculate number of temporaries used\n\n        ArrayList<String> temps = new ArrayList<>();\n        // foo(1,2,3,4,5,6,7....) -> rdi, rsi, rdx, rcx, r8, r9, stack\n        int numParams = node.functionSig.inputTypes.size();\n        int numReturns = node.functionSig.outputTypes.size();\n        IRSeq body = (IRSeq) node.body();\n        for (int i = 0; i< numParams;i++){\n            IRMove nameAndArg = (IRMove) body.stmts().get(i);\n            IRTemp name = (IRTemp) nameAndArg.target();\n            temps.add(name.name());\n        }\n        ArrayList<ASMInstruction> bodyInstructions = new ArrayList<>();\n\n        if (numReturns > 2){\n//            functionToTemps.get(curFunction).add(\"_returnBase\");\n            bodyInstructions.add(new ASMMov(\n                    new ASMTempExpr(\"_returnBase\"),\n                    new ASMRegisterExpr(\"rdi\")\n            ));\n        }\n\n        int start = numReturns > 2 ? 2: 1;\n        int end   = numReturns > 2 ? numParams +1: numParams;\n        for (int i = start; i<=end;i++){\n\n            // Move arg into argI. argI <- RDI\n            ASMExpr ARGI = switch (i) {\n                case 1 -> new ASMRegisterExpr(\"rdi\");\n                case 2 -> new ASMRegisterExpr(\"rsi\");\n                case 3 -> new ASMRegisterExpr(\"rdx\");\n                case 4 -> new ASMRegisterExpr(\"rcx\");\n                case 5 -> new ASMRegisterExpr(\"r8\");\n                case 6 -> new ASMRegisterExpr(\"r9\");\n                default ->\n                        new ASMMemExpr(\n                                new ASMBinOpAddExpr(\n                                        new ASMRegisterExpr(\"rbp\"),\n                                        new ASMConstExpr(8L * (i - 7 + 2))));\n            };\n//            String tempName = \"_ARG\" + i;\n            String tempName = numReturns > 2 ? temps.get(i-2):temps.get(i-1);\n//            functionToTemps.get(curFunction).add(tempName);\n            // can't do [stack location] <- [stack location2]\n            // need intermediate rax <- [stack location2]\n            // then [stack location] <- temp rax\n//            if (i>=7){\n//                bodyInstructions.add(new ASMMov(new ASMRegisterExpr(\"rax\"),ARGI));\n//                bodyInstructions.add(new ASMMov(new ASMTempExpr(tempName),new ASMRegisterExpr(\"rax\")));\n//            }\n//            // just do MOV [stack location] <- register\n//            else{\n//                bodyInstructions.add(new ASMMov(new ASMTempExpr(tempName),ARGI));\n//            }\n            bodyInstructions.add(new ASMMov(new ASMTempExpr(tempName),ARGI));\n        }\n        if (node.body() instanceof  IRSeq seq){\n            for (int i = numParams;i< seq.stmts().size();i++){\n                IRStmt stmt = seq.stmts().get(i);\n                bodyInstructions.addAll(stmt.accept(this));\n            }\n        }else{\n            throw new InternalCompilerError(\"body isn't a seq\");\n        }\n        // add enter at begin.\n        // enter 8*L, 0\n//        ASMEnter begin = new ASMEnter(new ASMConstExpr(8L*functionToTemps.get(curFunction).size()),new ASMConstExpr(0));\n        ASMEnter begin = new ASMEnter(new ASMConstExpr(0),new ASMConstExpr(0));\n        result.add(begin);\n        result.addAll(bodyInstructions);\n        return result;\n    }\n    public ArrayList<ASMInstruction> visit(IRJump jump) {\n        ArrayList<ASMInstruction> instructions = new ArrayList<>();\n        if (jump.target() instanceof IRName) {\n            instructions.add(new ASMJumpAlways(new ASMNameExpr(jump.label())));\n        }\n        return instructions;\n    }\n    public ArrayList<ASMInstruction> visit(IRLabel node) {\n        ArrayList<ASMInstruction> instructions = new ArrayList<>();\n        instructions.add(new ASMLabel(node.name()));\n        return instructions;\n    }\n    // Always use these three rax, rcx, and rdx\n    public ArrayList<ASMInstruction> visit(IRMove node){\n        IRExpr dest = node.target();\n        IRExpr source = node.source();\n        ArrayList<ASMInstruction> instructions = new ArrayList<>();\n\n        // TEMP TEMP\n        if (dest instanceof IRTemp t1 && source instanceof IRTemp t2) { // random case for testing atm\n            tileTempTemp(t1, t2, instructions);\n        // TEMP CONST\n        } else if (dest instanceof IRTemp t && source instanceof IRConst x) {\n            tileTempConst(t, x, instructions);\n        // TEMP MEM\n        } else if (dest instanceof IRTemp t && source instanceof IRMem m) {\n            tileTempMem(t, m, instructions);\n        // TEMP BINOP\n        } else if (dest instanceof IRTemp t && source instanceof IRBinOp b) {\n            tileTempBinop(t, b, instructions);\n        // MEM TEMP\n        } else if (dest instanceof IRMem m && source instanceof IRTemp t) {\n            tileMemTemp(m, t, instructions);\n        // MEM MEM\n        } else if (dest instanceof IRMem m1 && source instanceof IRMem m2) {\n            tileMemMem(m1, m2, instructions);\n        // MEM CONST\n        } else if (dest instanceof IRMem m && source instanceof IRConst x) {\n            tileMemConst(m, x, instructions);\n        // MEM BINOP\n        } else if (dest instanceof IRMem m && source instanceof IRBinOp b) {\n            tileMemBinop(m, b, instructions);\n        } else {\n            throw new InternalCompilerError(\"TODO Other moves\");\n        }\n        return instructions;\n    }\n\n    // Base Case\n    public long tileTempTemp(IRTemp t1, IRTemp t2, ArrayList<ASMInstruction> instrs) {\n        instrs.add(new ASMMov(new ASMTempExpr(t1.name()), new ASMTempExpr(t2.name())));\n        return 1;\n    }\n\n    // Base Case\n    public long tileTempConst(IRTemp t, IRConst c, ArrayList<ASMInstruction> instrs) {\n        instrs.add(new ASMMov(new ASMTempExpr(t.name()), new ASMConstExpr(c.value())));\n        return 1;\n    }\n\n    // Can Expand\n    public long tileTempMem(IRTemp t, IRMem m, ArrayList<ASMInstruction> instrs) {\n        long curBestCost = Long.MAX_VALUE;\n        ArrayList<ASMInstruction> curBestInstructions = new ArrayList<>();\n        if (false){ // other patterns;\n\n        }else { // catch all case\n            ASMAbstractReg temp = munchIRExpr(m);\n            if (m.getBestCost() + 1 < curBestCost){\n                ArrayList<ASMInstruction> caseInstructions = new ArrayList<>(m.getBestInstructions()); // instructions for Mem\n                caseInstructions.add(new ASMMov(new ASMTempExpr(t.name()), temp)); // move the temp mem into ASMMOV\n                curBestInstructions = caseInstructions;\n                curBestCost = m.getBestCost() + 1;\n            }\n        }\n        instrs.addAll(curBestInstructions);\n        return curBestCost;\n    }\n\n    // Can Expand\n    public long tileTempBinop(IRTemp t, IRBinOp b, ArrayList<ASMInstruction> instrs) {\n        long curBestCost = Long.MAX_VALUE;\n        ArrayList<ASMInstruction> curBestInstructions = new ArrayList<>();\n        if (false){ // other patterns;\n\n        }else { // catch all case\n            ASMAbstractReg temp = munchIRExpr(b);\n            if (b.getBestCost() + 1 < curBestCost){\n                ArrayList<ASMInstruction> caseInstructions = new ArrayList<>(b.getBestInstructions()); // instructions for Mem\n                caseInstructions.add(new ASMMov(new ASMTempExpr(t.name()), temp)); // move the temp mem into ASMMOV\n                curBestInstructions = caseInstructions;\n                curBestCost = b.getBestCost() + 1;\n            }\n        }\n        instrs.addAll(curBestInstructions);\n        return curBestCost;\n    }\n\n    // Can Expand\n    public long tileMemTemp(IRMem m, IRTemp t, ArrayList<ASMInstruction> instrs) {\n        long curBestCost = Long.MAX_VALUE;\n        ArrayList<ASMInstruction> curBestInstructions = new ArrayList<>();\n        if (false){ // other patterns;\n\n        }else { // catch all case\n            ASMAbstractReg temp = munchIRExpr(m);\n            if (m.getBestCost() + 1 < curBestCost){\n                ArrayList<ASMInstruction> caseInstructions = new ArrayList<>(m.getBestInstructions()); // instructions for Mem\n                caseInstructions.add(new ASMMov(new ASMTempExpr(t.name()), temp)); // move the temp mem into ASMMOV\n                curBestInstructions = caseInstructions;\n                curBestCost = m.getBestCost() + 1;\n            }\n        }\n        instrs.addAll(curBestInstructions);\n        return curBestCost;\n    }\n    // Can Expand\n    public long tileMemMem(IRMem m1, IRMem m2, ArrayList<ASMInstruction> instrs) {\n        long curBestCost = Long.MAX_VALUE;\n        ArrayList<ASMInstruction> curBestInstructions = new ArrayList<>();\n        if (false){ // other patterns;\n\n        }else { // catch all case do right mem then left mem\n            ASMAbstractReg leftTemp = munchIRExpr(m1);\n            ASMAbstractReg rightTemp = munchIRExpr(m2);\n            if (m2.getBestCost() + m1.getBestCost() +  1 < curBestCost){\n                ArrayList<ASMInstruction> caseInstructions = new ArrayList<>(); // instructions for Mem\n                caseInstructions.addAll(m2.getBestInstructions());\n                caseInstructions.addAll(m1.getBestInstructions());\n                caseInstructions.add(new ASMMov(leftTemp, rightTemp)); // move the temp mem into ASMMOV\n                curBestInstructions = caseInstructions;\n                curBestCost = m2.getBestCost() + m1.getBestCost() +  1;\n            }\n        }\n        instrs.addAll(curBestInstructions);\n        return curBestCost;\n    }\n    // Can Expand\n    public long tileMemConst(IRMem m, IRConst c, ArrayList<ASMInstruction> instrs) {\n        long curBestCost = Long.MAX_VALUE;\n        ArrayList<ASMInstruction> curBestInstructions = new ArrayList<>();\n        if (false){ // other patterns;\n\n        }else { // catch all case\n            ASMAbstractReg temp = munchIRExpr(m);\n            if (m.getBestCost() + 1 < curBestCost){\n                ArrayList<ASMInstruction> caseInstructions = new ArrayList<>(m.getBestInstructions()); // instructions for Mem\n                caseInstructions.add(new ASMMov(temp, new ASMConstExpr(c.value()))); // move the temp mem into ASMMOV\n                curBestInstructions = caseInstructions;\n                curBestCost = m.getBestCost() + 1;\n            }\n        }\n        instrs.addAll(curBestInstructions);\n        return curBestCost;\n    }\n    // Can Expand\n    public long tileMemBinop(IRMem m, IRBinOp b, ArrayList<ASMInstruction> instrs) {\n        long curBestCost = Long.MAX_VALUE;\n        ArrayList<ASMInstruction> curBestInstructions = new ArrayList<>();\n        if (false){ // other patterns;\n\n        }else { // catch all case\n            ASMAbstractReg temp1 = munchIRExpr(m);\n            ASMAbstractReg temp2 = munchIRExpr(b);\n            if (m.getBestCost() + b.getBestCost() + 1 < curBestCost){\n                ArrayList<ASMInstruction> caseInstructions = new ArrayList<>(); // instructions for Mem\n                caseInstructions.addAll(b.getBestInstructions());\n                caseInstructions.addAll(m.getBestInstructions());\n                caseInstructions.add(new ASMMov(temp1, temp2)); // move the temp mem into ASMMOV\n                curBestInstructions = caseInstructions;\n                curBestCost = m.getBestCost() + 1;\n            }\n        }\n        instrs.addAll(curBestInstructions);\n        return curBestCost;\n    }\n\n    private ASMAbstractReg munchIRExpr(IRExpr e) {\n        IRNode_c top = (IRNode_c) e;\n        if (top.visited){\n            System.out.println(\"visited\");\n            return top.tempName;\n        }\n        if (e instanceof IRBinOp binop) {\n            return munchBinop(binop);\n        }else if (e instanceof IRTemp t){\n            return munchTemp(t);\n        }else if (e instanceof IRConst cons){\n            return munchIRConst(cons);\n        }else if (e instanceof IRName name){ // cheese way of doing it\n            return munchIRName(name);\n        }else if (e instanceof IRMem mem){\n            return munchIRMem(mem);\n        }else{\n            throw new InternalCompilerError(\"TODO EXPR not tested\");\n        }\n    }\n    private ASMTempExpr munchIRName(IRName name) {\n        name.visited = true;\n        name.bestCost = 0;\n        name.bestInstructions = new ArrayList<>();\n        return new ASMTempExpr(name.name());\n    }\n    private ASMTempExpr munchIRMem(IRMem mem) {\n        long curBestCost = Long.MAX_VALUE;\n        ArrayList<ASMInstruction> curBestInstructions = new ArrayList<>();\n        ASMTempExpr destTemp = new ASMTempExpr(nxtTemp());\n        if (false){ // other patterns;\n\n        }else { // catch all case\n            ASMAbstractReg munched = munchIRExpr(mem.expr());\n            if ( mem.expr().getBestCost() +1 < curBestCost){\n                ArrayList<ASMInstruction> caseInstructions = new ArrayList<>(mem.expr().getBestInstructions()); // instructions for Mem\n                caseInstructions.add(new ASMMov(destTemp,new ASMMemExpr(munched)));\n                curBestInstructions = caseInstructions;\n                curBestCost = mem.expr().getBestCost() +1;\n            }\n        }\n        mem.visited = true;\n        mem.bestCost = curBestCost;\n        mem.bestInstructions = curBestInstructions;\n        return destTemp;\n//        return null;\n    }\n    private ASMTempExpr munchTemp(IRTemp temp) {\n        temp.visited = true;\n        temp.bestCost = 0;\n        temp.bestInstructions = new ArrayList<>();\n        return new ASMTempExpr(temp.name());\n    }\n    private ASMTempExpr munchIRConst(IRConst c){\n        c.visited = true;\n        c.bestCost = 1;\n        String extraTemp = nxtTemp();\n        ArrayList<ASMInstruction> extraInstructions = new ArrayList<>();\n        extraInstructions.add(new ASMMov(new ASMTempExpr(extraTemp),new ASMConstExpr(c.value())));\n        c.bestInstructions = extraInstructions;\n        return new ASMTempExpr(extraTemp);\n    }\n    private ASMAbstractReg munchBinop(IRBinOp binop) {\n        // TODO: LATER ADD TEMP/CONST, TEMP/TEMP, CONST/TEMP, ELSE MUCH\n        ASMAbstractReg l1 = munchIRExpr(binop.left());\n        ASMAbstractReg l2 = munchIRExpr(binop.right());\n        ASMTempExpr destTemp = new ASMTempExpr(nxtTemp());\n        ArrayList<ASMInstruction> instrs = new ArrayList<>();\n        instrs.addAll(binop.left().getBestInstructions());\n        instrs.addAll(binop.right().getBestInstructions());\n        switch (binop.opType()) {\n            case ADD:\n                binop.bestCost = binop.left().getBestCost() +\n                        binop.right().getBestCost() + 2;\n                instrs.add(new ASMMov(destTemp, l1));\n                instrs.add(new ASMAdd(l1, l2));\n                break;\n            case MUL:\n                binop.bestCost = binop.left().getBestCost() +\n                        binop.right().getBestCost() + 2;\n                instrs.add(new ASMMov(destTemp, l1));\n                instrs.add(new ASMIMul(destTemp, l2));\n                break;\n            case DIV: // rax/div, store result in rax and remainder in rdx\n                binop.bestCost = binop.left().getBestCost() +\n                        binop.right().getBestCost() + 2;\n                instrs.add(new ASMMov(new ASMRegisterExpr(\"rax\"), l1));\n                instrs.add(new ASMIDiv(l2));\n                instrs.add(new ASMMov(destTemp, new ASMRegisterExpr(\"rax\")));\n                break;\n            case SUB:\n                binop.bestCost = binop.left().getBestCost() +\n                        binop.right().getBestCost() + 2;\n                instrs.add(new ASMMov(destTemp, l1));\n                instrs.add(new ASMArg2(ASMOpCodes.SUB, destTemp, l2));\n                break;\n            case HMUL: // TODO: fix this\n                binop.bestCost = binop.left().getBestCost() +\n                        binop.right().getBestCost() + 5;\n                ASMTempExpr srcTemp = new ASMTempExpr(nxtTemp());\n\n                instrs.add(new ASMMov(destTemp, l1));\n                instrs.add(new ASMShr(srcTemp, l2));\n                instrs.add(new ASMShr(destTemp, new ASMConstExpr(32)));\n                instrs.add(new ASMShr(srcTemp, new ASMConstExpr(32)));\n                instrs.add(new ASMIMul(destTemp, srcTemp));\n                break;\n            case MOD: // rax/div, store result in rax and remainder in rdx\n                binop.bestCost = binop.left().getBestCost() +\n                        binop.right().getBestCost() + 3;\n                instrs.add(new ASMMov(new ASMRegisterExpr(\"rax\"), l1));\n                instrs.add(new ASMIDiv(l2));\n                instrs.add(new ASMMov(destTemp, new ASMRegisterExpr(\"rdx\")));\n                break;\n            case AND:\n                binop.bestCost = binop.left().getBestCost() +\n                        binop.right().getBestCost() + 2;\n                instrs.add(new ASMMov(destTemp, l1));\n                instrs.add(new ASMAnd(destTemp, l2));\n                break;\n            case OR:\n                binop.bestCost = binop.left().getBestCost() +\n                        binop.right().getBestCost() + 2;\n                instrs.add(new ASMMov(destTemp, l1));\n                instrs.add(new ASMOr(destTemp, l2));\n                break;\n            case XOR:\n                binop.bestCost = binop.left().getBestCost() +\n                        binop.right().getBestCost() + 2;\n                instrs.add(new ASMMov(destTemp, l1));\n                instrs.add(new ASMXor(destTemp, l2));\n                break;\n            case LSHIFT: // logical left shift\n                binop.bestCost = binop.left().getBestCost() +\n                        binop.right().getBestCost() + 2;\n                instrs.add(new ASMMov(destTemp, l1));\n                instrs.add(new ASMShl(destTemp, l2));\n                break;\n            case RSHIFT: // logical right shift\n                binop.bestCost = binop.left().getBestCost() +\n                        binop.right().getBestCost() + 2;\n                instrs.add(new ASMMov(destTemp, l1));\n                instrs.add(new ASMShr(destTemp, l2));\n                break;\n            case ARSHIFT:\n                binop.bestCost = binop.left().getBestCost() +\n                        binop.right().getBestCost() + 2;\n                instrs.add(new ASMMov(destTemp, l1));\n                instrs.add(new ASMSar(destTemp, l2));\n                break;\n            case EQ:\n                binop.bestCost = binop.left().getBestCost() +\n                        binop.right().getBestCost() + 4;\n                instrs.add(new ASMMov(destTemp, l1));\n                instrs.add(new ASMCmp(destTemp, l2));\n                instrs.add(new ASMSete(new ASMRegisterExpr(\"al\")));\n//                instrs.add(new ASMAnd(al, new ASMConstExpr(1))); in clang but not in gcc\n                instrs.add(new ASMMov(destTemp, new ASMRegisterExpr(\"al\")));\n                break;\n            case NEQ:\n                binop.bestCost = binop.left().getBestCost() +\n                        binop.right().getBestCost() + 4;\n                instrs.add(new ASMMov(destTemp, l1));\n                instrs.add(new ASMCmp(destTemp, l2));\n                instrs.add(new ASMSetne(new ASMRegisterExpr(\"al\")));\n//                instrs.add(new ASMAnd(al, new ASMConstExpr(1))); in clang but not in gcc\n                instrs.add(new ASMMov(destTemp, new ASMRegisterExpr(\"al\")));\n                break;\n            case LT:\n                binop.bestCost = binop.left().getBestCost() +\n                        binop.right().getBestCost() + 4;\n                instrs.add(new ASMMov(destTemp, l1));\n                instrs.add(new ASMCmp(destTemp, l2));\n                instrs.add(new ASMSetl(new ASMRegisterExpr(\"al\")));\n//                instrs.add(new ASMAnd(al, new ASMConstExpr(1))); in clang but not in gcc\n                instrs.add(new ASMMov(destTemp, new ASMRegisterExpr(\"al\")));\n                break;\n            case ULT:\n                binop.bestCost = binop.left().getBestCost() +\n                        binop.right().getBestCost() + 4;\n                instrs.add(new ASMMov(destTemp, l1));\n                instrs.add(new ASMCmp(destTemp, l2));\n                instrs.add(new ASMSetb(new ASMRegisterExpr(\"al\")));\n                //                instrs.add(new ASMAnd(al, new ASMConstExpr(1))); in clang but not in gcc\n                instrs.add(new ASMMov(destTemp, new ASMRegisterExpr(\"al\")));\n                break;\n            case GT:\n                binop.bestCost = binop.left().getBestCost() +\n                        binop.right().getBestCost() + 4;\n                instrs.add(new ASMMov(destTemp, l1));\n                instrs.add(new ASMCmp(destTemp, l2));\n                instrs.add(new ASMSetg(new ASMRegisterExpr(\"al\")));\n//                instrs.add(new ASMAnd(al, new ASMConstExpr(1))); in clang but not in gcc\n                instrs.add(new ASMMov(destTemp, new ASMRegisterExpr(\"al\")));\n                break;\n            case LEQ:\n                binop.bestCost = binop.left().getBestCost() +\n                        binop.right().getBestCost() + 4;\n                instrs.add(new ASMMov(destTemp, l1));\n                instrs.add(new ASMCmp(destTemp, l2));\n                instrs.add(new ASMSetle(new ASMRegisterExpr(\"al\")));\n//                instrs.add(new ASMAnd(al, new ASMConstExpr(1))); in clang but not in gcc\n                instrs.add(new ASMMov(destTemp, new ASMRegisterExpr(\"al\")));\n                break;\n            case GEQ:\n                binop.bestCost = binop.left().getBestCost() +\n                        binop.right().getBestCost() + 4;\n                instrs.add(new ASMMov(destTemp, l1));\n                instrs.add(new ASMCmp(destTemp, l2));\n                instrs.add(new ASMSetge(new ASMRegisterExpr(\"al\")));\n//                instrs.add(new ASMAnd(al, new ASMConstExpr(1))); in clang but not in gcc\n                instrs.add(new ASMMov(destTemp, new ASMRegisterExpr(\"al\")));\n                break;\n        }\n        binop.bestInstructions = instrs;\n        binop.visited = true;\n        return destTemp;\n    }\n\n\n\n\n    public ArrayList<ASMInstruction> visit(IRSeq node){\n        ArrayList<ASMInstruction> instructions = new ArrayList<>();\n        for (IRStmt stmt : node.stmts()) {\n            ArrayList<ASMInstruction> stmtInstrs = stmt.accept(this);\n            instructions.addAll(stmtInstrs);\n        }\n        return instructions;\n    }\n    public ArrayList<ASMInstruction> visit(IRReturn node) {\n        //\n        ArrayList<ASMInstruction> returnInstructions = new ArrayList<>();\n        int returnSize = node.rets().size();\n\n        ArrayList<String> tempNames = new ArrayList<>();\n        //in case returns stop being temporaries in the future.\n        for (IRExpr e: node.rets()){\n             if (e instanceof IRTemp t){\n                tempNames.add(t.name());\n             }else{\n                 System.out.println(\"return is not a temp? \" + e);\n                 String nxtName = nxtTemp();\n                 tempNames.add(nxtName);\n//                 ASMTempExpr tmp = new ASMTempExpr(nxtName);\n                 // need to translate\n                 throw new InternalCompilerError(\"return has an element that isn't a temp\");\n             }\n        }\n//        functionToTemps.get(curFunction).addAll(tempNames);\n        // looping in reverse so rax can be used temporarily until the end\n        for (int i = 1; i <= returnSize; i++) {\n            // move expression to Return Location\n            // Move ret into reti. reti <- RDI\n            ASMExpr retI = switch (i) {\n                case 1 -> new ASMRegisterExpr(\"rax\");\n                case 2 -> new ASMRegisterExpr(\"rdx\");\n                default -> new ASMMemExpr(\n                        new ASMBinOpAddExpr(\n                                new ASMTempExpr(\"_returnBase\"),\n                                new ASMConstExpr(8L*(i-3))));\n            };\n//\n//            if (i >2){\n//                if (i == 3){\n//                    returnInstructions.add(new ASMMov(new ASMRegisterExpr(\"rsi\"),\n//                            new ASMTempExpr(\"_returnBase\")));\n//                }\n//                System.out.println(\"greater than 3\");\n//                // just in case we just put everything on the stack lol need intermediate\n//                // rcx <- [origin]\n//                returnInstructions.add(new ASMMov(new ASMRegisterExpr(\"rcx\"),new ASMTempExpr(tempNames.get(i-1)))); // check this\n//                // [dest] <- rcx\n//                returnInstructions.add(new ASMMov(retI,new ASMRegisterExpr(\"rcx\")));\n//            }else{\n//                returnInstructions.add(new ASMMov(retI,new ASMTempExpr(tempNames.get(i-1))));\n//            }\n            returnInstructions.add(new ASMMov(retI,new ASMTempExpr(tempNames.get(i-1))));\n        }\n\n        // leave\n        // ret\n        returnInstructions.add(new ASMLeave());\n        returnInstructions.add(new ASMRet());\n        return returnInstructions;\n    }\n    public ArrayList<ASMInstruction> visit(IRCallStmt node) {\n        ArrayList<ASMInstruction> instructions = new ArrayList<>();\n        IRName functionName = (IRName) node.target();\n        int argSiz = node.args().size();\n        ArrayList<String> tempNames = new ArrayList<>();\n        //in case returns stop being temporaries in the future.\n        // Will have to revisit translation too if we change iRCALLSTMT\n        // Move the Push translations to later\n        for (IRExpr e: node.args()){\n            if (e instanceof IRTemp t){\n                tempNames.add(t.name());\n            }else{\n                System.out.println(\"call is not a temp? \" + e);\n                String nxtName = nxtTemp();\n                tempNames.add(nxtName);\n                ASMTempExpr tmp = new ASMTempExpr(nxtName);\n                // need to translate\n                throw new InternalCompilerError(\"return has an element that isn't a temp\");\n            }\n        }\n//        functionToTemps.get(curFunction).addAll(tempNames);\n        instructions.add(new ASMComment(\"Add Padding\",functionName.name()));\n        // add extra stack space for returns\n        if (node.n_returns() >2){\n            instructions.add(new ASMSub(\n                    new ASMRegisterExpr(\"rsp\"),\n                    new ASMConstExpr(8* (node.n_returns()-2))));\n            instructions.add(new ASMMov(\n                    new ASMRegisterExpr(\"rdi\"),\n                    new ASMRegisterExpr(\"rsp\")));\n        }\n        // pushes for Arguments\n        if (argSiz >= 6){\n            int end = node.n_returns() > 2 ? 6 : 7;\n            int ind = tempNames.size();\n            while (ind >= end){\n                instructions.add(new ASMPush(new ASMTempExpr(tempNames.get(ind-1))));\n                ind--;\n            }\n        }\n        int start = node.n_returns() > 2 ? Math.min(argSiz+1,6): Math.min(argSiz,6);\n        int end = node.n_returns() > 2 ? 2 : 1;\n        for (int i = start; i >= end; i--) {\n            // move expression from temp to required register\n            // Move ret into reti. reti <- RDI\n            ASMExpr argI = switch (i) {\n                case 1 -> new ASMRegisterExpr(\"rdi\");\n                case 2 -> new ASMRegisterExpr(\"rsi\");\n                case 3 -> new ASMRegisterExpr(\"rdx\");\n                case 4 -> new ASMRegisterExpr(\"rcx\");\n                case 5 -> new ASMRegisterExpr(\"r8\");\n                case 6 -> new ASMRegisterExpr(\"r9\");\n                default -> throw new InternalCompilerError(\"should not be in default for Function Call\");\n            };\n            int loc = node.n_returns() > 2? i-2: i-1;\n            String tempName = tempNames.get(loc);\n            instructions.add(new ASMMov(argI,new ASMTempExpr(tempName)));\n        }\n        // Align by 16 bytes I have no idea how\n        functionsNameToSig.put(functionName.name(),new Pair<>(argSiz,node.n_returns().intValue()));\n        instructions.add(new ASMCall(new ASMNameExpr(functionName.name())));\n\n        if (argSiz > 6 && node.n_returns() <= 2){\n            instructions.add(new ASMAdd(new ASMRegisterExpr(\"rsp\"),\n                    new ASMConstExpr(8L*(argSiz-6))));\n        }else if (argSiz > 5 && node.n_returns() > 2){\n//            System.out.println(\"im here\");\n            instructions.add(new ASMAdd(new ASMRegisterExpr(\"rsp\"),\n                    new ASMConstExpr(8L*(argSiz-5))));\n        }\n        String ret = \"_RV\";\n        for (int i = 1; i<= node.n_returns();i++){\n            ASMTempExpr temp = new ASMTempExpr(ret+i);\n            if (i == 1){\n                instructions.add(new ASMMov(temp,new ASMRegisterExpr(\"rax\")));\n            }else if (i == 2){\n                instructions.add(new ASMMov(temp,new ASMRegisterExpr(\"rdx\")));\n            }else{\n                instructions.add(new ASMPop(temp));\n            }\n        }\n        instructions.add(new ASMComment(\"Undo Padding\",functionName.name()));\n        return instructions;\n    }\n\n    public ArrayList<ASMInstruction> visit(IRExp irExp) {\n        System.out.println(\"don't have irExp\");\n        return new ArrayList<>();\n    }\n\n    public ArrayList<ASMInstruction> visit(IRTemp irTemp) {\n        return null;\n    }\n\n    public ArrayList<ASMInstruction> visit(IRName irName) {\n        return null;\n    }\n\n    public ArrayList<ASMInstruction> visit(IRMem irMem) {\n        return null;\n    }\n\n    public ArrayList<ASMInstruction> visit(IRBinOp irBinOp) {\n        return null;\n    }\n\n    public ArrayList<ASMInstruction> visit(IRESeq ireSeq) {\n        System.out.println(\"don't have ireSeq\");\n        return new ArrayList<>();\n    }\n\n    public ArrayList<ASMInstruction> visit(IRCall irCall) {\n        System.out.println(\"don't have irCall\");\n        return new ArrayList<>();\n    }\n\n    private ArrayList<ASMInstruction> visitExpression(IRExpr expr) {\n        if (expr instanceof IRBinOp bop)\n            return visit(bop);\n        else if (expr instanceof IRCallStmt call)\n            return visit(call);\n        else if (expr instanceof IRConst cnst)\n            return visit(cnst);\n        else if (expr instanceof IRMem mem)\n            return visit(mem);\n        else if (expr instanceof IRName name)\n            return visit(name);\n        else if (expr instanceof IRTemp tmp)\n            return visit(tmp);\n        else throw new InternalCompilerError(\"Invalid expression for visitExpression\");\n    }\n\n//    private void replaceTemps(ArrayList<ASMInstruction> instructions, String functionName){\n//        functionToTemps.get(functionName);\n//        int index = 1;\n//        HashMap<String, Integer> tempToStack = new HashMap<>();\n//        for (String temp: functionToTemps.get(functionName)){\n//            tempToStack.put(temp,index*8);\n//            index++;\n//        }\n//        for (ASMInstruction instr: instructions){\n//            instr.createPrint(tempToStack);\n//            System.out.println(instr);\n//        }\n//    }\n\n    // TODO: 4/1/2023\n    // move\n    // TODO: 4/1/2023\n    // temp\n    // TODO: 4/1/2023\n    // mem\n    // TODO: 4/1/2023\n    // call_stmt\n    // TODO: 4/1/2023\n    // name\n    // TODO: 4/1/2023\n    // RETURN\n}\n\n//    int index = numParams;\n//            while (index < seq.stmts().size()){\n//        IRStmt stmt = seq.stmts().get(index);\n//        bodyInstructions.addAll(stmt.accept(this));\n//        if (stmt instanceof IRCallStmt call){\n//        int rvMoves = Math.toIntExact(call.n_returns());\n//        for (int i = 1; i <= rvMoves;i++){\n//        int getInd = (rvMoves + i-1);\n//        IRMove nameAndArg = (IRMove) body.stmts().get(getInd);\n//        IRTemp name = (IRTemp) nameAndArg.target();\n//        ASMTempExpr retName = new ASMTempExpr(name.name());\n//        if (i == 1){\n//        bodyInstructions.add(new ASMMov(retName,new ASMRegisterExpr(\"rax\")));\n//        }else if (i == 2){\n//        bodyInstructions.add(new ASMMov(retName,new ASMRegisterExpr(\"rdx\")));\n//        }else{\n//        bodyInstructions.add(new ASMPop(retName));\n//        }\n//        }\n//        index += rvMoves+1;\n//        }else{\n//        index++;\n//        }\n//        }\n\n//        if (dest instanceof IRTemp t1 && source instanceof IRTemp t2){ // random case for testing atm\n//            functionToTemps.get(curFunction).add(t1.name());\n//            functionToTemps.get(curFunction).add(t2.name());\n//            instructions.add(new ASMMov(new ASMTempExpr(t1.name()),new ASMTempExpr(t2.name())));\n//        }else if (dest instanceof IRTemp t1 && source instanceof IRConst x){\n//            functionToTemps.get(curFunction).add(t1.name());\n//            boolean isInt = x.value() <= Integer.MAX_VALUE && x.value() >= Integer.MIN_VALUE;\n//            ASMArg2 instruction = (isInt) ? new ASMMov(new ASMTempExpr(t1.name()),new ASMConstExpr(x.value()))\n//                    : new ASMMovabs(new ASMTempExpr(t1.name()),new ASMConstExpr(x.value()));\n//            instructions.add(instruction);\n//        }else{\n//            throw new InternalCompilerError(\"TODO Other moves\");\n//        }
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/aar226_akc55_ayc62_ahl88/src/edu/cornell/cs/cs4120/xic/ir/visit/AbstractASMVisitor.java b/src/main/java/aar226_akc55_ayc62_ahl88/src/edu/cornell/cs/cs4120/xic/ir/visit/AbstractASMVisitor.java
--- a/src/main/java/aar226_akc55_ayc62_ahl88/src/edu/cornell/cs/cs4120/xic/ir/visit/AbstractASMVisitor.java	(revision ebbd6ae1200b2de737d9dcf89c251a5f43dedfc2)
+++ b/src/main/java/aar226_akc55_ayc62_ahl88/src/edu/cornell/cs/cs4120/xic/ir/visit/AbstractASMVisitor.java	(date 1681159260926)
@@ -94,6 +94,18 @@
     public ASMInstruction binopCondToOpCode(IRBinOp bin,IRCJump node){
         ASMNameExpr label = new ASMNameExpr(node.trueLabel());
         return switch (bin.opType()){
+//            case ADD -> null;
+//            case SUB -> null;
+//            case MUL -> null;
+//            case HMUL -> null;
+//            case DIV -> null;
+//            case MOD -> null;
+//            case AND -> null;
+//            case OR -> null;
+//            case XOR -> null;
+//            case LSHIFT -> null;
+//            case RSHIFT -> null;
+//            case ARSHIFT -> null;
             case EQ -> new ASMJumpEqual(label);
             case NEQ -> new ASMJumpNotEqual(label);
             case LT -> new ASMJumpLT(label);
Index: tests/pa4Eth/ex01.eta
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>use io\n\nmain(args: int[][]) {\n  print(\"Hello, Worl\\x{64}!\\n\")\n  c3po: int = 'x' + 47;\n  r2d2: int = c3po // No Han Solo\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/tests/pa4Eth/ex01.eta b/tests/pa4Eth/ex01.eta
--- a/tests/pa4Eth/ex01.eta	(revision ebbd6ae1200b2de737d9dcf89c251a5f43dedfc2)
+++ b/tests/pa4Eth/ex01.eta	(date 1681159410619)
@@ -2,6 +2,6 @@
 
 main(args: int[][]) {
   print("Hello, Worl\x{64}!\n")
-  c3po: int = 'x' + 47;
-  r2d2: int = c3po // No Han Solo
+  //c3po: int = 'x' + 47;
+  //r2d2: int = c3po // No Han Solo
 }
Index: src/main/java/aar226_akc55_ayc62_ahl88/asm/visit/RegisterAllocationTrivialVisitor.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package aar226_akc55_ayc62_ahl88.asm.visit;\n\nimport aar226_akc55_ayc62_ahl88.asm.ASMCompUnit;\nimport aar226_akc55_ayc62_ahl88.asm.ASMOpCodes;\nimport aar226_akc55_ayc62_ahl88.asm.Expressions.*;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.*;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.mov.ASMMov;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.mov.ASMMovabs;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.stackops.ASMPop;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.stackops.ASMPush;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.subroutine.ASMCall;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.subroutine.ASMEnter;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.subroutine.ASMLeave;\nimport aar226_akc55_ayc62_ahl88.src.polyglot.util.InternalCompilerError;\nimport aar226_akc55_ayc62_ahl88.src.polyglot.util.Pair;\n\nimport java.util.*;\n\npublic class RegisterAllocationTrivialVisitor implements ASMVisitor<ArrayList<ASMInstruction>>{\n\n\n    // push these 3 whenever we enter this function ez\n\n    HashMap<String, HashSet<String>> functionToTemps = new HashMap<>();\n    HashMap<String,HashMap<String,Long>> functionToTempsToStackOffset = new HashMap<>();\n\n    HashMap<String, Pair<Integer,Integer>> functionSignatures;\n    String currentFunction;\n\n    public ArrayList<ASMInstruction> visit(ASMCompUnit compUnit){\n        functionSignatures = compUnit.getAllFunctionsSigs();\n        ArrayList<ASMInstruction> total = new ArrayList<>();\n//        for (ASMData d: compUnit.getGlobals()){\n//            System.out.println(\"doing Global\");\n//        }\n        for (Map.Entry<String, ArrayList<ASMInstruction>> function: compUnit.getFunctionToInstructionList().entrySet()){\n            currentFunction = function.getKey();\n            functionToTempsToStackOffset.put(currentFunction,new HashMap<>());\n            functionToTemps.put(currentFunction,new HashSet<>());\n            ArrayList<ASMInstruction> updatedInstructions = fixAllStackAlignments(function);\n            ASMEnter newEnter = createEnterAndBuildMapping(function.getValue());\n            ArrayList<ASMInstruction> functionResult = new ArrayList<>();\n            for (ASMInstruction instr: updatedInstructions){\n                if (!(instr instanceof ASMEnter oldEnter)) {\n                    functionResult.addAll(instr.accept(this));\n                }else{\n                    System.out.println(\"oldEnter: \"+ oldEnter + \" newEnter: \" + newEnter);\n                    functionResult.add(newEnter);\n                    functionResult.add(new ASMPush(new ASMRegisterExpr(\"r12\")));\n                    functionResult.add(new ASMPush(new ASMRegisterExpr(\"r13\")));\n                    functionResult.add(new ASMPush(new ASMRegisterExpr(\"r14\")));\n                }\n            }\n            total.addAll(functionResult);\n        }\n        return total;\n    }\n    @Override\n    public ArrayList<ASMInstruction> visit(ASMComment node) {\n        ArrayList<ASMInstruction> result = new ArrayList<>();\n        result.add(node);\n        return result;\n    }\n    @Override\n    public ArrayList<ASMInstruction> visit(ASMLabel node) {\n        ArrayList<ASMInstruction> result = new ArrayList<>();\n        result.add(node);\n        return result;\n    }\n    @Override\n    public ArrayList<ASMInstruction> visit(ASMArg0 node) { // leave, ret\n        ArrayList<ASMInstruction> res = new ArrayList<>();\n        if (node instanceof ASMLeave){\n            res.add(new ASMPop(new ASMRegisterExpr(\"r14\")));\n            res.add(new ASMPop(new ASMRegisterExpr(\"r13\")));\n            res.add(new ASMPop(new ASMRegisterExpr(\"r12\")));\n        }\n        res.add(node);\n        return res;\n    }\n\n    // CALL SOLO\n    // JUMPS, INC, DEC, NOT, IDIV, POP, PUSH,\n    @Override\n    public ArrayList<ASMInstruction> visit(ASMArg1 node) {\n//        ArrayList<String> availReg = new ArrayList<>(Arrays.asList(\"rax\", \"rcx\",\"rdx\"));\n        ArrayList<String> availReg = new ArrayList<>(Arrays.asList(\"r12\", \"r13\",\"r14\"));\n        ArrayList<ASMInstruction> res = new ArrayList<>();\n        if (node instanceof ASMCall call){\n            // align stack if needed unalign after too dont know how to undo\n//            res.add(new ASMAnd(new ASMRegisterExpr(\"rsp\"),new ASMConstExpr(-16))); // possible to revert idk?\n//            System.out.println(call.toString());\n//            System.out.println(doWeNeedstackAlignment(call));\n//            res.add(call);\n            if (doWeNeedstackAlignment(call.getLeft().toString())){\n//                res.add(new ASMArg2(ASMOpCodes.SUB, new ASMRegisterExpr(\"rsp\"), new ASMConstExpr(8)));\n                res.add(call);\n//                res.add(new ASMArg2(ASMOpCodes.ADD, new ASMRegisterExpr(\"rsp\"), new ASMConstExpr(8)));\n            }else{\n                res.add(call);\n            }\n\n        }else{\n            ASMExpr argument = node.getLeft();\n            if (argument instanceof ASMTempExpr temp){ // migrate temp to stack?\n                String curReg = availReg.get(availReg.size()-1);\n                availReg.remove(availReg.size()-1);\n                // add the move\n                ASMMemExpr stackLoc = tempToStack(temp);\n                ASMRegisterExpr usedReg = new ASMRegisterExpr(curReg);\n                res.add(new ASMMov(usedReg,stackLoc)); // fake reg on stack now moved to real\n                res.add(new ASMArg1(node.getOpCode(),usedReg)); // original instruction with real reg\n                res.add(new ASMMov(stackLoc,usedReg)); // move the real reg back to the stack location\n            }else if (argument instanceof ASMMemExpr mem){ // see if inside mem is temp\n                ArrayList<ASMExpr> expressions = flattenMem(mem);\n                HashMap<String, String> tempToReg= new HashMap<>();\n                for (ASMExpr expr: expressions){\n                    if (expr instanceof ASMTempExpr temp){\n                        // get stack mapping for reg\n                        String curReg = availReg.get(availReg.size()-1);\n                        availReg.remove(availReg.size()-1);\n                        // add the move\n                        ASMMemExpr stackLoc = tempToStack(temp);\n                        ASMRegisterExpr usedReg = new ASMRegisterExpr(curReg);\n                        res.add(new ASMMov(usedReg,stackLoc));\n                        tempToReg.put(temp.getName(),curReg);\n                    }\n                }\n                ASMExpr tempMem = tempsToRegs(mem,tempToReg);\n                res.add(new ASMArg1(node.getOpCode(),tempMem));\n            }else if (argument instanceof ASMConstExpr cons){\n                String curReg = availReg.get(availReg.size()-1);\n                availReg.remove(availReg.size()-1);\n                ASMRegisterExpr usedReg = new ASMRegisterExpr(curReg);\n\n                ASMExpr curSrc = isIMMTooBig(cons,res,availReg);\n                res.add(new ASMMov(usedReg,curSrc));\n            }\n            else{ // no change instruction Jumps\n                res.add(node);\n            }\n        }\n        return res;\n    }\n\n//    ENTER,MOV,MOVABS,\n//    r64, r/m64 ADD,SUB,AND,OR,XOR,SHL,SHR,SAR,TEST,CMP,\n    @Override\n    public ArrayList<ASMInstruction> visit(ASMArg2 node) {\n//        ArrayList<String> availReg = new ArrayList<>(Arrays.asList(\"rax\", \"rcx\",\"rdx\"));\n        ArrayList<String> availReg = new ArrayList<>(Arrays.asList(\"r12\", \"r13\",\"r14\"));\n        ASMExpr left = node.getLeft();\n        ASMExpr right = node.getRight();\n\n        ArrayList<ASMInstruction> res = new ArrayList<>();\n        ArrayList<ASMInstruction> postInstruction = new ArrayList<>();\n        ASMOpCodes opCodes = node.getOpCode();\n        ASMExpr curDest; // replace Left with curDest\n        ASMExpr curSrc;  // replace Right with curSrc\n        if (node instanceof ASMEnter ){\n            throw new InternalCompilerError(\"Enter Replaced Earlier\");\n        }\n\n        if (left instanceof ASMRegisterExpr reg){// known register Return\n            curDest = left;\n            availReg.remove(reg.getRegisterName());\n        }else if (left instanceof ASMTempExpr temp){ // Move left into Reg1 cause left is a stack location\n            // get the stack location through mapping\n            String curReg = availReg.get(availReg.size()-1);\n            availReg.remove(availReg.size()-1);\n            // add the move\n            ASMMemExpr stackLoc = tempToStack(temp);\n            ASMRegisterExpr usedReg = new ASMRegisterExpr(curReg);\n            res.add(new ASMMov(usedReg,stackLoc));\n            postInstruction.add(new ASMMov(stackLoc,usedReg));\n            curDest = usedReg;\n        }else if (left instanceof ASMMemExpr mem){ // Mem\n            // find the memory locations of the temps inside of mem pass in current avail Regs\n            ArrayList<ASMExpr> expressions = flattenMem(mem);\n            HashMap<String, String> tempToReg= new HashMap<>();\n            for (ASMExpr expr: expressions){\n                if (expr instanceof ASMTempExpr temp){\n                    // get stack mapping for reg\n                    String curReg = availReg.get(availReg.size()-1);\n                    availReg.remove(availReg.size()-1);\n                    // add the move\n                    ASMMemExpr stackLoc = tempToStack(temp);\n                    ASMRegisterExpr usedReg = new ASMRegisterExpr(curReg);\n                    res.add(new ASMMov(usedReg,stackLoc));\n                    tempToReg.put(temp.getName(),curReg);\n                }\n            }\n            curDest = tempsToRegs(mem,tempToReg);\n        }else{\n            throw new InternalCompilerError(\"nothing else should be left on the top level\");\n        }\n\n        // need intermediate steps cause both can't be mem\n        // need extra reg\n        if (!(left instanceof ASMMemExpr)){ // left is mem\n            if (right instanceof ASMTempExpr temp) {\n                // Move temp into reg2 cause temp is a stack location\n                String curReg = availReg.get(availReg.size()-1);\n                availReg.remove(availReg.size()-1);\n                // add the move\n                ASMMemExpr stackLoc = tempToStack(temp);\n                ASMRegisterExpr usedReg = new ASMRegisterExpr(curReg);\n                res.add(new ASMMov(usedReg,stackLoc));\n                curSrc = usedReg;\n                // use reg 2 for right\n            } else if (right instanceof ASMMemExpr mem) {\n                // Move the temp in mem (if exist) into reg2 cause temp is a stack location\n                // Move the tempSecond in mem (if exist) into reg3 cause temp is a stack location\n                ArrayList<ASMExpr> expressions = flattenMem(mem);\n                HashMap<String, String> tempToReg= new HashMap<>();\n                for (ASMExpr expr: expressions){\n                    if (expr instanceof ASMTempExpr temp){\n                        // get stack mapping for reg\n                        String curReg = availReg.get(availReg.size()-1);\n                        availReg.remove(availReg.size()-1);\n                        // add the move\n                        ASMMemExpr stackLoc = tempToStack(temp);\n                        ASMRegisterExpr usedReg = new ASMRegisterExpr(curReg);\n                        res.add(new ASMMov(usedReg,stackLoc));\n                        tempToReg.put(temp.getName(),curReg);\n                    }\n                }\n                ASMExpr tempMem = tempsToRegs(mem,tempToReg);\n                String curReg = availReg.get(availReg.size()-1);\n                availReg.remove(availReg.size()-1);\n                // add the move\n                ASMRegisterExpr usedReg = new ASMRegisterExpr(curReg);\n                res.add(new ASMMov(usedReg,tempMem));\n                curSrc = usedReg;\n            } else if (right instanceof ASMConstExpr num) {\n                // Need an extra move if number is greater or less than max/min int\n                curSrc = isIMMTooBig(num,res,availReg); // adds extra instruction\n                boolean isInt = num.getValue() <= Integer.MAX_VALUE && num.getValue() >= Integer.MIN_VALUE;\n                if (!isInt){\n                    opCodes = ASMOpCodes.MOV;\n                }\n            } else { // ASM Register\n                curSrc = right;\n            }\n        }else{ // left is reg\n            if (right instanceof ASMTempExpr temp) {\n                // get the stack location through mapping\n                String curReg = availReg.get(availReg.size()-1);\n                availReg.remove(availReg.size()-1);\n                // add the move\n                ASMMemExpr stackLoc = tempToStack(temp);\n                ASMRegisterExpr usedReg = new ASMRegisterExpr(curReg);\n                res.add(new ASMMov(usedReg,stackLoc));\n                curSrc = usedReg;\n                // Move temp into reg2 cause temp is a stack location\n                // use reg 2 for right\n            } else if (right instanceof ASMMemExpr mem) { // can leave right side as mem\n                ArrayList<ASMExpr> expressions = flattenMem(mem);\n                HashMap<String, String> tempToReg= new HashMap<>();\n                for (ASMExpr expr: expressions){\n                    if (expr instanceof ASMTempExpr temp){\n                        // get stack mapping for reg\n                        String curReg = availReg.get(availReg.size()-1);\n                        availReg.remove(availReg.size()-1);\n                        // add the move\n                        ASMMemExpr stackLoc = tempToStack(temp);\n                        ASMRegisterExpr usedReg = new ASMRegisterExpr(curReg);\n                        res.add(new ASMMov(usedReg,stackLoc));\n                        tempToReg.put(temp.getName(),curReg);\n                    }\n                }\n                curSrc = tempsToRegs(mem,tempToReg);\n                // Move the temp in mem (if exist) into reg2 cause temp is a stack location\n                // Move the tempSecond in mem (if exist) into reg3 cause temp is a stack location\n            } else if (right instanceof ASMConstExpr num) {\n                // Need an extra move if number is greater or less than max/min int\n                curSrc = isIMMTooBig(num,res,availReg);\n                boolean isInt = num.getValue() <= Integer.MAX_VALUE && num.getValue() >= Integer.MIN_VALUE;\n                if (!isInt){\n                    opCodes = ASMOpCodes.MOV;\n                }\n            } else { // ASM Register\n                curSrc = right;\n            }\n        }\n        ASMArg2 reBuild = new ASMArg2(opCodes, curDest, curSrc);\n        res.add(reBuild);\n        res.addAll(postInstruction);\n//        System.out.println(\"Before\");\n//        System.out.println(node);\n//        System.out.println(\"AFTER\");\n//        for (ASMInstruction instr: res){\n//            System.out.println(instr);\n//        }\n        return res;\n    }\n\n    // imul dest, v1, v2 // dest = v1 * v2;\n    @Override\n    public ArrayList<ASMInstruction> visit(ASMArg3 node) {\n\n        return null;\n    }\n\n    /**\n     * Creates a new Instruction Enter for the number of locations on the stack needed.\n     * @param instructions\n     * @return A new Enter Statement and the Register mapping\n     */\n    private ASMEnter createEnterAndBuildMapping(ArrayList<ASMInstruction> instructions){\n\n        HashSet<String> temps = functionToTemps.get(currentFunction);\n        for (ASMInstruction instr: instructions){\n            if (instr instanceof ASMArg1 arg1){\n                checkExprForTemp(arg1.getLeft(),temps);\n            }else if (instr instanceof  ASMArg2 arg2){\n                checkExprForTemp(arg2.getLeft(),temps);\n                checkExprForTemp(arg2.getRight(),temps);\n            }else if (instr instanceof ASMArg3 arg3){\n                checkExprForTemp(arg3.getA1(),temps);\n                checkExprForTemp(arg3.getA2(),temps);\n                checkExprForTemp(arg3.getA3(),temps);\n            }\n        }\n        long index = 1;\n        HashMap<String,Long> tempsToStack =  functionToTempsToStackOffset.get(currentFunction);\n        for (String temp: temps){\n            tempsToStack.put(temp,-8L*index);\n            index++;\n        }\n        return new ASMEnter(new ASMConstExpr(8L*temps.size()), new ASMConstExpr(0));\n    }\n\n\n    /**\n     * Check if Expression has any Temps\n     * @param expr checking if ASMexpr has temp\n     * @param temps returns the set of temps\n     */\n    private void checkExprForTemp(ASMExpr expr, HashSet<String> temps){\n        if (expr == null){\n            return;\n        }\n        if (expr instanceof ASMTempExpr temp){\n            temps.add(temp.getName());\n        }else if (expr instanceof ASMMemExpr mem){\n            ArrayList<ASMExpr> res = flattenMem(mem);\n            for (ASMExpr ex: res){\n                if (ex instanceof ASMTempExpr temp){\n                    temps.add(temp.getName());\n                }\n            }\n        }else if (expr instanceof ASMBinOpExpr binop){\n            ArrayList<ASMExpr> res = flattenBinop(binop);\n            for (ASMExpr ex: res){\n                if (ex instanceof ASMTempExpr temp){\n                    temps.add(temp.getName());\n                }\n            }\n        }\n\n    }\n\n\n    /**\n     * Returns a list of all the ASM expressions inside the memory operand.\n     * @param mem\n     * @return\n     */\n    private ArrayList<ASMExpr> flattenMem(ASMMemExpr mem){\n        ArrayList<ASMExpr> res = new ArrayList<>();\n        if (mem.getMem() instanceof ASMBinOpExpr binop){\n            res.addAll(flattenBinop(binop));\n        }else{\n            res.add(mem);\n        }\n        return res;\n    }\n    /**\n     * Returns a list of all the ASM expressions inside the binop in a list\n     * @param binop\n     * @return\n     */\n    private ArrayList<ASMExpr> flattenBinop(ASMBinOpExpr binop){\n        ArrayList<ASMExpr> res = new ArrayList<>();\n        if (binop.getLeft() instanceof ASMBinOpExpr leftBinop){\n            res.addAll(flattenBinop(leftBinop));\n        }else{\n            res.add(binop.getLeft());\n        }\n        if (binop.getRight() instanceof ASMBinOpExpr rightBinop){\n            res.addAll(flattenBinop(rightBinop));\n        }else{\n            res.add(binop.getRight());\n        }\n        return res;\n    }\n    /**\n     * Maps the Temporary to the corresponding stack location\n     * @param temp\n     * @return the stack location of the temporary\n     */\n    private ASMMemExpr tempToStack(ASMTempExpr temp){\n        long index = functionToTempsToStackOffset.get(currentFunction).get(temp.getName());\n\n        return new ASMMemExpr(new ASMBinOpAddExpr(\n                new ASMRegisterExpr(\"rbp\"),\n                new ASMConstExpr(index)));\n    }\n\n    /**\n     * Checks if the immediate is too big and will insert an extra move and a register to\n     * make sure instruction sequence is valid.\n     * @param cons the constant we are checking\n     * @param instructions the current instructions that are in the arrayList\n     * @param availRegs up to the three registers we can use for this instruction\n     * @return\n     */\n    private ASMExpr isIMMTooBig(ASMConstExpr cons, ArrayList<ASMInstruction> instructions, ArrayList<String> availRegs){\n\n        boolean isInt = cons.getValue() <= Integer.MAX_VALUE && cons.getValue() >= Integer.MIN_VALUE;\n        if (!isInt){\n            String usedReg = availRegs.get(availRegs.size()-1);\n            availRegs.remove(availRegs.size()-1);\n            ASMRegisterExpr reg = new ASMRegisterExpr(usedReg);\n            ASMMovabs extraMove = new ASMMovabs(reg,cons);\n            instructions.add(extraMove);\n            return reg;\n        }else{\n            return cons;\n        }\n        // returns either a reg or the imm\n    }\n\n    /**\n     * Replace the temporaries found in memory with real registers assuming already mapped\n     * @param expr\n     * @param tempMapping\n     * @return\n     */\n    private ASMExpr tempsToRegs(ASMExpr expr, HashMap<String,String> tempMapping){\n        if (expr instanceof ASMTempExpr temp){ // base case\n            return new ASMRegisterExpr(tempMapping.get(temp.getName()));\n        }else if (expr instanceof ASMMemExpr mem){\n            return new ASMMemExpr(tempsToRegs(mem.getMem(),tempMapping));\n        }else if (expr instanceof ASMBinOpMultExpr binopMult){\n            return new ASMBinOpMultExpr(tempsToRegs(binopMult.getLeft(),tempMapping),\n                    tempsToRegs(binopMult.getRight(),tempMapping));\n        }else if (expr instanceof ASMBinOpAddExpr binopAdd){\n            return new ASMBinOpAddExpr(tempsToRegs(binopAdd.getLeft(),tempMapping),\n                    tempsToRegs(binopAdd.getRight(),tempMapping));\n        }else{ // other base case\n            return expr;\n        }\n    }\n\n    /**\n     * Returns whether we need stack alignment or stack. Assumes We found number of temps required already\n     * @param calledFunction\n     * @return true if we need to insert stackalignment.\n     */\n    private boolean doWeNeedstackAlignment(String calledFunction) {\n\n        int tempCount = functionToTemps.get(currentFunction).size();\n\n\n        int paramCount = functionSignatures.get(calledFunction).part1();\n        int returnCount = functionSignatures.get(calledFunction).part2();\n        int returnSpace = Math.max(returnCount - 2, 0);\n        int argSpace = Math.max(paramCount - (returnCount > 2 ? 5 : 6), 0);\n        int stackSize = 1 + 1 + 3 + tempCount + returnSpace + argSpace;\n        // rip, rbp, r12, r13, r14\n//        System.out.println(returnSpace);\n//        System.out.println(argSpace);\n//        System.out.println(tempCount);\n        return (stackSize & 1) != 0;\n    }\n\n\n    /**\n     * Fixes all stack Alignment issues\n     * @param function\n     */\n\n    private ArrayList<ASMInstruction> fixAllStackAlignments(Map.Entry<String,ArrayList<ASMInstruction>> function) {\n        ArrayList<ASMInstruction> alignedFunction = new ArrayList<>(function.getValue());\n        for (int i = 0 ;i< alignedFunction.size();i++){\n            ASMInstruction instr = alignedFunction.get(i);\n            if (instr instanceof ASMComment comment && comment.getComment().equals(\"Add Padding\")){\n                if (doWeNeedstackAlignment(comment.getFunctionName())){\n                    alignedFunction.set(i,new ASMArg2(ASMOpCodes.SUB, new ASMRegisterExpr(\"rsp\"), new ASMConstExpr(8)));\n                    // find end\n                    int undoIndex = undoComment(alignedFunction,i+1);\n                    alignedFunction.set(undoIndex,new ASMArg2(ASMOpCodes.SUB, new ASMRegisterExpr(\"rsp\"), new ASMConstExpr(8)));\n                }\n            }\n        }\n        return alignedFunction;\n\n    }\n    private int undoComment(ArrayList<ASMInstruction> instructionsList, int startIndex){\n        for (int i = startIndex;i < instructionsList.size();i++){\n            ASMInstruction instr = instructionsList.get(i);\n            if (instr instanceof ASMComment comment && comment.getComment().equals(\"Undo Padding\")){\n                return i;\n            }\n        }\n        throw new InternalCompilerError(\"did align properly and replace undo\");\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/aar226_akc55_ayc62_ahl88/asm/visit/RegisterAllocationTrivialVisitor.java b/src/main/java/aar226_akc55_ayc62_ahl88/asm/visit/RegisterAllocationTrivialVisitor.java
--- a/src/main/java/aar226_akc55_ayc62_ahl88/asm/visit/RegisterAllocationTrivialVisitor.java	(revision ebbd6ae1200b2de737d9dcf89c251a5f43dedfc2)
+++ b/src/main/java/aar226_akc55_ayc62_ahl88/asm/visit/RegisterAllocationTrivialVisitor.java	(date 1681162001825)
@@ -4,6 +4,7 @@
 import aar226_akc55_ayc62_ahl88.asm.ASMOpCodes;
 import aar226_akc55_ayc62_ahl88.asm.Expressions.*;
 import aar226_akc55_ayc62_ahl88.asm.Instructions.*;
+import aar226_akc55_ayc62_ahl88.asm.Instructions.arithmetic.ASMIMul;
 import aar226_akc55_ayc62_ahl88.asm.Instructions.mov.ASMMov;
 import aar226_akc55_ayc62_ahl88.asm.Instructions.mov.ASMMovabs;
 import aar226_akc55_ayc62_ahl88.asm.Instructions.stackops.ASMPop;
@@ -42,9 +43,10 @@
             ArrayList<ASMInstruction> functionResult = new ArrayList<>();
             for (ASMInstruction instr: updatedInstructions){
                 if (!(instr instanceof ASMEnter oldEnter)) {
+                    System.out.println(instr);
                     functionResult.addAll(instr.accept(this));
                 }else{
-                    System.out.println("oldEnter: "+ oldEnter + " newEnter: " + newEnter);
+//                    System.out.println("oldEnter: "+ oldEnter + " newEnter: " + newEnter);
                     functionResult.add(newEnter);
                     functionResult.add(new ASMPush(new ASMRegisterExpr("r12")));
                     functionResult.add(new ASMPush(new ASMRegisterExpr("r13")));
@@ -197,7 +199,7 @@
 
         // need intermediate steps cause both can't be mem
         // need extra reg
-        if (!(left instanceof ASMMemExpr)){ // left is mem
+        if ((left instanceof ASMMemExpr)){ // left is mem
             if (right instanceof ASMTempExpr temp) {
                 // Move temp into reg2 cause temp is a stack location
                 String curReg = availReg.get(availReg.size()-1);
@@ -298,8 +300,80 @@
     // imul dest, v1, v2 // dest = v1 * v2;
     @Override
     public ArrayList<ASMInstruction> visit(ASMArg3 node) {
+        if (node.getOpCode() != ASMOpCodes.IMUL){
+            throw new InternalCompilerError("3 ARG NOT IMUL");
+        }
+        ArrayList<String> availReg = new ArrayList<>(Arrays.asList("r12", "r13","r14"));
+//        String leftReg = availReg.get(availReg.size()-1);
+//        availReg.remove(availReg.size()-1);
+        ASMExpr left = node.getA1();
+        ASMExpr mid = node.getA2();
+        ASMExpr right = node.getA3();
+        ArrayList<ASMInstruction> res = new ArrayList<>();
+        ArrayList<ASMInstruction> postInstruction = new ArrayList<>();
+        ASMExpr curDest= null; // replace Left with curDest
+        ASMExpr curMiddle = null;  // replace Middle with curSrc
+        ASMExpr curRight = null;  // replace Right with curSrc
+        if (node.getA2() == null && node.getA3() == null){
+            throw new InternalCompilerError("1 ARGS TODO");
+        }else if (node.getA3() == null){
+            if (left instanceof ASMRegisterExpr reg){ // known register Return
+                curDest = left;
+                availReg.remove(reg.getRegisterName());
+            }else if (left instanceof ASMTempExpr temp){ // Move left into Reg1 cause left is a stack location
+                // get the stack location through mapping
+                String curReg = availReg.get(availReg.size()-1);
+                availReg.remove(availReg.size()-1);
+                // add the move
+                ASMMemExpr stackLoc = tempToStack(temp);
+                ASMRegisterExpr usedReg = new ASMRegisterExpr(curReg);
+                res.add(new ASMMov(usedReg,stackLoc));
+                postInstruction.add(new ASMMov(stackLoc,usedReg));
+                curDest = usedReg;
+            }else{
+                throw new InternalCompilerError("nothing else should be left for IMUL on the top level");
+            }
+            if (right instanceof ASMTempExpr temp) {
+                // get the stack location through mapping
+                String curReg = availReg.get(availReg.size()-1);
+                availReg.remove(availReg.size()-1);
+                // add the move
+                ASMMemExpr stackLoc = tempToStack(temp);
+                ASMRegisterExpr usedReg = new ASMRegisterExpr(curReg);
+                res.add(new ASMMov(usedReg,stackLoc));
+                curMiddle = usedReg;
+                // Move temp into reg2 cause temp is a stack location
+                // use reg 2 for right
+            } else if (right instanceof ASMMemExpr mem) { // can leave right side as mem
+                ArrayList<ASMExpr> expressions = flattenMem(mem);
+                HashMap<String, String> tempToReg= new HashMap<>();
+                for (ASMExpr expr: expressions){
+                    if (expr instanceof ASMTempExpr temp){
+                        // get stack mapping for reg
+                        String curReg = availReg.get(availReg.size()-1);
+                        availReg.remove(availReg.size()-1);
+                        // add the move
+                        ASMMemExpr stackLoc = tempToStack(temp);
+                        ASMRegisterExpr usedReg = new ASMRegisterExpr(curReg);
+                        res.add(new ASMMov(usedReg,stackLoc));
+                        tempToReg.put(temp.getName(),curReg);
+                    }
+                }
+                curMiddle = tempsToRegs(mem,tempToReg);
+                // Move the temp in mem (if exist) into reg2 cause temp is a stack location
+                // Move the tempSecond in mem (if exist) into reg3 cause temp is a stack location
+            } else if (right instanceof ASMConstExpr num) {
+                throw new InternalCompilerError("IMUL cant have immediate as second");
+            } else { // ASM Register
+                curMiddle = right;
+            }
 
-        return null;
+        }else{
+            throw new InternalCompilerError("THREE ARGS TODO");
+        }
+        res.add(new ASMIMul(curDest, curMiddle,curRight));
+        res.addAll(postInstruction);
+        return res;
     }
 
     /**
Index: src/main/java/aar226_akc55_ayc62_ahl88/asm/Instructions/arithmetic/ASMIMul.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package aar226_akc55_ayc62_ahl88.asm.Instructions.arithmetic;\n\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.ASMArg3;\nimport aar226_akc55_ayc62_ahl88.asm.Expressions.ASMExpr;\nimport aar226_akc55_ayc62_ahl88.asm.ASMOpCodes;\n\npublic class ASMIMul extends ASMArg3 {\n\n    // dest = v1 * v2\n    public ASMIMul(ASMExpr dest, ASMExpr v1, ASMExpr v2) {\n        super(ASMOpCodes.IMUL, dest, v1, v2);\n    }\n\n    // dest = dest * src\n    public ASMIMul(ASMExpr dest, ASMExpr src) {\n        super(ASMOpCodes.IMUL, dest, dest, src);\n    }\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/aar226_akc55_ayc62_ahl88/asm/Instructions/arithmetic/ASMIMul.java b/src/main/java/aar226_akc55_ayc62_ahl88/asm/Instructions/arithmetic/ASMIMul.java
--- a/src/main/java/aar226_akc55_ayc62_ahl88/asm/Instructions/arithmetic/ASMIMul.java	(revision ebbd6ae1200b2de737d9dcf89c251a5f43dedfc2)
+++ b/src/main/java/aar226_akc55_ayc62_ahl88/asm/Instructions/arithmetic/ASMIMul.java	(date 1681161157757)
@@ -16,4 +16,16 @@
         super(ASMOpCodes.IMUL, dest, dest, src);
     }
 
+    @Override
+    public String toString(){
+        if (getA2() == null && getA3() == null){
+            return opCodeToString() + getA1();
+        }else if (getA3() == null){
+            return opCodeToString() + getA1()+ ", "+getA2();
+        }else{
+            return opCodeToString() + getA1()+ ", "+getA2() + ", "+getA3();
+        }
+    }
+
+
 }
Index: tests/pa5Eth/conv.eti
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/tests/pa5Eth/conv.eti b/tests/pa5Eth/conv.eti
new file mode 100644
--- /dev/null	(date 1681159260929)
+++ b/tests/pa5Eth/conv.eti	(date 1681159260929)
@@ -0,0 +1,9 @@
+// String conversion functions
+
+// If "str" contains a sequence of ASCII characters that correctly represent
+// an integer constant n, return (n, true). Otherwise return (0, false).
+parseInt(str: int[]): int, bool
+
+// Return a sequence of ASCII characters representing the
+// integer n.
+unparseInt(n: int): int[]
Index: tests/pa5Eth/ex01.eta
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/tests/pa5Eth/ex01.eta b/tests/pa5Eth/ex01.eta
new file mode 100644
--- /dev/null	(date 1681159260915)
+++ b/tests/pa5Eth/ex01.eta	(date 1681159260915)
@@ -0,0 +1,7 @@
+use io
+
+main(args: int[][]) {
+  print("Hello, Worl\x{64}!\n")
+  c3po: int = 'x' + 47;
+  r2d2: int = c3po // No Han Solo
+}
Index: tests/pa5Eth/io.eti
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/tests/pa5Eth/io.eti b/tests/pa5Eth/io.eti
new file mode 100644
--- /dev/null	(date 1681159260920)
+++ b/tests/pa5Eth/io.eti	(date 1681159260920)
@@ -0,0 +1,8 @@
+// I/O support
+
+print(str: int[])     // Print a string to standard output.
+println(str: int[])   // Print a string to standard output, followed by a newline.
+readln() : int[]      // Read from standard input until a newline.
+getchar() : int       // Read a single character from standard input.
+                      // Returns -1 if the end of input has been reached.
+eof() : bool          // Test for end of file on standard input.
