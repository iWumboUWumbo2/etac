Index: src/main/java/aar226_akc55_ayc62_ahl88/src/edu/cornell/cs/cs4120/xic/ir/visit/AbstractASMVisitor.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package aar226_akc55_ayc62_ahl88.src.edu.cornell.cs.cs4120.xic.ir.visit;\n\nimport aar226_akc55_ayc62_ahl88.asm.*;\nimport aar226_akc55_ayc62_ahl88.asm.Expressions.*;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.ASMArg2;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.ASMComment;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.ASMInstruction;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.ASMLabel;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.arithmetic.*;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.bitwise.*;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.jumps.*;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.mov.ASMMov;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.mov.ASMMovabs;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.stackops.ASMPop;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.stackops.ASMPush;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.subroutine.ASMCall;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.subroutine.ASMEnter;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.subroutine.ASMLeave;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.subroutine.ASMRet;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.tstcmp.*;\nimport aar226_akc55_ayc62_ahl88.src.edu.cornell.cs.cs4120.xic.ir.*;\nimport aar226_akc55_ayc62_ahl88.src.polyglot.util.InternalCompilerError;\nimport aar226_akc55_ayc62_ahl88.src.polyglot.util.Pair;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\n\n/**\n * NOTES:\n * - branches: use cmp then corresponding jump\n * - multireturn: store first argument in rax, push rest on stack\n * - function args: rdi, rsi, rdx, rcx, r8, r9, push rest on stack\n * - callee saved: rbx, rbp, and r12â€“r15\n * - caller saved: everything else\n * THINGS WE NEEEEEEEEEEEDDDDDDDDD\n * - ir compunit ->\n *      add glob mem locations\n *      call visit to all functions\n * - ir func decl ->\n *      create new label at the top for function name\n *      follow abi for args and register alloc\n *      call visit on each statement\n *      flatten arraylist we get back\n *      follow abi for correct func exit\n * - jump -> jr <label name>\n * - cjump ->\n *      two args: cmp <t1> <t2>; j<flag> <label name>\n *      if instance of IRConst and is boolliteral: true -> jr / false -> nothing\n * - move ->\n *      mooooooooooooove\n *      contains expr: used for dynamic tiling\n *      tiling\n * - mem\n * - binop\n * - call stmt ->\n *      init function call follow abi for function call (store func args correctly)\n *      jump to function\n *      clean accroding to ABI spec (be careful about multireturns and stack dead space)\n *      pop from function\n * - IR Label -> ASM label\n * Generic ASM Class will be called ASMNode\n */\n\npublic class AbstractASMVisitor {\n    private int tempCnt = 0;\n\n    private final HashMap<String, Pair<Integer,Integer>> functionsNameToSig = new HashMap<>();\n\n    private String nxtTemp() {\n        return String.format(\"_ASMReg_t%d\", (tempCnt++));\n    }\n\n    public ArrayList<ASMInstruction> visit(IRData node){\n        throw new InternalCompilerError(\"not visiting IRDATA\");\n    }\n\n    public ASMInstruction binopCondToOpCode(IRBinOp bin,IRCJump node){\n        ASMNameExpr label = new ASMNameExpr(node.trueLabel());\n        return switch (bin.opType()){\n            case EQ -> new ASMJumpEqual(label);\n            case NEQ -> new ASMJumpNotEqual(label);\n            case LT -> new ASMJumpLT(label);\n            case ULT -> new ASMJumpULT(label);\n            case GT -> new ASMJumpGT(label);\n            case LEQ -> new ASMJumpLE(label);\n            case GEQ -> new ASMJumpGE(label);\n            default -> throw new InternalCompilerError(\"binop Cond is not boolean it is: \" + bin);\n        };\n    }\n    public ArrayList<ASMInstruction> visit(IRCJump node) {\n        ArrayList<ASMInstruction> instructions = new ArrayList<>();\n\n        IRExpr condition = node.cond();\n\n        if (condition instanceof IRBinOp c) { // maybe test is faster\n            // create function for IRBINOP\n            // DO A CMP instead\n            if (c.opType() == IRBinOp.OpType.XOR){ //fix this shit\n                ASMAbstractReg tleft = munchIRExpr(c.left());\n                ASMAbstractReg tright = munchIRExpr(c.right());\n                ASMTempExpr destTemp = new ASMTempExpr(nxtTemp());\n                if (c.left() instanceof IRConst cons){\n                    instructions.addAll(c.right().getBestInstructions());\n                    instructions.add(new ASMMov(destTemp,tright));\n                    instructions.add(new ASMXor(destTemp,new ASMConstExpr(cons.value())));\n                }else if (c.right() instanceof  IRConst cons){\n                    instructions.addAll(c.left().getBestInstructions());\n                    instructions.add(new ASMMov(destTemp,tleft));\n                    instructions.add(new ASMXor(destTemp,new ASMConstExpr(cons.value())));\n                }else{\n                    instructions.addAll(c.left().getBestInstructions());\n                    instructions.addAll(c.right().getBestInstructions());\n                    instructions.add(new ASMMov(destTemp,tleft));\n                    instructions.add(new ASMXor(destTemp,tright));\n                }\n                instructions.add(new ASMTest(destTemp,destTemp));\n                instructions.add(new ASMJumpNotEqual(new ASMNameExpr(node.trueLabel())));\n            }else {\n                ASMAbstractReg tleft = munchIRExpr(c.left());\n                ASMAbstractReg tright = munchIRExpr(c.right());\n                instructions.addAll(c.left().getBestInstructions()); // instrs to create left temp\n                instructions.addAll(c.right().getBestInstructions()); // instrs to create right temp\n                instructions.add(new ASMCmp(tleft, tright)); // cmp\n                instructions.add(binopCondToOpCode(c, node));\n            }\n        } else if (condition instanceof IRConst c) {\n            if (c.value() != 0L){ // jump\n                instructions.add(new ASMJumpAlways(new ASMNameExpr(node.trueLabel())));\n            }\n        } else if (condition instanceof IRTemp c) {\n//            functionToTemps.get(curFunction).add(c.name());\n            ASMTempExpr tempName = new ASMTempExpr(c.name());\n            instructions.add(new ASMTest(tempName,tempName));\n            instructions.add(new ASMJumpNotEqual(new ASMNameExpr(node.trueLabel())));\n            //test t, t\n            //jnz l\n        } else if (condition instanceof IRMem c) {\n            ASMAbstractReg tempMem = munchIRExpr(c);\n            instructions.addAll(c.getBestInstructions());\n            instructions.add(new ASMTest(tempMem,tempMem));\n            instructions.add(new ASMJumpNotEqual(new ASMNameExpr(node.trueLabel())));\n            // do temp test and ASM Jump no Equal\n        }else{\n            throw new InternalCompilerError(\"CJUMP guard has another type\");\n        }\n        return instructions;\n    }\n    public ASMCompUnit visit(IRCompUnit node) {\n        HashSet<ASMData> globals = new HashSet<>();\n        HashMap<String, ArrayList<ASMInstruction>> functionToInstructionList = new HashMap<>();\n        HashMap<String, HashSet<String>> functionToTempsMapping = new HashMap<>();\n        for (IRData data : node.dataMap().values()) {\n            ASMLabel data_label = new ASMLabel(data.name());\n            ASMData data_instr = new ASMData(data_label, data.data());\n            globals.add(data_instr);\n            // add to ASMCOMP UNIT GLOBAL\n        }\n\n        for (IRFuncDecl func : node.functions().values()) {\n            String curFunction = func.name();\n//            functionToTemps.put(func.name(),new HashSet<>());\n            ArrayList<ASMInstruction> functionInstructions = visit(func);\n//            functionToTempsMapping.put(curFunction,functionToTemps.get(curFunction));\n            functionToInstructionList.put(curFunction,functionInstructions);\n//            replaceTemps(functionInstructions,curFunction);\n//            instructions.addAll(functionInstructions);\n        }\n\n        return new ASMCompUnit(globals,functionToInstructionList,functionToTempsMapping,functionsNameToSig);\n    }\n    public ArrayList<ASMInstruction> visit (IRConst x) {\n        ArrayList<ASMInstruction> instructions = new ArrayList<>();\n        boolean isInt = x.value() <= Integer.MAX_VALUE && x.value() >= Integer.MIN_VALUE;\n        ASMArg2 instruction = (isInt) ? new ASMMov(new ASMTempExpr(nxtTemp()),new ASMConstExpr(x.value()))\n                : new ASMMovabs(new ASMTempExpr(nxtTemp()),new ASMConstExpr(x.value()));\n        instructions.add(instruction);\n        return instructions;\n    }\n    public ArrayList<ASMInstruction> visit(IRFuncDecl node) {\n        ArrayList<ASMInstruction> result = new ArrayList<>();\n\n        // create new Starting label for this Function\n        result.add(new ASMLabel(node.name()));\n\n//        enter at Botoom\n//        push rbp\n//        mov rbp rsp\n//        sub rsp, 8*l\n//        result.add(new ASMPush(new ASMRegisterExpr(\"rbp\")));\n//        result.add(new ASMMov(new ASMRegisterExpr(\"rbp\"),new ASMRegisterExpr(\"rsp\")));\n\n        // need to calculate number of temporaries used\n\n        ArrayList<String> temps = new ArrayList<>();\n        // foo(1,2,3,4,5,6,7....) -> rdi, rsi, rdx, rcx, r8, r9, stack\n        int numParams = node.functionSig.inputTypes.size();\n        int numReturns = node.functionSig.outputTypes.size();\n        IRSeq body = (IRSeq) node.body();\n        for (int i = 0; i< numParams;i++){\n            IRMove nameAndArg = (IRMove) body.stmts().get(i);\n            IRTemp name = (IRTemp) nameAndArg.target();\n            temps.add(name.name());\n        }\n        ArrayList<ASMInstruction> bodyInstructions = new ArrayList<>();\n\n        if (numReturns > 2){\n//            functionToTemps.get(curFunction).add(\"_returnBase\");\n            bodyInstructions.add(new ASMMov(\n                    new ASMTempExpr(\"_returnBase\"),\n                    new ASMRegisterExpr(\"rdi\")\n            ));\n        }\n\n        int start = numReturns > 2 ? 2: 1;\n        int end   = numReturns > 2 ? numParams +1: numParams;\n        for (int i = start; i<=end;i++){\n\n            // Move arg into argI. argI <- RDI\n            ASMExpr ARGI = switch (i) {\n                case 1 -> new ASMRegisterExpr(\"rdi\");\n                case 2 -> new ASMRegisterExpr(\"rsi\");\n                case 3 -> new ASMRegisterExpr(\"rdx\");\n                case 4 -> new ASMRegisterExpr(\"rcx\");\n                case 5 -> new ASMRegisterExpr(\"r8\");\n                case 6 -> new ASMRegisterExpr(\"r9\");\n                default ->\n                        new ASMMemExpr(\n                                new ASMBinOpAddExpr(\n                                        new ASMRegisterExpr(\"rbp\"),\n                                        new ASMConstExpr(8L * (i - 7 + 2))));\n            };\n//            String tempName = \"_ARG\" + i;\n            String tempName = numReturns > 2 ? temps.get(i-2):temps.get(i-1);\n//            functionToTemps.get(curFunction).add(tempName);\n            // can't do [stack location] <- [stack location2]\n            // need intermediate rax <- [stack location2]\n            // then [stack location] <- temp rax\n            bodyInstructions.add(new ASMMov(new ASMTempExpr(tempName),ARGI));\n        }\n        if (node.body() instanceof  IRSeq seq){\n            for (int i = numParams;i< seq.stmts().size();i++){\n                IRStmt stmt = seq.stmts().get(i);\n                bodyInstructions.addAll(stmt.accept(this));\n            }\n        }else{\n            throw new InternalCompilerError(\"body isn't a seq\");\n        }\n        // add enter at begin.\n        // enter 8*L, 0\n//        ASMEnter begin = new ASMEnter(new ASMConstExpr(8L*functionToTemps.get(curFunction).size()),new ASMConstExpr(0));\n        ASMEnter begin = new ASMEnter(new ASMConstExpr(0),new ASMConstExpr(0));\n        result.add(begin);\n        result.addAll(bodyInstructions);\n        return result;\n    }\n    public ArrayList<ASMInstruction> visit(IRJump jump) {\n        ArrayList<ASMInstruction> instructions = new ArrayList<>();\n        if (jump.target() instanceof IRName name) {\n            instructions.add(new ASMJumpAlways(new ASMNameExpr(name.name())));\n        }\n        return instructions;\n    }\n    public ArrayList<ASMInstruction> visit(IRLabel node) {\n        ArrayList<ASMInstruction> instructions = new ArrayList<>();\n        instructions.add(new ASMLabel(node.name()));\n        return instructions;\n    }\n    // Always use these three rax, rcx, and rdx\n    public ArrayList<ASMInstruction> visit(IRMove node){\n        IRExpr dest = node.target();\n        IRExpr source = node.source();\n        ArrayList<ASMInstruction> instructions = new ArrayList<>();\n\n        // TEMP TEMP\n        if (dest instanceof IRTemp t1 && source instanceof IRTemp t2) { // random case for testing atm\n            tileTempTemp(t1, t2, instructions);\n        // TEMP CONST\n        } else if (dest instanceof IRTemp t && source instanceof IRConst x) {\n            tileTempConst(t, x, instructions);\n        // TEMP MEM\n        } else if (dest instanceof IRTemp t && source instanceof IRMem m) {\n            tileTempMem(t, m, instructions);\n        // TEMP BINOP\n        } else if (dest instanceof IRTemp t && source instanceof IRBinOp b) {\n            tileTempBinop(t, b, instructions);\n        // MEM TEMP\n        } else if (dest instanceof IRMem m && source instanceof IRTemp t) {\n            tileMemTemp(m, t, instructions);\n        // MEM MEM\n        } else if (dest instanceof IRMem m1 && source instanceof IRMem m2) {\n            tileMemMem(m1, m2, instructions);\n        // MEM CONST\n        } else if (dest instanceof IRMem m && source instanceof IRConst x) {\n            tileMemConst(m, x, instructions);\n        // MEM BINOP\n        } else if (dest instanceof IRMem m && source instanceof IRBinOp b) {\n            tileMemBinop(m, b, instructions);\n        }\n        else {\n            System.out.println(node);\n            throw new InternalCompilerError(\"TODO Other moves\");\n        }\n//        System.out.println(\"before IRSTMT: \");\n//        System.out.println(node);\n//        System.out.println(\"After IRSTMT: \");\n//        for (ASMInstruction instrs: instructions){\n//            System.out.println(instrs);\n//        }\n        return instructions;\n    }\n\n    // Base Case\n    public long tileTempTemp(IRTemp t1, IRTemp t2, ArrayList<ASMInstruction> instrs) {\n        instrs.add(new ASMMov(new ASMTempExpr(t1.name()), new ASMTempExpr(t2.name())));\n        return 1;\n    }\n\n    // Base Case\n    public long tileTempConst(IRTemp t, IRConst c, ArrayList<ASMInstruction> instrs) {\n        instrs.add(new ASMMov(new ASMTempExpr(t.name()), new ASMConstExpr(c.value())));\n        return 1;\n    }\n\n    // Can Expand\n    public long tileTempMem(IRTemp t, IRMem m, ArrayList<ASMInstruction> instrs) {\n        long curBestCost = Long.MAX_VALUE;\n        ArrayList<ASMInstruction> curBestInstructions = new ArrayList<>();\n        ASMAbstractReg temp = munchIRExpr(m);\n        if (false){ // other patterns;\n\n        }else { // catch all case\n            if (m.getBestCost() + 1 < curBestCost){\n                ArrayList<ASMInstruction> caseInstructions = new ArrayList<>(m.expr().getBestInstructions()); // instructions for Mem\n                caseInstructions.add(new ASMMov(new ASMTempExpr(t.name()), new ASMMemExpr(m.expr().getAbstractReg()))); // move the temp mem into ASMMOV\n                curBestInstructions = caseInstructions;\n                curBestCost = m.getBestCost() + 1;\n            }\n        }\n        instrs.addAll(curBestInstructions);\n        return curBestCost;\n    }\n\n    // Can Expand\n    public long tileTempBinop(IRTemp t, IRBinOp b, ArrayList<ASMInstruction> instrs) {\n        long curBestCost = Long.MAX_VALUE;\n        ArrayList<ASMInstruction> curBestInstructions = new ArrayList<>();\n        ASMAbstractReg tempTemp = munchIRExpr(t);\n        ASMAbstractReg binopTemp = munchIRExpr(b);\n        if (b.left() instanceof IRTemp tleft && twoOpArith(b) && (t.toString().equals(tleft.toString()))) { // move a (a+tLeft)\n            if (b.left().getBestCost() + 1 < curBestCost) {\n                ArrayList<ASMInstruction> caseInstructions = new ArrayList<>(b.left().getBestInstructions());\n                caseInstructions.add(new ASMArg2(irOpToASMOp(b), new ASMTempExpr(t.name()), b.right().getAbstractReg()));\n                curBestInstructions = caseInstructions;\n                curBestCost = b.left().getBestCost() + 1;\n            }\n        }\n        if (b.opType() == IRBinOp.OpType.ADD){\n            // lea t1 [t2 + t3]\n            if (b.left().getBestCost() + b.right().getBestCost() + 1 < curBestCost){\n                ArrayList<ASMInstruction> caseInstructions = new ArrayList<>(b.left().getBestInstructions());\n                caseInstructions.addAll(b.right().getBestInstructions());\n                caseInstructions.add(new ASMLEA(tempTemp,new ASMMemExpr(new ASMBinOpAddExpr(b.left().getAbstractReg(),b.right().getAbstractReg())))); // lea t1 [t2 + t3]\n                curBestInstructions = caseInstructions;\n                curBestCost = b.left().getBestCost() + b.right().getBestCost() + 1;\n            }\n            // lea t1 [5 + t2]\n            if (b.left() instanceof IRConst c){\n                if (b.right().getBestCost() + 1 < curBestCost) {\n                    ArrayList<ASMInstruction> caseInstructions = new ArrayList<>(b.right().getBestInstructions());\n                    caseInstructions.add(new ASMLEA(tempTemp,new ASMMemExpr(new ASMBinOpAddExpr(new ASMConstExpr(c.value()),b.right().getAbstractReg()))));\n                    curBestInstructions = caseInstructions;\n                    curBestCost = b.right().getBestCost() + 1;\n                }\n            }\n            // lea t1 [t2 + 5]\n            if (b.right() instanceof IRConst c){\n                if (b.left().getBestCost() + 1 < curBestCost) {\n                    ArrayList<ASMInstruction> caseInstructions = new ArrayList<>(b.left().getBestInstructions());\n                    caseInstructions.add(new ASMLEA(tempTemp,new ASMMemExpr(new ASMBinOpAddExpr(b.left().getAbstractReg(),new ASMConstExpr(c.value())))));\n                    curBestInstructions = caseInstructions;\n                    curBestCost = b.right().getBestCost() + 1;\n                }\n            }\n        }\n\n        if (false){ // other patterns;\n\n        }else { // catch all case\n            if (b.getBestCost() + 1 < curBestCost){\n                ArrayList<ASMInstruction> caseInstructions = new ArrayList<>(b.getBestInstructions()); // instructions for Mem\n                caseInstructions.add(new ASMMov(new ASMTempExpr(t.name()), binopTemp)); // move the temp mem into ASMMOV\n                curBestInstructions = caseInstructions;\n                curBestCost = b.getBestCost() + 1;\n            }\n        }\n        instrs.addAll(curBestInstructions);\n        return curBestCost;\n    }\n\n    // Can Expand\n    public long tileMemTemp(IRMem m, IRTemp t, ArrayList<ASMInstruction> instrs) {\n        long curBestCost = Long.MAX_VALUE;\n        ArrayList<ASMInstruction> curBestInstructions = new ArrayList<>();\n        ASMAbstractReg temp = munchIRExpr(m); // side effects\n        if (false){ // other patterns;\n\n        }else { // catch all case\n            if (m.getBestCost() + 1 < curBestCost){\n                ArrayList<ASMInstruction> caseInstructions = new ArrayList<>(m.expr().getBestInstructions()); // instructions for Mem\n                caseInstructions.add(new ASMMov( new ASMMemExpr(m.expr().getAbstractReg()),new ASMTempExpr(t.name()))); // move the temp mem into ASMMOV\n                curBestInstructions = caseInstructions;\n                curBestCost = m.getBestCost() + 1;\n            }\n        }\n        instrs.addAll(curBestInstructions);\n        return curBestCost;\n    }\n    // Can Expand\n    public long tileMemMem(IRMem m1, IRMem m2, ArrayList<ASMInstruction> instrs) {\n        long curBestCost = Long.MAX_VALUE;\n        ArrayList<ASMInstruction> curBestInstructions = new ArrayList<>();\n        ASMAbstractReg leftTemp = munchIRExpr(m1);\n        ASMAbstractReg rightTemp = munchIRExpr(m2);\n        if (false){ // other patterns;\n\n        }else { // catch all case do right mem then left mem\n            if (m2.getBestCost() + m1.getBestCost() +  1 < curBestCost){\n                ArrayList<ASMInstruction> caseInstructions = new ArrayList<>(); // instructions for Mem\n                caseInstructions.addAll(m2.expr().getBestInstructions());\n                caseInstructions.addAll(m1.expr().getBestInstructions());\n                caseInstructions.add(new ASMMov(new ASMMemExpr(m1.expr().getAbstractReg()), new ASMMemExpr(m2.expr().getAbstractReg()))); // move the temp mem into ASMMOV\n                curBestInstructions = caseInstructions;\n                curBestCost = m2.getBestCost() + m1.getBestCost() +  1;\n            }\n        }\n        instrs.addAll(curBestInstructions);\n        return curBestCost;\n    }\n    // Can Expand\n    public long tileMemConst(IRMem m, IRConst c, ArrayList<ASMInstruction> instrs) {\n        long curBestCost = Long.MAX_VALUE;\n        ArrayList<ASMInstruction> curBestInstructions = new ArrayList<>();\n        ASMAbstractReg temp = munchIRExpr(m);\n        if (false){ // other patterns;\n\n        }else { // catch all case\n            if (m.getBestCost() + 1 < curBestCost){\n                ArrayList<ASMInstruction> caseInstructions = new ArrayList<>(m.expr().getBestInstructions()); // instructions for Mem\n                caseInstructions.add(new ASMMov(new ASMMemExpr(m.expr().getAbstractReg()), new ASMConstExpr(c.value()))); // move the temp mem into ASMMOV\n                curBestInstructions = caseInstructions;\n                curBestCost = m.getBestCost() + 1;\n            }\n        }\n        instrs.addAll(curBestInstructions);\n        return curBestCost;\n    }\n    // Can Expand\n    public long tileMemBinop(IRMem m, IRBinOp b, ArrayList<ASMInstruction> instrs) {\n        long curBestCost = Long.MAX_VALUE;\n        ArrayList<ASMInstruction> curBestInstructions = new ArrayList<>();\n        ASMAbstractReg temp1 = munchIRExpr(m);\n        ASMAbstractReg temp2 = munchIRExpr(b);\n        if (false){ // other patterns;\n\n        }else { // catch all case\n            if (m.getBestCost() + b.getBestCost() + 1 < curBestCost){\n                ArrayList<ASMInstruction> caseInstructions = new ArrayList<>(); // instructions for Mem\n                caseInstructions.addAll(b.getBestInstructions());\n                caseInstructions.addAll(m.expr().getBestInstructions());\n                caseInstructions.add(new ASMMov(new ASMMemExpr(m.expr().getAbstractReg()), temp2)); // move the temp mem into ASMMOV\n                curBestInstructions = caseInstructions;\n                curBestCost = m.getBestCost() + 1;\n            }\n        }\n        instrs.addAll(curBestInstructions);\n        return curBestCost;\n    }\n\n    public long tileMemName(IRMem m, IRName n, ArrayList<ASMInstruction> instrs) {\n        return 0;\n    }\n\n    private ASMAbstractReg munchIRExpr(IRExpr e) {\n        IRNode_c top = (IRNode_c) e;\n        if (top.visited){\n//            System.out.println(\"visited\");\n            return top.tempName;\n        }\n        if (e instanceof IRBinOp binop) {\n            return munchBinop(binop);\n        }else if (e instanceof IRTemp t){\n            return munchTemp(t);\n        }else if (e instanceof IRConst cons){\n            return munchIRConst(cons);\n        }else if (e instanceof IRName name){ // cheese way of doing it\n            return munchIRName(name);\n        }else if (e instanceof IRMem mem){\n            return munchIRMem(mem);\n        }else{\n            throw new InternalCompilerError(\"TODO EXPR not tested\");\n        }\n    }\n    private ASMNameExpr munchIRName(IRName name) {\n        name.visited = true;\n        name.bestCost = 0;\n        name.bestInstructions = new ArrayList<>();\n        ASMNameExpr res = new ASMNameExpr(name.name());\n        name.tempName = res;\n        return res;\n    }\n    private ASMTempExpr munchIRMem(IRMem mem) {\n        long curBestCost = Long.MAX_VALUE;\n        ArrayList<ASMInstruction> curBestInstructions = new ArrayList<>();\n        ASMTempExpr destTemp = new ASMTempExpr(nxtTemp());\n        ASMAbstractReg munched = munchIRExpr(mem.expr());\n\n        if (mem.expr() instanceof IRName name){ // other patterns;\n            if (mem.expr().getBestCost() + 1 < curBestCost){\n                ArrayList<ASMInstruction> caseInstructions = new ArrayList<>(mem.expr().getBestInstructions()); // instructions for Mem\n                caseInstructions.add(new ASMMov(destTemp, new ASMMemExpr(new ASMNameExpr(name.name()))));\n                curBestInstructions = caseInstructions;\n                curBestCost = mem.expr().getBestCost() + 1;\n            }\n        } else { // catch all case\n            if (mem.expr().getBestCost() + 1 < curBestCost){\n                ArrayList<ASMInstruction> caseInstructions = new ArrayList<>(mem.expr().getBestInstructions()); // instructions for Mem\n                caseInstructions.add(new ASMMov(destTemp,new ASMMemExpr(munched)));\n                curBestInstructions = caseInstructions;\n                curBestCost = mem.expr().getBestCost() + 1;\n            }\n        }\n        mem.visited = true;\n        mem.bestCost = curBestCost;\n        mem.bestInstructions = curBestInstructions;\n        mem.tempName = destTemp;\n        return destTemp;\n//        return null;\n    }\n    private ASMTempExpr munchTemp(IRTemp temp) {\n        temp.visited = true;\n        temp.bestCost = 0;\n        temp.bestInstructions = new ArrayList<>();\n        ASMTempExpr res = new ASMTempExpr(temp.name());\n        temp.tempName = res;\n        return res;\n    }\n    private ASMTempExpr munchIRConst(IRConst c){\n        c.visited = true;\n        c.bestCost = 1;\n        String extraTemp = nxtTemp();\n        ArrayList<ASMInstruction> extraInstructions = new ArrayList<>();\n        extraInstructions.add(new ASMMov(new ASMTempExpr(extraTemp),new ASMConstExpr(c.value())));\n        c.bestInstructions = extraInstructions;\n        ASMTempExpr res = new ASMTempExpr(extraTemp);\n        c.tempName = res;\n        return res;\n    }\n    private ASMAbstractReg munchBinop(IRBinOp binop) {\n        // TODO: LATER ADD TEMP/CONST, TEMP/TEMP, CONST/TEMP, ELSE MUCH\n        long curBestCost = Long.MAX_VALUE;\n        ASMTempExpr destTemp = new ASMTempExpr(nxtTemp());\n        ArrayList<ASMInstruction> curBestInstructions = new ArrayList<>();\n        ASMAbstractReg l1 = munchIRExpr(binop.left());\n        ASMAbstractReg l2 = munchIRExpr(binop.right());\n\n        if (false) {\n\n        } else {\n\n            curBestInstructions.addAll(binop.left().getBestInstructions());\n            curBestInstructions.addAll(binop.right().getBestInstructions());\n\n            switch (binop.opType()) {\n                case ADD:\n                    if ( binop.left().getBestCost() +\n                            binop.right().getBestCost() + 2 < curBestCost) {\n                        curBestCost = binop.left().getBestCost() +\n                                binop.right().getBestCost() + 2;\n                        curBestInstructions.add(new ASMMov(destTemp, l1));\n                        curBestInstructions.add(new ASMAdd(destTemp, l2));\n                    }\n                    break;\n                case MUL:\n                    if (binop.left().getBestCost() +\n                            binop.right().getBestCost() + 2 < curBestCost) {\n                        curBestCost = binop.left().getBestCost() +\n                                binop.right().getBestCost() + 2;\n                        curBestInstructions.add(new ASMMov(destTemp, l1));\n                        curBestInstructions.add(new ASMIMul(destTemp, l2));\n                    }\n                    break;\n                case DIV: // rax/div, store result in rax and remainder in rdx\n                    if (binop.left().getBestCost() +\n                            binop.right().getBestCost() + 3 < curBestCost) {\n                        curBestCost = binop.left().getBestCost() +\n                                binop.right().getBestCost() + 3;\n//                        curBestInstructions.add(new ASMXor(new ASMRegisterExpr(\"rdx\"),new ASMRegisterExpr(\"rdx\")));\n                        curBestInstructions.add(new ASMMov(new ASMRegisterExpr(\"rax\"), l1));\n                        curBestInstructions.add(new ASMCQTO());\n                        curBestInstructions.add(new ASMIDiv(l2));\n                        curBestInstructions.add(new ASMMov(destTemp, new ASMRegisterExpr(\"rax\")));\n                    }\n                    break;\n                case SUB:\n                    if (binop.left().getBestCost() +\n                            binop.right().getBestCost() + 2 < curBestCost) {\n                        curBestCost = binop.left().getBestCost() +\n                                binop.right().getBestCost() + 2;\n                        curBestInstructions.add(new ASMMov(destTemp, l1));\n                        curBestInstructions.add(new ASMArg2(ASMOpCodes.SUB, destTemp, l2));\n                    }\n                    break;\n                case HMUL: // TODO: fix this\n                    if (binop.left().getBestCost() +\n                            binop.right().getBestCost() + 3 < curBestCost) {\n                        curBestCost = binop.left().getBestCost() +\n                                binop.right().getBestCost() + 3;\n\n                        curBestInstructions.add(new ASMMov(new ASMRegisterExpr(\"rax\"), l1));\n                        curBestInstructions.add(new ASMIMul(l2));\n                        curBestInstructions.add(new ASMMov(destTemp, new ASMRegisterExpr(\"rdx\")));\n                    }\n                    break;\n                case MOD: // rax/div, store result in rax and remainder in rdx\n                    if (binop.left().getBestCost() +\n                            binop.right().getBestCost() + 3 < curBestCost) {\n                        curBestCost = binop.left().getBestCost() +\n                                binop.right().getBestCost() + 3;\n//                        curBestInstructions.add(new ASMXor(new ASMRegisterExpr(\"rdx\"),new ASMRegisterExpr(\"rdx\")));\n                        curBestInstructions.add(new ASMMov(new ASMRegisterExpr(\"rax\"), l1));\n                        curBestInstructions.add(new ASMCQTO());\n                        curBestInstructions.add(new ASMIDiv(l2));\n                        curBestInstructions.add(new ASMMov(destTemp, new ASMRegisterExpr(\"rdx\")));\n                    }\n                    break;\n                case AND:\n                    if (binop.left().getBestCost() +\n                            binop.right().getBestCost() + 2 < curBestCost) {\n                        curBestCost = binop.left().getBestCost() +\n                                binop.right().getBestCost() + 2;\n                        curBestInstructions.add(new ASMMov(destTemp, l1));\n                        curBestInstructions.add(new ASMAnd(destTemp, l2));\n                    }\n                    break;\n                case OR:\n                    if (binop.left().getBestCost() +\n                            binop.right().getBestCost() + 2 < curBestCost) {\n                        curBestCost = binop.left().getBestCost() +\n                                binop.right().getBestCost() + 2;\n                        curBestInstructions.add(new ASMMov(destTemp, l1));\n                        curBestInstructions.add(new ASMOr(destTemp, l2));\n                    }\n                    break;\n                case XOR:\n                    if (binop.left().getBestCost() +\n                            binop.right().getBestCost() + 2 < curBestCost) {\n                        curBestCost = binop.left().getBestCost() +\n                                binop.right().getBestCost() + 2;\n                        curBestInstructions.add(new ASMMov(destTemp, l1));\n                        curBestInstructions.add(new ASMXor(destTemp, l2));\n                    }\n                    break;\n                case LSHIFT: // logical left shift\n                    if (binop.left().getBestCost() +\n                            binop.right().getBestCost() + 2 < curBestCost) {\n                        curBestCost = binop.left().getBestCost() +\n                                binop.right().getBestCost() + 2;\n                        curBestInstructions.add(new ASMMov(destTemp, l1));\n                        curBestInstructions.add(new ASMShl(destTemp, l2));\n                    }\n                    break;\n                case RSHIFT: // logical right shift\n                    if (binop.left().getBestCost() +\n                            binop.right().getBestCost() + 2 < curBestCost) {\n                        curBestCost = binop.left().getBestCost() +\n                                binop.right().getBestCost() + 2;\n                        curBestInstructions.add(new ASMMov(destTemp, l1));\n                        curBestInstructions.add(new ASMShr(destTemp, l2));\n                    }\n                    break;\n                case ARSHIFT:\n                    if (binop.left().getBestCost() +\n                            binop.right().getBestCost() + 2 < curBestCost) {\n                        curBestCost = binop.left().getBestCost() +\n                                binop.right().getBestCost() + 2;\n                        curBestInstructions.add(new ASMMov(destTemp, l1));\n                        curBestInstructions.add(new ASMSar(destTemp, l2));\n                    }\n                    break;\n                case EQ:\n                    if (binop.left().getBestCost() +\n                            binop.right().getBestCost() + 4 < curBestCost) {\n                        curBestCost = binop.left().getBestCost() +\n                                binop.right().getBestCost() + 4;\n                        curBestInstructions.add(new ASMMov(destTemp, l1));\n                        curBestInstructions.add(new ASMCmp(destTemp, l2));\n                        curBestInstructions.add(new ASMSete(new ASMRegisterExpr(\"al\")));\n                        curBestInstructions.add(new ASMAnd(new ASMRegisterExpr(\"rax\"), new ASMConstExpr(1)));\n                        curBestInstructions.add(new ASMMov(destTemp, new ASMRegisterExpr(\"rax\")));\n                    }\n                    break;\n                case NEQ:\n                    if (binop.left().getBestCost() +\n                            binop.right().getBestCost() + 4 < curBestCost) {\n                        curBestCost = binop.left().getBestCost() +\n                                binop.right().getBestCost() + 4;\n                        curBestInstructions.add(new ASMMov(destTemp, l1));\n                        curBestInstructions.add(new ASMCmp(destTemp, l2));\n                        curBestInstructions.add(new ASMSetne(new ASMRegisterExpr(\"al\")));\n                        curBestInstructions.add(new ASMAnd(new ASMRegisterExpr(\"rax\"), new ASMConstExpr(1)));\n//                instrs.add(new ASMAnd(al, new ASMConstExpr(1))); in clang but not in gcc\n                        curBestInstructions.add(new ASMMov(destTemp, new ASMRegisterExpr(\"rax\")));\n                    }\n                    break;\n                case LT:\n                    if (binop.left().getBestCost() +\n                            binop.right().getBestCost() + 4 < curBestCost) {\n                        curBestCost = binop.left().getBestCost() +\n                                binop.right().getBestCost() + 4;\n                        curBestInstructions.add(new ASMMov(destTemp, l1));\n                        curBestInstructions.add(new ASMCmp(destTemp, l2));\n                        curBestInstructions.add(new ASMSetl(new ASMRegisterExpr(\"al\")));\n                        curBestInstructions.add(new ASMAnd(new ASMRegisterExpr(\"rax\"), new ASMConstExpr(1)));\n//                instrs.add(new ASMAnd(al, new ASMConstExpr(1))); in clang but not in gcc\n                        curBestInstructions.add(new ASMMov(destTemp, new ASMRegisterExpr(\"rax\")));\n                    }\n                    break;\n                case ULT:\n                    if (binop.left().getBestCost() +\n                            binop.right().getBestCost() + 4 < curBestCost) {\n                        curBestCost = binop.left().getBestCost() +\n                                binop.right().getBestCost() + 4;\n                        curBestInstructions.add(new ASMMov(destTemp, l1));\n                        curBestInstructions.add(new ASMCmp(destTemp, l2));\n                        curBestInstructions.add(new ASMSetb(new ASMRegisterExpr(\"al\")));\n                        curBestInstructions.add(new ASMAnd(new ASMRegisterExpr(\"rax\"), new ASMConstExpr(1)));\n                        //                instrs.add(new ASMAnd(al, new ASMConstExpr(1))); in clang but not in gcc\n                        curBestInstructions.add(new ASMMov(destTemp, new ASMRegisterExpr(\"rax\")));\n                    }\n                    break;\n                case GT:\n                    if (binop.left().getBestCost() +\n                            binop.right().getBestCost() + 4 < curBestCost) {\n                        curBestCost = binop.left().getBestCost() +\n                                binop.right().getBestCost() + 4;\n                        curBestInstructions.add(new ASMMov(destTemp, l1));\n                        curBestInstructions.add(new ASMCmp(destTemp, l2));\n                        curBestInstructions.add(new ASMSetg(new ASMRegisterExpr(\"al\")));\n                        curBestInstructions.add(new ASMAnd(new ASMRegisterExpr(\"rax\"), new ASMConstExpr(1)));\n//                instrs.add(new ASMAnd(al, new ASMConstExpr(1))); in clang but not in gcc\n                        curBestInstructions.add(new ASMMov(destTemp, new ASMRegisterExpr(\"rax\")));\n                    }\n                    break;\n                case LEQ:\n                    if (binop.left().getBestCost() +\n                            binop.right().getBestCost() + 4 < curBestCost) {\n                        curBestCost = binop.left().getBestCost() +\n                                binop.right().getBestCost() + 4;\n                        curBestInstructions.add(new ASMMov(destTemp, l1));\n                        curBestInstructions.add(new ASMCmp(destTemp, l2));\n                        curBestInstructions.add(new ASMSetle(new ASMRegisterExpr(\"al\")));\n                        curBestInstructions.add(new ASMAnd(new ASMRegisterExpr(\"rax\"), new ASMConstExpr(1)));\n//                instrs.add(new ASMAnd(al, new ASMConstExpr(1))); in clang but not in gcc\n                        curBestInstructions.add(new ASMMov(destTemp, new ASMRegisterExpr(\"rax\")));\n                    }\n                    break;\n                case GEQ:\n                    if (binop.left().getBestCost() +\n                            binop.right().getBestCost() + 4 < curBestCost) {\n                        curBestCost = binop.left().getBestCost() +\n                                binop.right().getBestCost() + 4;\n                        curBestInstructions.add(new ASMMov(destTemp, l1));\n                        curBestInstructions.add(new ASMCmp(destTemp, l2));\n                        curBestInstructions.add(new ASMSetge(new ASMRegisterExpr(\"al\")));\n                        curBestInstructions.add(new ASMAnd(new ASMRegisterExpr(\"rax\"), new ASMConstExpr(1)));\n//                instrs.add(new ASMAnd(al, new ASMConstExpr(1))); in clang but not in gcc\n                        curBestInstructions.add(new ASMMov(destTemp, new ASMRegisterExpr(\"rax\")));\n                    }\n                    break;\n            }\n        }\n        binop.bestInstructions = curBestInstructions;\n        binop.bestCost = curBestCost;\n        binop.visited = true;\n        binop.tempName = destTemp;\n        return destTemp;\n    }\n\n\n\n\n    public ArrayList<ASMInstruction> visit(IRSeq node){\n        ArrayList<ASMInstruction> instructions = new ArrayList<>();\n        for (IRStmt stmt : node.stmts()) {\n            ArrayList<ASMInstruction> stmtInstrs = stmt.accept(this);\n            instructions.addAll(stmtInstrs);\n        }\n        return instructions;\n    }\n    public ArrayList<ASMInstruction> visit(IRReturn node) {\n        //\n        ArrayList<ASMInstruction> returnInstructions = new ArrayList<>();\n        int returnSize = node.rets().size();\n\n        ArrayList<String> tempNames = new ArrayList<>();\n        //in case returns stop being temporaries in the future.\n        for (IRExpr e: node.rets()){\n             if (e instanceof IRTemp t){\n                tempNames.add(t.name());\n             }else{\n                 System.out.println(\"return is not a temp? \" + e);\n                 String nxtName = nxtTemp();\n                 tempNames.add(nxtName);\n//                 ASMTempExpr tmp = new ASMTempExpr(nxtName);\n                 // need to translate\n                 throw new InternalCompilerError(\"return has an element that isn't a temp\");\n             }\n        }\n//        functionToTemps.get(curFunction).addAll(tempNames);\n        // looping in reverse so rax can be used temporarily until the end\n        for (int i = 1; i <= returnSize; i++) {\n            // move expression to Return Location\n            // Move ret into reti. reti <- RDI\n            ASMExpr retI = switch (i) {\n                case 1 -> new ASMRegisterExpr(\"rax\");\n                case 2 -> new ASMRegisterExpr(\"rdx\");\n                default -> new ASMMemExpr(\n                        new ASMBinOpAddExpr(\n                                new ASMTempExpr(\"_returnBase\"),\n                                new ASMConstExpr(8L*(i-3))));\n            };\n//\n//            if (i >2){\n//                if (i == 3){\n//                    returnInstructions.add(new ASMMov(new ASMRegisterExpr(\"rsi\"),\n//                            new ASMTempExpr(\"_returnBase\")));\n//                }\n//                System.out.println(\"greater than 3\");\n//                // just in case we just put everything on the stack lol need intermediate\n//                // rcx <- [origin]\n//                returnInstructions.add(new ASMMov(new ASMRegisterExpr(\"rcx\"),new ASMTempExpr(tempNames.get(i-1)))); // check this\n//                // [dest] <- rcx\n//                returnInstructions.add(new ASMMov(retI,new ASMRegisterExpr(\"rcx\")));\n//            }else{\n//                returnInstructions.add(new ASMMov(retI,new ASMTempExpr(tempNames.get(i-1))));\n//            }\n            returnInstructions.add(new ASMMov(retI,new ASMTempExpr(tempNames.get(i-1))));\n        }\n\n        // leave\n        // ret\n        returnInstructions.add(new ASMLeave());\n        returnInstructions.add(new ASMRet());\n        return returnInstructions;\n    }\n    public ArrayList<ASMInstruction> visit(IRCallStmt node) {\n        ArrayList<ASMInstruction> instructions = new ArrayList<>();\n        IRName functionName = (IRName) node.target();\n        int argSiz = node.args().size();\n        ArrayList<String> tempNames = new ArrayList<>();\n        //in case returns stop being temporaries in the future.\n        // Will have to revisit translation too if we change iRCALLSTMT\n        // Move the Push translations to later\n        for (IRExpr e: node.args()){\n            if (e instanceof IRTemp t){\n                tempNames.add(t.name());\n            }else{\n                System.out.println(\"call is not a temp? \" + e);\n                String nxtName = nxtTemp();\n                tempNames.add(nxtName);\n                ASMTempExpr tmp = new ASMTempExpr(nxtName);\n                // need to translate\n                throw new InternalCompilerError(\"return has an element that isn't a temp\");\n            }\n        }\n//        functionToTemps.get(curFunction).addAll(tempNames);\n        instructions.add(new ASMComment(\"Add Padding\",functionName.name()));\n        // add extra stack space for returns\n        if (node.n_returns() >2){\n            instructions.add(new ASMSub(\n                    new ASMRegisterExpr(\"rsp\"),\n                    new ASMConstExpr(8* (node.n_returns()-2))));\n            instructions.add(new ASMMov(\n                    new ASMRegisterExpr(\"rdi\"),\n                    new ASMRegisterExpr(\"rsp\")));\n        }\n        // pushes for Arguments\n        if (argSiz >= 6){\n            int end = node.n_returns() > 2 ? 6 : 7;\n            int ind = tempNames.size();\n            while (ind >= end){\n                instructions.add(new ASMPush(new ASMTempExpr(tempNames.get(ind-1))));\n                ind--;\n            }\n        }\n        int start = node.n_returns() > 2 ? Math.min(argSiz+1,6): Math.min(argSiz,6);\n        int end = node.n_returns() > 2 ? 2 : 1;\n        for (int i = start; i >= end; i--) {\n            // move expression from temp to required register\n            // Move ret into reti. reti <- RDI\n            ASMExpr argI = switch (i) {\n                case 1 -> new ASMRegisterExpr(\"rdi\");\n                case 2 -> new ASMRegisterExpr(\"rsi\");\n                case 3 -> new ASMRegisterExpr(\"rdx\");\n                case 4 -> new ASMRegisterExpr(\"rcx\");\n                case 5 -> new ASMRegisterExpr(\"r8\");\n                case 6 -> new ASMRegisterExpr(\"r9\");\n                default -> throw new InternalCompilerError(\"should not be in default for Function Call\");\n            };\n            int loc = node.n_returns() > 2? i-2: i-1;\n            String tempName = tempNames.get(loc);\n            instructions.add(new ASMMov(argI,new ASMTempExpr(tempName)));\n        }\n        // Align by 16 bytes I have no idea how\n        functionsNameToSig.put(functionName.name(),new Pair<>(argSiz,node.n_returns().intValue()));\n        instructions.add(new ASMCall(new ASMNameExpr(functionName.name())));\n\n        if (argSiz > 6 && node.n_returns() <= 2){\n            instructions.add(new ASMAdd(new ASMRegisterExpr(\"rsp\"),\n                    new ASMConstExpr(8L*(argSiz-6))));\n        }else if (argSiz > 5 && node.n_returns() > 2){\n            instructions.add(new ASMAdd(new ASMRegisterExpr(\"rsp\"),\n                    new ASMConstExpr(8L*(argSiz-5))));\n        }\n        String ret = \"_RV\";\n        for (int i = 1; i<= node.n_returns();i++){\n            ASMTempExpr temp = new ASMTempExpr(ret+i);\n            if (i == 1){\n                instructions.add(new ASMMov(temp,new ASMRegisterExpr(\"rax\")));\n            }else if (i == 2){\n                instructions.add(new ASMMov(temp,new ASMRegisterExpr(\"rdx\")));\n            }else{\n                instructions.add(new ASMPop(temp));\n            }\n        }\n        instructions.add(new ASMComment(\"Undo Padding\",functionName.name()));\n        return instructions;\n    }\n\n    public ArrayList<ASMInstruction> visit(IRExp irExp) {\n        System.out.println(\"don't have irExp\");\n        return new ArrayList<>();\n    }\n\n    public ArrayList<ASMInstruction> visit(IRTemp irTemp) {\n        return null;\n    }\n\n    public ArrayList<ASMInstruction> visit(IRName irName) {\n        return null;\n    }\n\n    public ArrayList<ASMInstruction> visit(IRMem irMem) {\n        return null;\n    }\n\n    public ArrayList<ASMInstruction> visit(IRBinOp irBinOp) {\n        return null;\n    }\n\n    public ArrayList<ASMInstruction> visit(IRESeq ireSeq) {\n        System.out.println(\"don't have ireSeq\");\n        return new ArrayList<>();\n    }\n\n    public ArrayList<ASMInstruction> visit(IRCall irCall) {\n        System.out.println(\"don't have irCall\");\n        return new ArrayList<>();\n    }\n\n    // add/sub/xor/imul dest, src // dest += src; dest -= src; dest ^= src; dest *= src;\n\n    /**\n     * Checks if the IRBinop can be reduced to Two Arguments\n     * @param b IRBinop node to check\n     * @return the binop can be reduced to two arg asm instruction eg a = a * t1\n     */\n    private boolean twoOpArith(IRBinOp b){\n        return (b.opType() == IRBinOp.OpType.ADD)\n                || (b.opType() == IRBinOp.OpType.SUB)\n                || (b.opType() == IRBinOp.OpType.XOR)\n                || (b.opType() == IRBinOp.OpType.MUL);\n    }\n\n    /**\n     * Converts the IRBinop Instruction to the Corresponding ASM Opcode\n     * @param b IRBinop to Check\n     * @return The ASMOpCode\n     */\n    private ASMOpCodes irOpToASMOp(IRBinOp b){\n        return switch (b.opType()){\n            case ADD -> ASMOpCodes.ADD;\n            case SUB -> ASMOpCodes.SUB;\n            case MUL, HMUL -> ASMOpCodes.IMUL;\n            case DIV, MOD -> ASMOpCodes.IDIV;\n            case AND -> ASMOpCodes.AND;\n            case OR -> ASMOpCodes.OR;\n            case XOR -> ASMOpCodes.XOR;\n            case LSHIFT, ARSHIFT, RSHIFT -> throw new InternalCompilerError(\"NO ASM SHIFT\");\n            case EQ -> ASMOpCodes.SETE;\n            case NEQ -> ASMOpCodes.SETNE;\n            case LT -> ASMOpCodes.SETL;\n            case ULT -> ASMOpCodes.SETB;\n            case GT -> ASMOpCodes.SETG;\n            case LEQ -> ASMOpCodes.SETLE;\n            case GEQ -> ASMOpCodes.SETGE;\n            case UGE -> ASMOpCodes.SETAE;\n        };\n    }\n\n    /**\n     * Returns the ASMDirective Type in ASM\n     * @param name string to Check\n     * @return the asm Directive\n     */\n    private ASMDirectives getType(String name) {\n        String type = name.split(\"_\")[0];\n        if (type.equals(\"i\") || type.equals(\"b\")) {\n            return ASMDirectives.QUAD;\n        }\n        return ASMDirectives.ZERO;\n    }\n}\n\n//    int index = numParams;\n//            while (index < seq.stmts().size()){\n//        IRStmt stmt = seq.stmts().get(index);\n//        bodyInstructions.addAll(stmt.accept(this));\n//        if (stmt instanceof IRCallStmt call){\n//        int rvMoves = Math.toIntExact(call.n_returns());\n//        for (int i = 1; i <= rvMoves;i++){\n//        int getInd = (rvMoves + i-1);\n//        IRMove nameAndArg = (IRMove) body.stmts().get(getInd);\n//        IRTemp name = (IRTemp) nameAndArg.target();\n//        ASMTempExpr retName = new ASMTempExpr(name.name());\n//        if (i == 1){\n//        bodyInstructions.add(new ASMMov(retName,new ASMRegisterExpr(\"rax\")));\n//        }else if (i == 2){\n//        bodyInstructions.add(new ASMMov(retName,new ASMRegisterExpr(\"rdx\")));\n//        }else{\n//        bodyInstructions.add(new ASMPop(retName));\n//        }\n//        }\n//        index += rvMoves+1;\n//        }else{\n//        index++;\n//        }\n//        }
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/aar226_akc55_ayc62_ahl88/src/edu/cornell/cs/cs4120/xic/ir/visit/AbstractASMVisitor.java b/src/main/java/aar226_akc55_ayc62_ahl88/src/edu/cornell/cs/cs4120/xic/ir/visit/AbstractASMVisitor.java
--- a/src/main/java/aar226_akc55_ayc62_ahl88/src/edu/cornell/cs/cs4120/xic/ir/visit/AbstractASMVisitor.java	(revision 797405cf6bacf019917fce020c4269b44f9b7c9c)
+++ b/src/main/java/aar226_akc55_ayc62_ahl88/src/edu/cornell/cs/cs4120/xic/ir/visit/AbstractASMVisitor.java	(date 1681329765705)
@@ -271,6 +271,7 @@
         IRExpr dest = node.target();
         IRExpr source = node.source();
         ArrayList<ASMInstruction> instructions = new ArrayList<>();
+        instructions.add(new ASMComment(node.toString(),null));
 
         // TEMP TEMP
         if (dest instanceof IRTemp t1 && source instanceof IRTemp t2) { // random case for testing atm
Index: src/main/java/aar226_akc55_ayc62_ahl88/Main.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package aar226_akc55_ayc62_ahl88;\n\nimport aar226_akc55_ayc62_ahl88.Errors.EtaError;\nimport aar226_akc55_ayc62_ahl88.SymbolTable.SymbolTable;\nimport aar226_akc55_ayc62_ahl88.asm.ASMCompUnit;\nimport aar226_akc55_ayc62_ahl88.asm.ASMData;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.ASMInstruction;\nimport aar226_akc55_ayc62_ahl88.asm.Instructions.ASMLabel;\nimport aar226_akc55_ayc62_ahl88.asm.visit.RegisterAllocationTrivialVisitor;\nimport aar226_akc55_ayc62_ahl88.newast.Program;\nimport aar226_akc55_ayc62_ahl88.newast.interfaceNodes.EtiInterface;\nimport aar226_akc55_ayc62_ahl88.src.edu.cornell.cs.cs4120.xic.ir.IRCompUnit;\nimport aar226_akc55_ayc62_ahl88.src.edu.cornell.cs.cs4120.xic.ir.IRNode;\nimport aar226_akc55_ayc62_ahl88.src.edu.cornell.cs.cs4120.xic.ir.IRNodeFactory_c;\nimport aar226_akc55_ayc62_ahl88.src.edu.cornell.cs.cs4120.xic.ir.interpret.IRSimulator;\nimport aar226_akc55_ayc62_ahl88.src.edu.cornell.cs.cs4120.xic.ir.visit.AbstractASMVisitor;\nimport aar226_akc55_ayc62_ahl88.src.edu.cornell.cs.cs4120.xic.ir.visit.CheckCanonicalIRVisitor;\nimport aar226_akc55_ayc62_ahl88.src.edu.cornell.cs.cs4120.xic.ir.visit.CheckConstFoldedIRVisitor;\nimport aar226_akc55_ayc62_ahl88.src.edu.cornell.cs.cs4120.xic.ir.visit.IRLoweringVisitor;\nimport aar226_akc55_ayc62_ahl88.visitors.IRVisitor;\nimport java_cup.runtime.Symbol;\nimport java_cup.runtime.lr_parser;\nimport org.apache.commons.cli.*;\nimport java.io.*;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\n\nimport aar226_akc55_ayc62_ahl88.src.edu.cornell.cs.cs4120.util.CodeWriterSExpPrinter;\n\npublic class Main {\n    enum Target {\n        LINUX,\n        WINDOWS,\n        MACOS\n    }\n\n    private static String outputAsmDirectory;\n    private static String outputDiagnosticDirectory;\n    private static String inputDirectory;\n    public static String libpathDirectory;\n\n    private static boolean isOutputAsmDirSpecified;\n    private static boolean isOutputDiagnosticDirSpecified;\n    private static boolean isInputDirSpecified;\n    public static boolean isLibpathDirSpecified;\n\n    public static Optimizations opts;\n\n    private static Target target;\n\n    // Write the lexed string into the corresponding file name\n    private static void writeOutputGeneric(String filename, String output, String extension, boolean isAsm) {\n        Path path;\n        Path path1 = Paths.get(filename);\n\n        if (!isAsm) {\n            path = (isOutputDiagnosticDirSpecified)\n                    ? Paths.get(outputDiagnosticDirectory, filename)\n                    : path1;\n        }\n        else {\n            path = (isOutputAsmDirSpecified)\n                    ? Paths.get(outputAsmDirectory, filename)\n                    : path1;\n        }\n\n        String pathname = path.toString();\n        pathname = pathname.substring(0, pathname.length() - 3) + extension;\n//        System.out.println(pathname);\n        Path parentPath = path.getParent();\n        String dirname = (parentPath == null) ? \"\" : parentPath.toString();\n//        System.out.println(dirname);\n        // Create directory\n        File dir = new File(dirname);\n        dir.mkdirs();\n\n        // Create file\n        try {\n            File file = new File(pathname);\n            file.createNewFile();\n        }\n        catch (IOException e) {\n            System.out.println(\"An error occurred when creating the file \" + filename);\n            return;\n        }\n\n        // Write to file\n        try {\n            FileWriter myWriter = new FileWriter(pathname);\n\n            myWriter.write(output);\n            myWriter.close();\n        }\n        catch (IOException e) {\n            System.out.println(\"An error occurred when writing to the file \" + filename);\n        }\n    }\n\n    private static void writeOutput(String filename, String output, String extension) {\n        writeOutputGeneric(filename, output, extension, false);\n    }\n\n    private static void writeOutputAsm(String filename, String output, String extension) {\n        writeOutputGeneric(filename, output, extension, true);\n    }\n\n    private static String prettyOut(Symbol s){\n        String out = s.value().toString();\n        switch (s.sym){\n            case (sym.INTEGER_LITERAL):\n                if (out.length() > 1){\n                    out = out.substring(1);\n                }\n                out = \"integer \" + out;\n                break;\n            case (sym.BOOL_LITERAL):\n                out = \"boolean \" + out;\n                break;\n            case (sym.IDENTIFIER):\n                out = \"id \" +  out;\n                break;\n            case (sym.CHARACTER_LITERAL):\n                out = \"character \" +  out;\n                break;\n            case (sym.STRING_LITERAL):\n                out = \"string \" + out;\n                break;\n            default:\n                break;\n        }\n        return String.format(\"%d:%d %s\\n\", s.left, s.right, out);\n    }\n\n    private static String getZhenFilename(String filename) {\n        return (isInputDirSpecified)\n                ? Paths.get(inputDirectory, filename).toString()\n                : filename;\n    }\n\n    private static void lexFile(String filename, StringBuilder lexedOutput, boolean shouldWrite) throws IOException {\n        try {\n            if (filename.endsWith(\".eta\") || filename.endsWith(\".eti\")) {\n                String zhenFilename = getZhenFilename(filename);\n\n                Lexer etaLexer;\n                try {\n                    etaLexer = new Lexer(new FileReader(zhenFilename));\n                } catch (Exception e) {\n                    System.out.println(\"File without name \" + filename + \" found\");\n                    return;\n                }\n\n                try {\n                    while (true) {\n                        Symbol t = etaLexer.next_token();\n                        if (t.sym == sym.EOF) break;\n                        String lexed = prettyOut(t);\n                        lexedOutput.append(lexed);\n                    }\n                }\n                catch (EtaError e) {\n                    lexedOutput.append(e.getMessage());\n                }\n            }\n            else {\n                throw new FileNotFoundException(\n                        \"Invalid filename \"\n                                + filename\n                                + \" provided: All files passed to etac must have a .eta extension\");\n            }\n        }\n        catch (FileNotFoundException invalidFilename) {\n            System.out.println(invalidFilename.getMessage());\n            return;\n        }\n\n        if (shouldWrite) {\n            writeOutput(filename, lexedOutput.toString(), \"lexed\");\n        }\n    }\n\n    private static void parseFile(String filename, boolean shouldWrite) throws IOException {\n        try {\n            String zhenFilename = getZhenFilename(filename);\n\n            Lexer lex;\n            try {\n                lex = new Lexer(new FileReader(zhenFilename));\n            } catch (Exception e) {\n                System.out.println(\"File without name \" + filename + \" found\");\n                return;\n            }\n\n            lr_parser p = null;\n            if (filename.endsWith(\".eta\")) p = new EtaParser(lex);\n            else if (filename.endsWith(\".eti\")) p = new EtiParser(lex);\n            else throw new FileNotFoundException(\n                        \"Invalid filename \"\n                                + filename\n                                + \" provided: All files passed to etac must have a .eta extension\");\n\n            try {\n                StringWriter out = new StringWriter();\n                PrintWriter cw = new PrintWriter(out);\n                CodeWriterSExpPrinter printer = new CodeWriterSExpPrinter(cw);\n\n                if (filename.endsWith(\".eta\")) {\n                    Program result = (Program) p.parse().value;\n                    result.prettyPrint(printer);\n                }\n                else if (filename.endsWith(\".eti\")) {\n                    EtiInterface result = (EtiInterface) p.parse().value;\n                    result.prettyPrint(printer);\n                }\n\n                printer.close();\n                if (shouldWrite) {\n                    writeOutput(filename, out.toString(), \"parsed\");\n                }\n            } catch (EtaError e) {\n                if (shouldWrite) {\n                    writeOutput(filename, e.getMessage(), \"parsed\");\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n                System.out.println(\"File without name \" + filename + \" found\");\n            }\n        }\n        catch (FileNotFoundException invalidFilename) {\n            System.out.println(invalidFilename.getMessage());\n        }\n    }\n\n    private static void typeCheckFile(String filename, boolean shouldWrite) throws IOException {\n        try {\n            String zhenFilename = getZhenFilename(filename);\n\n            Lexer lex = null;\n            try {\n                lex = new Lexer(new FileReader(zhenFilename));\n            } catch (Exception e) {\n                System.out.println(\"No file found with filename \" + filename);\n                return;\n            }\n\n            lr_parser p;\n            if (filename.endsWith(\".eta\")) p = new EtaParser(lex);\n            else if (filename.endsWith(\".eti\")) p = new EtiParser(lex);\n            else throw new FileNotFoundException(\n                        \"Invalid filename \"\n                                + filename\n                                + \" provided: All files passed to etac must have a .eta extension\");\n\n            try {\n                if (filename.endsWith(\".eta\")) {\n                    Program result = (Program) p.parse().value;\n                    result.typeCheck(new SymbolTable<>(), zhenFilename);\n                } else if (filename.endsWith(\".eti\")) {\n                    EtiInterface result = (EtiInterface) p.parse().value;\n                    result.firstPass(); // Just to throw EtaErrors\n                }\n\n                if (shouldWrite) {\n                    writeOutput(filename, \"Valid Eta Program\", \"typed\");\n                }\n            } catch (EtaError e) {\n                e.printError(zhenFilename);\n                if (shouldWrite) {\n                    writeOutput(filename, e.getMessage(), \"typed\");\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n                System.out.println(\"File without name \" + filename + \" found\");\n            }\n        }\n        catch (FileNotFoundException invalidFilename) {\n            System.out.println(invalidFilename.getMessage());\n        }\n    }\n\n\n\n    private static IRNode irbuild(String filename) throws Exception {\n        try {\n            String zhenFilename = getZhenFilename(filename);\n\n            Lexer lex;\n            try {\n                lex = new Lexer(new FileReader(zhenFilename));\n            } catch (Exception e) {\n                System.out.println(\"No file found with filename \" + filename);\n                return null;\n            }\n\n            lr_parser p;\n            if (filename.endsWith(\".eta\")) p = new EtaParser(lex);\n            else if (filename.endsWith(\".eti\")) p = new EtiParser(lex);\n            else throw new FileNotFoundException(\n                        \"Invalid filename \"\n                                + filename\n                                + \" provided: All files passed to etac must have a .eta extension\");\n\n            try {\n                if (filename.endsWith(\".eta\")) {\n                    Program result = (Program) p.parse().value;\n                    result.typeCheck(new SymbolTable<>(), zhenFilename);\n//                    filename.substring(0, filename.length() - 2)\n                    IRNode ir = result.accept(new IRVisitor(\"CompUnit\"));\n//                    {\n//                        StringWriter out = new StringWriter();\n//                        PrintWriter pw = new PrintWriter(out);\n//\n//                        CodeWriterSExpPrinter printer = new CodeWriterSExpPrinter(pw);\n//                        ir.printSExp(printer);\n//                        printer.close();\n//                        writeOutput(filename, out.toString(), \"irnoLower\");\n//                    }\n                    // IR constant-folding checker demo\n                    {\n                        CheckConstFoldedIRVisitor cv = new CheckConstFoldedIRVisitor();\n//                        System.out.print(\"Constant-folded?: \");\n//                        System.out.println(cv.visit(ir));\n                    }\n\n                    ir = new IRLoweringVisitor(new IRNodeFactory_c()).visit(ir);\n                    {\n                        CheckCanonicalIRVisitor cv = new CheckCanonicalIRVisitor();\n//                        System.out.print(\"Canonical?: \");\n//                        System.out.println(cv.visit(ir));\n                    }\n                    return ir;\n                } else if (filename.endsWith(\".eti\")) {\n                    EtiInterface result = (EtiInterface) p.parse().value;\n                    result.firstPass(); // Just to throw EtaErrors\n                }\n                else {\n                    System.out.println(\"Why are we here\");\n                }\n\n//                if (opts.isSet(OptimizationTypes.CONSTANT_FOLDING)) {\n//\n//                }\n\n            } catch (EtaError e) {\n                e.printError(zhenFilename);\n                throw e;\n            } catch (Exception e) {\n                e.printStackTrace();\n                throw e;\n            }\n        }\n        catch (FileNotFoundException invalidFilename) {\n            System.out.println(invalidFilename.getMessage());\n        }\n\n        return null;\n    }\n\n    private static void irgenFile(String filename, boolean shouldWrite) {\n        String zhenFilename = getZhenFilename(filename);\n\n        try {\n            IRNode ir = irbuild(zhenFilename);\n\n            StringWriter out = new StringWriter();\n            PrintWriter pw = new PrintWriter(out);\n\n            CodeWriterSExpPrinter printer = new CodeWriterSExpPrinter(pw);\n//            System.out.println(ir);\n//            System.out.println(ir instanceof IRCompUnit);\n            ir.printSExp(printer);\n\n            printer.close();\n\n            if (shouldWrite) {\n                writeOutput(filename, out.toString(), \"ir\");\n            }\n        }\n        catch (EtaError e) {\n            e.printError(zhenFilename);\n        }\n        catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void irrunFile(String filename, boolean shouldWrite) {\n        String zhenFilename = getZhenFilename(filename);\n\n        try {\n            IRNode ir = irbuild(zhenFilename);\n\n            StringWriter out = new StringWriter();\n            PrintWriter pw = new PrintWriter(out);\n\n            CodeWriterSExpPrinter printer = new CodeWriterSExpPrinter(pw);\n\n            IRSimulator sim = new IRSimulator((IRCompUnit) ir);\n            sim.call(\"_Imain_paai\", 0);\n            ir.printSExp(printer);\n\n            printer.close();\n\n            if (shouldWrite) {\n                writeOutput(filename, out.toString(), \"ir\");\n            }\n        }\n        catch (EtaError e) {\n            e.printError(zhenFilename);\n        }\n        catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static final String INDENT_SFILE = \"    \";\n    private static void asmGenFile(String filename, boolean shouldWrite) {\n        String zhenFilename = getZhenFilename(filename);\n\n        try {\n            // DO SHIT\n            IRNode ir = irbuild(zhenFilename);\n            ASMCompUnit comp = new AbstractASMVisitor().visit((IRCompUnit) ir);\n            System.out.println(comp.printInstructions());\n            ArrayList<ASMInstruction> postAlloc = new RegisterAllocationTrivialVisitor().visit(comp);\n            StringWriter out = new StringWriter();\n            out.write(INDENT_SFILE+ \".file  \\\"\"+zhenFilename+\"\\\"\\n\");\n            out.write(INDENT_SFILE+\".intel_syntax noprefix\\n\");\n            out.write(INDENT_SFILE+\".text\\n\");\n            out.write(INDENT_SFILE+\".globl  _Imain_paai\\n\");\n            out.write(INDENT_SFILE+\".type\t_Imain_paai, @function\\n\");\n            for (ASMInstruction instr: postAlloc){\n                if (!(instr instanceof ASMLabel)){\n                    out.write(INDENT_SFILE + instr + '\\n');\n                }else{\n                    out.write(instr+\"\\n\");\n                }\n            }\n            out.write(\"\\n\");\n            out.write(INDENT_SFILE+\".data\\n\");\n            for (ASMData data: comp.getGlobals()){\n                out.write(data.toString());\n            }\n            if (shouldWrite) {\n                writeOutputAsm(filename, out.toString(), \"s\");\n            }\n        }\n        catch (EtaError e) {\n            e.printError(zhenFilename);\n        }\n        catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void main(String[] args) throws java.io.IOException {\n        ArrayList<String> filenames = new ArrayList<>();\n        for (int i = args.length - 1; i >= 0; i--) {\n            if (args[i].endsWith(\".eta\") || args[i].endsWith(\".eti\")) {\n                filenames.add(args[i]);\n            }\n        }\n\n        // Create the command line parser\n        CommandLineParser parser = new DefaultParser();\n\n        // Create the Options\n        Options options = new Options();\n\n        Option helpOpt = new Option(\"h\", \"help\", false,\n                \"Print a synopsis of options.\");\n\n        Option lexOpt = new Option(null, \"lex\", false,\n                \"Generate output from lexical analysis.\");\n        Option parseOpt = new Option(null, \"parse\", false,\n                \"Generate output from syntactic analysis.\");\n        Option typeOpt = new Option(null, \"typecheck\", false,\n                \"Generate output from semantic analysis.\");\n        Option irgenOpt = new Option (null, \"irgen\", false,\n                \"Generate intermediate code.\");\n        Option irrunOpt = new Option (null, \"irrun\", false,\n                \"Generate and interpret intermediate code.\");\n\n\n        Option sourcepathOpt   = new Option (\"sourcepath\", true,\n                \"Specify where to find input source files.\");\n        Option libpathOpt = new Option (\"libpath\", true,\n                \"Specify where to find library interface files.\");\n\n        Option diagDirOpt   = new Option (\"D\", true,\n                \"Specify where to place generated diagnostic files.\");\n        Option asmDirOpt   = new Option (\"d\", true,\n                \"Specify where to place generated assembly output files.\");\n        Option optOpt   = new Option (\"O\", false,\n                \" Disable optimizations.\");\n\n        Option targetOpt = new Option(\"target\", true,\n                \"Specify the operating system for which to generate code.\");\n\n//        optOpt.setOptionalArg(true);\n\n        options.addOption(helpOpt);\n        options.addOption(lexOpt);\n        options.addOption(parseOpt);\n        options.addOption(typeOpt);\n        options.addOption(irgenOpt);\n        options.addOption(irrunOpt);\n\n        options.addOption(sourcepathOpt);\n        options.addOption(libpathOpt);\n\n        options.addOption(diagDirOpt);\n        options.addOption(asmDirOpt);\n\n        options.addOption(optOpt);\n        options.addOption(targetOpt);\n\n        HelpFormatter formatter = new HelpFormatter();\n\n        opts = new Optimizations();\n//        opts.setOptimizations(OptimizationTypes.CONSTANT_FOLDING, OptimizationTypes.IR_LOWERING);\n        opts.setOptimizations(OptimizationTypes.CONSTANT_FOLDING);\n\n        isOutputAsmDirSpecified = isOutputDiagnosticDirSpecified = isInputDirSpecified = isLibpathDirSpecified = false;\n        outputAsmDirectory = outputDiagnosticDirectory = inputDirectory = libpathDirectory =\n                Paths.get(\"\").toAbsolutePath().toString();\n        target = Target.LINUX;\n\n        boolean shouldAsmGen = true;\n\n//        System.out.println(outputDirectory);\n\n        try {\n            CommandLine cmd = parser.parse(options, args);\n            if (args.length == 0 || cmd.hasOption(\"help\")) {\n                formatter.printHelp(\"etac [options] <source files>\", options);\n                return;\n            }\n\n            if (cmd.hasOption(\"D\")) {\n                outputDiagnosticDirectory = cmd.getOptionValue(\"D\");\n                isOutputDiagnosticDirSpecified = true;\n            }\n\n            if (cmd.hasOption(\"d\")) {\n                outputAsmDirectory = cmd.getOptionValue(\"d\");\n                isOutputAsmDirSpecified = true;\n            }\n\n            if (cmd.hasOption(\"O\")) {\n                opts.clearOptimizations(OptimizationTypes.CONSTANT_FOLDING);\n            }\n\n            if (cmd.hasOption(\"sourcepath\")) {\n                inputDirectory = cmd.getOptionValue(\"sourcepath\");\n                isInputDirSpecified = true;\n            }\n\n            if (cmd.hasOption(\"libpath\")) {\n                libpathDirectory = cmd.getOptionValue(\"libpath\");\n                isLibpathDirSpecified = true;\n            }\n\n            if (cmd.hasOption(\"target\")) {\n                target = switch (cmd.getOptionValue(\"target\").toLowerCase()) {\n                    case \"linux\" -> Target.LINUX;\n                    case \"windows\" -> Target.WINDOWS;\n                    case \"macos\" -> Target.MACOS;\n                    default -> throw new IllegalStateException(\"Unexpected value: \" + cmd.getOptionValue(\"target\"));\n                };\n            }\n\n            if (cmd.hasOption(\"lex\")) {\n                shouldAsmGen = false;\n                for (String filename : filenames) {\n                    typeCheckFile(filename, false);\n                    lexFile(filename, new StringBuilder(), true);\n                }\n            }\n\n            if (cmd.hasOption(\"parse\")) {\n                shouldAsmGen = false;\n                for (String filename : filenames) {\n                    typeCheckFile(filename, false);\n                    parseFile(filename, true);\n                }\n            }\n\n            if (cmd.hasOption(\"typecheck\")) {\n                shouldAsmGen = false;\n                for (String filename : filenames) {\n                    typeCheckFile(filename, true);\n                }\n            }\n\n            if (cmd.hasOption(\"irgen\")) {\n                shouldAsmGen = false;\n                for (String filename : filenames) {\n                    irgenFile(filename, true);\n                }\n            }\n\n            if (cmd.hasOption(\"irrun\")) {\n                shouldAsmGen = false;\n                for (String filename : filenames) {\n                    irrunFile(filename, true);\n                }\n            }\n\n            if (shouldAsmGen) {\n                for (String filename : filenames) {\n                    asmGenFile(filename, true);\n                }\n            }\n        }\n        catch (ParseException parseException) {\n            formatter.printHelp(\"etac [options] <source files>\", options);\n            System.out.println(\"Unexpected exception: \" + parseException.getMessage());\n        }\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/aar226_akc55_ayc62_ahl88/Main.java b/src/main/java/aar226_akc55_ayc62_ahl88/Main.java
--- a/src/main/java/aar226_akc55_ayc62_ahl88/Main.java	(revision 797405cf6bacf019917fce020c4269b44f9b7c9c)
+++ b/src/main/java/aar226_akc55_ayc62_ahl88/Main.java	(date 1681330011143)
@@ -4,6 +4,7 @@
 import aar226_akc55_ayc62_ahl88.SymbolTable.SymbolTable;
 import aar226_akc55_ayc62_ahl88.asm.ASMCompUnit;
 import aar226_akc55_ayc62_ahl88.asm.ASMData;
+import aar226_akc55_ayc62_ahl88.asm.Instructions.ASMComment;
 import aar226_akc55_ayc62_ahl88.asm.Instructions.ASMInstruction;
 import aar226_akc55_ayc62_ahl88.asm.Instructions.ASMLabel;
 import aar226_akc55_ayc62_ahl88.asm.visit.RegisterAllocationTrivialVisitor;
